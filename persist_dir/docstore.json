{"docstore/data": {"dead65d2-4a16-4114-a700-20e926cbfb02": {"__data__": {"id_": "dead65d2-4a16-4114-a700-20e926cbfb02", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b4e94d5d-2aef-4b77-8b7c-ff7872c77e70", "node_type": "4", "metadata": {}, "hash": "78b7364febde99aaed85558436f30cbd657e9852b64428d8c8c8b8816fc0bba5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-789: Memory Allocation with Excessive Size Value\nDescription :\nThe product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated. \nExemple bonus\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nint main(int argc, char* argv[]){\n\tchar buff[0xF4250]; // dec: 1000016\n\tmalloc(0xF4250);\n\treturn 0;\n}\nExample: 1\nC\n(bad code)\u00a0\nunsigned int size = GetUntrustedInt();\n/* ignore integer overflow (CWE-190) for this example */ \nunsigned int totBytes = size * sizeof(char);\nchar *string = (char *)malloc(totBytes);\nInitializeString(string);\nExample: 2\nJava\n(bad code)\u00a0\nunsigned int size = GetUntrustedInt();\nHashMap list = new HashMap(size);\nExample: 3\nC\n(bad code)\u00a0\nint a = 5, b = 6;\n\t\t    size_t len = a - b;\n\t\t    char buf[len];    // Just blows up the stack\n\t\t  }\nExample: 4\nC\n(bad code)\u00a0\nint proc_msg(char *s, int msg_len)\n\t\t {\n// Note space at the end of the string - assume all strings have preamble with space\n\t\t    int pre_len = sizeof(\"preamble: \");\n\t\t    char buf[pre_len - msg_len];\n... Do processing here if we get this far\n\t\t  }\n\t\t  char *s = \"preamble: message\\n\";\n\t\t  char *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\n\t\t  int jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\n\t\t  int ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack\nExample: 5\nPerl\n(bad code)\u00a0\nmy $num = GetUntrustedNumber();\nmy @messages = ();\n$messages[$num] = \"Hello World\";\nExample: 6\nC\n(bad code)\u00a0\nint proc_msg(char *s, int msg_len)\n{\nint pre_len = sizeof(\"preamble: \");    // Note space at the end of the string - assume all strings have preamble with space\nchar buf[pre_len - msg_len];\n... Do processing here and set status\nreturn status;\n}\nchar *s = \"preamble: message\\n\";\nchar *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\nint jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\nint ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack", "start_char_idx": 0, "end_char_idx": 2242, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9feabfdf-ad6f-48b1-b4aa-c061f50d3d39": {"__data__": {"id_": "9feabfdf-ad6f-48b1-b4aa-c061f50d3d39", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f6ced86c-4f72-429c-9fbb-e50a4a053870", "node_type": "4", "metadata": {}, "hash": "fa83ca0fcf62d5c7e72ed01924e327ea308faf72f1d2fe1b15eefb7d3fe89b10", "class_name": "RelatedNodeInfo"}}, "text": "CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition\nDescription :\nThe product checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the product to perform invalid actions when the resource is in an unexpected state. \nExtended Description :\nThis weakness can be security-relevant when an attacker can influence the state of the resource between check and use. This can happen with shared resources such as files, memory, or even variables in multithreaded programs. \nExample: 1\nC\n(bad code)\u00a0\nstruct stat *sb;\n...\nlstat(\"...\",sb); // it has not been updated since the last time it was read\nprintf(\"stated file\\n\");\nif (sb->st_mtimespec==...){print(\"Now updating things\\n\");\nupdateThings();\n}\nExample: 2\nC\n(bad code)\u00a0\nif(!access(file,W_OK)) {f = fopen(file,\"w+\");\noperate(f);\n...\n}\nelse {\nfprintf(stderr,\"Unable to open file %s.\\n\",file);\n}\nExample: 3\nPHP\n(bad code)\u00a0\nfunction readFile($filename){\n$user = getCurrentUser();\n//resolve file if its a symbolic link\nif(is_link($filename)){$filename = readlink($filename);\n}\nif(fileowner($filename) == $user){echo file_get_contents($realFile);\nreturn;\n}\nelse{echo 'Access denied';\nreturn false;\n}\n}\nExample: 4\nC\n(bad code)\u00a0\n#include <sys/types.h>\n\t\t    #include <sys/stat.h>\n\t\t    ...\n\t\t      struct stat sb;\n\t\t      stat(\"MYFILE.txt\",&sb);\n\t\t      printf(\"file change time: %d\\n\",sb->st_ctime);\n\t\t      switch(sb->st_ctime % 2){\n\t\t        case 0: printf(\"Option 1\\n\"); break;\n\t\t        case 1: printf(\"Option 2\\n\"); break;\n\t\t        default: printf(\"this should be unreachable?\\n\"); break;\n}\nExemple bonus : \nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\nint main(){\n  if (access(\"file\", W_OK) != 0) {\n    exit(1);\n  }\n  char* buffer = malloc(6);\n  if(buffer == NULL){\n    exit(1);\n  }\n  memset(buffer, 1, 6);\n  int fd = open(\"file\", O_WRONLY);\n  write(fd, buffer, sizeof(buffer));\n  close(fd);\n  free(buffer);\n}", "start_char_idx": 0, "end_char_idx": 2089, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71f33c2f-9a04-4dcb-b01d-c6404314d105": {"__data__": {"id_": "71f33c2f-9a04-4dcb-b01d-c6404314d105", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c1d81e2e-c2b9-463b-8e6a-d535887f6abc", "node_type": "4", "metadata": {}, "hash": "7e868b859c9b963a9b5ecf30841a0e4f2ffaf39343a7f0439b1ebf4e146d1687", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1284: Improper Validation of Specified Quantity in Input\nDescription :\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties. \nExample: 1\nJava\n(bad code)\u00a0\n...\npublic static final double price = 20.00;\nint quantity = currentUser.getAttribute(\"quantity\");\ndouble total = price * quantity;\nchargeUser(total);\n...\nExample: 2\nC\n(bad code)\u00a0\n...\n#define MAX_DIM 100\n...\n/* board dimensions */\nint m,n, error;\nboard_square_t *board;\nprintf(\"Please specify the board height: \\n\");\nerror = scanf(\"%d\", &m);\nif ( EOF == error ){die(\"No integer passed: Die evil hacker!\\n\");\n}\nprintf(\"Please specify the board width: \\n\");\nerror = scanf(\"%d\", &n);\nif ( EOF == error ){die(\"No integer passed: Die evil hacker!\\n\");\n}\nif ( m > MAX_DIM || n > MAX_DIM ) {die(\"Value too large: Die evil hacker!\\n\");\n}\nboard = (board_square_t*) malloc( m * n * sizeof(board_square_t));\n...", "start_char_idx": 0, "end_char_idx": 993, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "61e6289e-f8ae-4d7e-af6b-c7bba3a213e1": {"__data__": {"id_": "61e6289e-f8ae-4d7e-af6b-c7bba3a213e1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5f198ad2-03ab-4461-adc6-adcfd4d6a7ff", "node_type": "4", "metadata": {}, "hash": "11254cd568fe4ffb584dcdbbc174688d4fa4083d2060d82a2b70f432dc8372b2", "class_name": "RelatedNodeInfo"}}, "text": "CWE-234: Failure to Handle Missing Parameter\nDescription :\nIf too few arguments are sent to a function, the function will still pop the expected number of arguments from the stack. Potentially, a variable number of arguments could be exhausted in a function as well. \nExample: 1\nC\n(bad code)\u00a0\nfoo_funct(one, two);\nvoid foo_funct(int one, int two, int three) {printf(\"1) %d\\n2) %d\\n3) %d\\n\", one, two, three);\n}", "start_char_idx": 0, "end_char_idx": 410, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3fd9424c-6ad1-46f6-a087-0a055bf18433": {"__data__": {"id_": "3fd9424c-6ad1-46f6-a087-0a055bf18433", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0610fd12-2d82-4a57-bbab-a94e2a5fa49e", "node_type": "4", "metadata": {}, "hash": "1b7fde4945588187ee673cf8178f23fed8df1a9ff526fdcd7fc4c4c998c086ca", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4b11c241-e09c-4545-bd09-085fb192008d", "node_type": "1", "metadata": {}, "hash": "8cce7d2d3452781f2a6b742c969274beae6a09cc4fa977fb52281dfb938aa9ca", "class_name": "RelatedNodeInfo"}}, "text": "CWE-190: Integer Overflow or Wraparound\nDescription :\nThe product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control. \nExtended Description :\nAn integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc.", "start_char_idx": 0, "end_char_idx": 1036, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b11c241-e09c-4545-bd09-085fb192008d": {"__data__": {"id_": "4b11c241-e09c-4545-bd09-085fb192008d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0610fd12-2d82-4a57-bbab-a94e2a5fa49e", "node_type": "4", "metadata": {}, "hash": "1b7fde4945588187ee673cf8178f23fed8df1a9ff526fdcd7fc4c4c998c086ca", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3fd9424c-6ad1-46f6-a087-0a055bf18433", "node_type": "1", "metadata": {}, "hash": "5269fab3c75d8a33f4968bbadc87c64db9ece6d4ba03990be4e1de7260969d8c", "class_name": "RelatedNodeInfo"}}, "text": "CWE-190: Integer Overflow or Wraparound\nDescription :\nThe product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control. \nExtended Description :\nAn integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc. \nExample: 1\nC\n(bad code)\u00a0\nimg_t table_ptr; /*struct containing img data, 10kB each*/\nint num_imgs;\n...\nnum_imgs = get_num_imgs();\ntable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n...\nExample: 2\nC\n(bad code)\u00a0\nnresp = packet_get_int();\nif (nresp > 0) {response = xmalloc(nresp*sizeof(char*));\nfor (i = 0; i < nresp; i++) response[i] = packet_get_string(NULL);\n}\nExample: 3\nC\n(bad code)\u00a0\nshort int bytesRec = 0;\nchar buf[SOMEBIGNUM];\nwhile(bytesRec < MAXGET) {bytesRec += getFromInput(buf+bytesRec);\n}\nExample: 4\nC\n(bad code)\u00a0\n#define JAN 1\n#define FEB 2\n#define MAR 3\nshort getMonthlySales(int month) {...}\nfloat calculateRevenueForQuarter(short quarterSold) {...}\nint determineFirstQuarterRevenue() {\n// Variable for sales revenue for the quarter\nfloat quarterRevenue = 0.0f;\nshort JanSold = getMonthlySales(JAN); /* Get sales in January */\nshort FebSold = getMonthlySales(FEB); /* Get sales in February */\nshort MarSold = getMonthlySales(MAR); /* Get sales in March */\n// Calculate quarterly total\nshort quarterSold = JanSold + FebSold + MarSold;\n// Calculate the total revenue for the quarter\nquarterRevenue = calculateRevenueForQuarter(quarterSold);\nsaveFirstQuarterRevenue(quarterRevenue);\nreturn 0;\n}\nExemple bonus\n#include <unistd.h>\n#include <stdlib.h> \nint main()\n{\n    char *buf;\n    int len;\n    read(0, &len, sizeof(len));\n    if (len > 8000) {return 0; }\n    buf = malloc(len);\n    read(0, buf, len); \n    return 0;\n}\nExemple bonus\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define png_t 4242\n// example taken from the book\n// \"The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities\"\n// slightly edited\nchar* make_table(unsigned int width, unsigned int height, char* init_row){\n        unsigned int n;\n        int i;\n        char* buf;\n        n = width * height;\n        buf = (char*) malloc(n);\n        if (!buf)\n                return NULL;\n        for(i=0; i < height; i++){\n                memcpy(&buf[i* width], init_row, width);\n        }\n        return buf;\n}\nvoid tassa1(int arg1, int arg2){\n        char init_row[] = \"init\";\n        char *res = make_table(arg1, arg2, &init_row);\n        printf(\"Table at %p\\n\", res);\n        free(res);\n}\nint malloc_overflow_get_num_elems(){\n        srand(42);\n        return rand() * 1000000;\n}\nvoid malloc_overflow(){\n        int num_elems = malloc_overflow_get_num_elems();\n        void* ptr_elems = malloc(sizeof(png_t) * num_elems); // overflow occurs here\n        printf(\"PNG at %p\\n\", ptr_elems);\n        free(ptr_elems);\n}\nint packet_get_int(){\n        return malloc_overflow_get_num_elems();\n}\nchar* packet_get_string(){\n        return NULL;\n}\n// taken from https://cwe.mitre.org/data/definitions/190.html\n// slightly edited to make it compile\nvoid overflow_ssh3_1(){\n        char** response;\n        int nresp = packet_get_int();\n        if (nresp > 0) {\n                response = malloc(nresp*sizeof(char*));\n                for (int i = 0; i < nresp; i++)\n                        response[i] = packet_get_string();\n                free(response);\n        }\n}\nint main(int argc, char *argv[argc])\n{\n        tassa1(atoi(argv[1]), atoi(argv[2]));\n        malloc_overflow();\n        overflow_ssh3_1();\n        return 0;\n}", "start_char_idx": 0, "end_char_idx": 4294, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "df1a9e13-4474-4a3e-b62d-433c290be0e5": {"__data__": {"id_": "df1a9e13-4474-4a3e-b62d-433c290be0e5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "67052d51-008b-4f89-8154-e1d1daab828a", "node_type": "4", "metadata": {}, "hash": "59039d50e7d6cd34cc8c1b6f7821dfe3d09e57e275e03a36f2531d44b10fc678", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\nDescription :\nThe product performs a power save/restore operation, but it does not ensure that the integrity of the configuration state is maintained and/or verified between the beginning and ending of the operation. \nExample: 1\nC\n(bad code)\u00a0\nvoid save_config_state()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvoid* cfg;\n\t\t\t\t\t\t\tcfg = get_config_state();\n\t\t\t\t\t\t\tsave_config_state(cfg);\n\t\t\t\t\t\t\tgo_to_sleep();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvoid restore_config_state()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvoid* cfg;\n\t\t\t\t\t\t\tcfg = get_config_file();\n\t\t\t\t\t\t\tload_config_file(cfg);\n\t\t\t\t\t\t}", "start_char_idx": 0, "end_char_idx": 628, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f279a4ce-c12c-4938-8ac2-00203e41effa": {"__data__": {"id_": "f279a4ce-c12c-4938-8ac2-00203e41effa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4407efa6-95f2-4009-9f2a-85c074e6ec65", "node_type": "4", "metadata": {}, "hash": "5f8400618ca6f93fdcd0b57c940fff745e3e7cf397e2fbd421585b3ebb717e8d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1341: Multiple Releases of Same Resource or Handle\nDescription :\nThe product attempts to close or release a resource or handle more than once, without any successful open between the close operations. \nExtended Description :\nCode typically requires \"opening\" handles or references to resources such as memory, files, devices, socket connections, services, etc. When the code is finished with using the resource, it is typically expected to \"close\" or \"release\" the resource, which indicates to the environment (such as the OS) that the resource can be re-assigned or reused by unrelated processes or actors - or in some cases, within the same process. API functions or other abstractions are often used to perform this release, such as free() or delete() within C/C++, or file-handle close() operations that are used in many languages. Unfortunately, the implementation or design of such APIs might expect the developer to be responsible for ensuring that such APIs are only called once per release of the resource. If the developer attempts to release the same resource/handle more than once, then the API's expectations are not met, resulting in undefined and/or insecure behavior. This could lead to consequences such as memory corruption, data corruption, execution path corruption, or other consequences. Note that while the implementation for most (if not all) resource reservation allocations involve a unique identifier/pointer/symbolic reference, then if this identifier is reused, checking the identifier for resource closure may result in a false state of openness and closing of the wrong resource. For this reason, reuse of identifiers is discouraged. \nExample: 1\nC\n(bad code)\u00a0\nchar b[2000];\nFILE *f = fopen(\"dbl_cls.c\", \"r\");\nif (f)\n{\nb[0] = 0;\n\tfread(b, 1, sizeof(b) - 1, f);\n\tprintf(\"%s\\n'\", b);\n\tint r1 = fclose(f);\n\tprintf(\"\\n-----------------\\n1 close done '%d'\\n\", r1);\n\tint r2 = fclose(f);\t// Double close\n\tprintf(\"2 close done '%d'\\n\", r2);\n}\nExample: 2\nC\n(good code)\u00a0\nchar b[2000];\nFILE *f = fopen(\"dbl_cls.c\", \"r\");\nif (f)\n{\nb[0] = 0;\n\tfread(b, 1, sizeof(b) - 1, f);\n\tprintf(\"%s\\n'\", b);\n\tint r = fclose(f);\n\tprintf(\"\\n-----------------\\n1 close done '%d'\\n\", r);\n}", "start_char_idx": 0, "end_char_idx": 2193, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9542073-3613-48ea-bfd9-3ff82b2f3f27": {"__data__": {"id_": "d9542073-3613-48ea-bfd9-3ff82b2f3f27", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e48ebc70-934e-45d1-a376-129e4cd12b42", "node_type": "4", "metadata": {}, "hash": "cddfdfd318496982ccddd80082b8986ca6920dea2927f646eb6f8f5702bfb9f1", "class_name": "RelatedNodeInfo"}}, "text": "CWE-14: Compiler Removal of Code to Clear Buffers\nDescription :\nSensitive memory is cleared according to the source code, but compiler optimizations leave the memory untouched when it is not read from again, aka \"dead store removal.\" \nExtended Description :\nThis compiler optimization error occurs when: 1. Secret data are stored in memory. 2. The secret data are scrubbed from memory by overwriting its contents. 3. The source code is compiled using an optimizing compiler, which identifies and removes the function that overwrites the contents as a dead store because the memory is not used subsequently. \nExample: 1\nC\n(bad code)\u00a0\nvoid GetData(char *MFAddr) {\nchar pwd[64];\nif (GetPasswordFromUser(pwd, sizeof(pwd))) {\nif (ConnectToMainframe(MFAddr, pwd)) {\n// Interaction with mainframe\n}\n}\nmemset(pwd, 0, sizeof(pwd));\n}", "start_char_idx": 0, "end_char_idx": 824, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "00ec58f7-84ea-471e-91d9-4342529b94ee": {"__data__": {"id_": "00ec58f7-84ea-471e-91d9-4342529b94ee", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fb052d08-d0da-4f5e-afb7-8f00241632c3", "node_type": "4", "metadata": {}, "hash": "b53c9c3bff412fd32b4ddc0bcbd107d12d5ea288663aed9cc984488b74b4987e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1255: Comparison Logic is Vulnerable to Power Side-Channel Attacks\nDescription :\nA device's real time power consumption may be monitored during security token evaluation and the information gleaned may be used to determine the value of the reference token. \nExample: 1\nC\n(bad code)\u00a0\nstatic nonvolatile password_tries = NUM_RETRIES;\n           do\n             while (password_tries == 0) ; // Hang here if no more password tries\n             password_ok = 0;\n             for (i = 0; i < NUM_PW_DIGITS; i++)\n               if (GetPasswordByte() == stored_password([i])\n\t\t password_ok |= 1; // Power consumption is different here\n               else\n\t\t password_ok |= 0; // than from here\n             end\n             if (password_ok > 0)\n               password_tries = NUM_RETRIES;\n               break_to_Ok_to_proceed\n             password_tries--;\n           while (true)\n           // Password OK\nExample: 2\nC\n(good code)\u00a0\nstatic nonvolatile password_tries = NUM_RETRIES;\n           do\n             while (password_tries == 0) ; // Hang here if no more password tries\n             password_tries--;  // Put retry code here to catch partial retries\n             password_ok = 0;\n             for (i = 0; i < NUM_PW_DIGITS; i++)\n               if (GetPasswordByte() == stored_password([i])\n\t\t password_ok |= 0x10; // Power consumption here\n               else\n\t\t password_ok |= 0x01; // is now the same here\n             end\n             if ((password_ok & 1) == 0)\n               password_tries = NUM_RETRIES;\n               break_to_Ok_to_proceed\n           while (true)\n           // Password OK", "start_char_idx": 0, "end_char_idx": 1605, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24883fe8-b867-4916-821e-7c0f663ac866": {"__data__": {"id_": "24883fe8-b867-4916-821e-7c0f663ac866", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7bfd973f-4325-4343-8375-e51d9c8847d3", "node_type": "4", "metadata": {}, "hash": "945de2a2a057d869750260d3203a5f67cd980a8f3cd66e19badd805b04e73d27", "class_name": "RelatedNodeInfo"}}, "text": "CWE-457: Use of Uninitialized Variable\nDescription :\nThe code uses a variable that has not been initialized, leading to unpredictable or unintended results. \nExtended Description :\nIn some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code. \nExemple bonus \nC\n(bad code)\u00a0\n#include <stdlib.h>\n#include <stdio.h>\nvoid uninitalized_variable(){\n        int a; // never initialized\n        int b = 7;\n        int c = a + b;\n        printf(\"a is %d, b is %d, c is %d\\n\", a , b, c);\n}\nint main(int argc, char *argv[argc])\n{\n        uninitalized_variable();\n        return 0;\n}\nExample: 1\nPHP\n(bad code)\u00a0\nif (isset($_POST['names'])) {$nameArray = $_POST['names'];\n}\necho \"Hello \" . $nameArray['first'];\nExample: 2\nC\n(bad code)\u00a0\nint aN, Bn;\nswitch (ctl) {\ncase -1:aN = 0;\nbN = 0;\nbreak;\ncase 0:aN = i;\nbN = -i;\nbreak;\ncase 1:aN = i + NEXT_SZ;\nbN = i - NEXT_SZ;\nbreak;\ndefault:aN = -1;\naN = -1;\nbreak;\n}\nrepaint(aN, bN);\nExample: 3\nC\n(bad code)\u00a0\nchar *test_string;\n                if (i != err_val)\n                {\ntest_string = \"Hello World!\";\n                }\n                printf(\"%s\", test_string);", "start_char_idx": 0, "end_char_idx": 1557, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "563a45bc-8b7c-4951-bc17-aeb6e669b213": {"__data__": {"id_": "563a45bc-8b7c-4951-bc17-aeb6e669b213", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1a222615-2d2e-4ba6-bebb-ac0acced7636", "node_type": "4", "metadata": {}, "hash": "8592790b555fa7ac5ab0ac3093a1d26fd5f5e784b004bcb6ed8ff20158448d7c", "class_name": "RelatedNodeInfo"}}, "text": "CWE-480: Use of Incorrect Operator\nDescription :\nThe product accidentally uses the wrong operator, which changes the logic in security-relevant ways. \nExtended Description :\nThese types of errors are generally the result of a typo by the programmer. \nExample: 1\nC\n(bad code)\u00a0\nint isValid(int value) {if (value=100) {printf(\"Value is valid\\n\");\nreturn(1);\n}\nprintf(\"Value is not valid\\n\");\nreturn(0);\n}", "start_char_idx": 0, "end_char_idx": 401, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5514f072-f52d-4890-9b95-c2c1958df6a5": {"__data__": {"id_": "5514f072-f52d-4890-9b95-c2c1958df6a5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a26fa20e-964e-4c0f-a467-fbe19148db1c", "node_type": "4", "metadata": {}, "hash": "7c18cfd0b6d3190a2f9aeffd2ccf051d7fefa137d0a043374af53c6a43ed931c", "class_name": "RelatedNodeInfo"}}, "text": "CWE-909: Missing Initialization of Resource\nDescription :\nThe product does not initialize a critical resource. \nExample: 1\nJava\n(bad code)\u00a0\nprivate boolean initialized = true;\npublic void someMethod() {\nif (!initialized) {\n// perform initialization tasks\n...\ninitialized = true;\n}\nExample: 2\nPerl\n(bad code)\u00a0\n$username = GetCurrentUser();\n$state = GetStateData($username);\nif (defined($state)) {$uid = ExtractUserID($state);\n}\n# do stuff\nif ($uid == 0) {DoAdminThings();\n}\nExample: 3\nC\n(bad code)\u00a0\nchar str[20];\nstrcat(str, \"hello world\");\nprintf(\"%s\", str);\nExample: 4\nC\n(bad code)\u00a0\nchar *test_string;\n                if (i != err_val)\n                {\ntest_string = \"Hello World!\";\n                }\n                printf(\"%s\", test_string);", "start_char_idx": 0, "end_char_idx": 745, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d1a47896-4381-4bd6-a0d0-d7b40af3244e": {"__data__": {"id_": "d1a47896-4381-4bd6-a0d0-d7b40af3244e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "58e46aeb-0142-4d77-a6b5-b7de3ca14a69", "node_type": "4", "metadata": {}, "hash": "1ac5ff17454c3c104b4b0f564dbca20cfbbb309c5a0e10b0fcae24dcf1f864be", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1105: Insufficient Encapsulation of Machine-Dependent Functionality\nDescription :\nThe product or code uses machine-dependent functionality, but it does not sufficiently encapsulate or isolate this functionality from the rest of the code. \nExample: 1\nC\n(bad code)\u00a0\nvoid example() {char a;\nchar b;\n*(&a + 1) = 0;\n}", "start_char_idx": 0, "end_char_idx": 316, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cb61c533-0550-48a6-809c-98a2e4237b62": {"__data__": {"id_": "cb61c533-0550-48a6-809c-98a2e4237b62", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c8b96aa-e750-4045-a4e1-591cd67e2304", "node_type": "4", "metadata": {}, "hash": "39693a10ed6ae60c98b3bc25ba839fd28c0a0555f05bd1cf0674bf4172b719f3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-606: Unchecked Input for Loop Condition\nDescription :\nThe product does not properly check inputs that are used for loop conditions, potentially leading to a denial of service or other consequences because of excessive looping. \nExample: 1\nC\n(bad code)\u00a0\nvoid iterate(int n){int i;\nfor (i = 0; i < n; i++){foo();\n}\n}\nvoid iterateFoo()\n{unsigned int num;\nscanf(\"%u\",&num);\niterate(num);\n}\nExample: 2\nC\n(bad code)\u00a0\nint processMessageFromSocket(int socket) {\nint success;\nchar buffer[BUFFER_SIZE];\nchar message[MESSAGE_SIZE];\n// get message from socket and store into buffer\n//Ignoring possibliity that buffer > BUFFER_SIZE\nif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n// place contents of the buffer into message structure\nExMessage *msg = recastBuffer(buffer);\n// copy message body into string for processing\nint index;\nfor (index = 0; index < msg->msgLength; index++) {message[index] = msg->msgBody[index];\n}\nmessage[index] = '\\0';\n// process message\nsuccess = processMessage(message);\n}\nreturn success;\n}", "start_char_idx": 0, "end_char_idx": 1013, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "708368ad-12f0-4722-ad14-60dda632db19": {"__data__": {"id_": "708368ad-12f0-4722-ad14-60dda632db19", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "809b1ad0-7a76-41c0-873c-32be1e1400a3", "node_type": "4", "metadata": {}, "hash": "14cd53115f8794c37bf338d112bdb583b215f7d976156255a3d07ec49cc18d9d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nDescription :\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component. \nExtended Description :\nThis could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage. There are at least two subtypes of OS command injection: The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing. The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line. From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input. \nExample: 1\nPHP\n(bad code)\u00a0\n$userName = $_POST[\"user\"];\n$command = 'ls -l /home/' . $userName;\nsystem($command);\nExample: 2\nC\n(bad code)\u00a0\nint main(int argc, char** argv) {char cmd[CMD_MAX] = \"/usr/bin/cat \";\nstrcat(cmd, argv[1]);\nsystem(cmd);\n}\nExample: 3\nPerl\n(bad code)\u00a0\nuse CGI qw(:standard);\n$name = param('name');\n$nslookup = \"/path/to/nslookup\";\nprint header;\nif (open($fh, \"$nslookup $name|\")) {while (<$fh>) {print escapeHTML($_);\nprint \"<br>\\n\";\n}\nclose($fh);\n}\nExemple bonus\nC\n(bad code)\n#include <string.h>\n#include <stdlib.h>\nvoid constant_system() {\n    system(\"ls\");\n}\nint main(int argc, char **argv) {\n    char dest[30] = \"usr/bin/cat \";\n    strcat(dest, argv[1]);\n    system(dest);\n    constant_system();\n    return 0;\n}", "start_char_idx": 0, "end_char_idx": 3541, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c21ba90-2ded-4553-ad9a-65207ed80a19": {"__data__": {"id_": "1c21ba90-2ded-4553-ad9a-65207ed80a19", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f0fe8be9-53a4-4d90-ab6d-aba6bcd91bac", "node_type": "4", "metadata": {}, "hash": "5934fd421e7d893dc85fe5d0f79b3467e0cfd9ec2f85ef17d0964508c88c5fb7", "class_name": "RelatedNodeInfo"}}, "text": "CWE-401: Missing Release of Memory after Effective Lifetime\nDescription :\nThe product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory. \nExtended Description :\nThis is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release. \nExample: 1\nC\n(bad code)\u00a0\nchar* getBlock(int fd) {\nchar* buf = (char*) malloc(BLOCK_SIZE);\nif (!buf) {return NULL;\n}\nif (read(fd, buf, BLOCK_SIZE) != BLOCK_SIZE) {\nreturn NULL;\n}\nreturn buf;\n}", "start_char_idx": 0, "end_char_idx": 747, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d0a2e1c-adcd-4ca5-81bf-aaa9beac444b": {"__data__": {"id_": "0d0a2e1c-adcd-4ca5-81bf-aaa9beac444b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3974bc6e-a2b0-4812-a41d-b34caad2d2b5", "node_type": "4", "metadata": {}, "hash": "b44bcc8a125faf5036ea4b5f61137b55e795c508323efd1be0a04639e46bf4bd", "class_name": "RelatedNodeInfo"}}, "text": "CWE-682: Incorrect Calculation\nDescription :\nThe product performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management. \nExtended Description :\nWhen product performs a security-critical calculation incorrectly, it might lead to incorrect resource allocations, incorrect privilege assignments, or failed comparisons among other things. Many of the direct results of an incorrect calculation can lead to even larger problems such as failed protection mechanisms or even arbitrary code execution. \nExample: 1\nC\n(bad code)\u00a0\nimg_t table_ptr; /*struct containing img data, 10kB each*/\nint num_imgs;\n...\nnum_imgs = get_num_imgs();\ntable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n...\nExample: 2\nJava\n(bad code)\u00a0\n...\nint touchdowns = team.getTouchdowns();\nint yardsGained = team.getTotalYardage();\nSystem.out.println(team.getName() + \" averages \" + yardsGained / touchdowns + \"yards gained for every touchdown scored\");\n...\nExample: 3\nC\n(bad code)\u00a0\nint *p = x;\nchar * second_char = (char *)(p + 1);", "start_char_idx": 0, "end_char_idx": 1075, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f186f07e-e395-4c8c-8059-334950f62c51": {"__data__": {"id_": "f186f07e-e395-4c8c-8059-334950f62c51", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ea8a8540-7a11-4cd9-8d6a-6b31c15c9049", "node_type": "4", "metadata": {}, "hash": "8de5e8a2d9f282961c180a287e99d01f7f757869d7e774e5b02b3361ca15af9d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-667: Improper Locking\nDescription :\nThe product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors. \nExtended Description :\nLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc. \nExample: 1\nJava\n(bad code)\u00a0\nprivate long someLongValue;\npublic long getLongValue() {return someLongValue;\n}\npublic void setLongValue(long l) {someLongValue = l;\n}\nExample: 2\nPHP\n(bad code)\u00a0\nfunction writeToLog($message){$logfile = fopen(\"logFile.log\", \"a\");\n//attempt to get logfile lock\nif (flock($logfile, LOCK_EX)) {fwrite($logfile,$message);\n// unlock logfile\nflock($logfile, LOCK_UN);\n}\nelse {print \"Could not obtain lock on logFile.log, message not recorded\\n\";\n}\n}\nfclose($logFile);\nExample: 3\nC\n(bad code)\u00a0\nvoid f(pthread_mutex_t *mutex) {\npthread_mutex_lock(mutex);\n/* access shared resource */\npthread_mutex_unlock(mutex);\n}\nExample: 4\nC\n(good code)\u00a0\nint f(pthread_mutex_t *mutex) {\nint result;\nresult = pthread_mutex_lock(mutex);\nif (0 != result)return result;\n/* access shared resource */\nreturn pthread_mutex_unlock(mutex);\n}", "start_char_idx": 0, "end_char_idx": 1568, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34058055-31a5-41ed-87c9-6580b865413e": {"__data__": {"id_": "34058055-31a5-41ed-87c9-6580b865413e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e650852b-5670-4ca2-b458-1cd08cd0ea20", "node_type": "4", "metadata": {}, "hash": "d5e68d9adeac3a2a9a6301a7747708b036a30adb5bce6a8c4370c8e5f5a32e84", "class_name": "RelatedNodeInfo"}}, "text": "CWE-593: Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\nDescription :\nThe product modifies the SSL context after connection creation has begun. \nExample: 1\nC\n(bad code)\u00a0\n#define CERT \"secret.pem\"\n#define CERT2 \"secret2.pem\"\nint main(){\nSSL_CTX *ctx;\nSSL *ssl;\ninit_OpenSSL();\nseed_prng();\nctx = SSL_CTX_new(SSLv23_method());\nif (SSL_CTX_use_certificate_chain_file(ctx, CERT) != 1)int_error(\"Error loading certificate from file\");\nif (SSL_CTX_use_PrivateKey_file(ctx, CERT, SSL_FILETYPE_PEM) != 1)int_error(\"Error loading private key from file\");\nif (!(ssl = SSL_new(ctx)))int_error(\"Error creating an SSL context\");\nif ( SSL_CTX_set_default_passwd_cb(ctx, \"new default password\" != 1))int_error(\"Doing something which is dangerous to do anyways\");\nif (!(ssl2 = SSL_new(ctx)))int_error(\"Error creating an SSL context\");\n}", "start_char_idx": 0, "end_char_idx": 854, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b9ba94b7-1da2-4c21-9625-4c556af5e5a4": {"__data__": {"id_": "b9ba94b7-1da2-4c21-9625-4c556af5e5a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c605b6a2-9cff-440b-a81c-46f5fbf63b85", "node_type": "4", "metadata": {}, "hash": "8f946da3e60a3813665a13fb41468dd6a7265f3e20de8ad63aedf62700b5cf45", "class_name": "RelatedNodeInfo"}}, "text": "CWE-332: Insufficient Entropy in PRNG\n+ Description\nThe lack of entropy available for, or used by, a Pseudo-Random Number Generator (PRNG) can be a stability and security threat.\n(bad code)\nExample Language: C \n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\nint main() {\n    int a, b;\n    srand((unsigned)time(NULL)); // CWE-337: Predictable Seed in PRNG\n    a = rand(); // CWE-332: Insufficient Entropy in PRNG\n    b = rand() % 100; // Exemple d'utilisation du PRNG pour une valeur sp\u00e9cifique\n    printf(\"%d\\n\", a);\n    printf(\"%d\\n\", b);\n    return 0;\n}", "start_char_idx": 0, "end_char_idx": 565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b147dfa-a033-4b83-a31f-451dc1646986": {"__data__": {"id_": "0b147dfa-a033-4b83-a31f-451dc1646986", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "58c80c45-b624-4a73-aaff-dd37a8a9d73e", "node_type": "4", "metadata": {}, "hash": "eacc42f2254b9b5083fc3ddf0fd980ca31afd171aca2124d03e6e090fb5daf3c", "class_name": "RelatedNodeInfo"}}, "text": "CWE-124: Buffer Underwrite ('Buffer Underflow')\nDescription :\nThe product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer. \nExtended Description :\nThis typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. \nExample: 1\nC\n(bad code)\u00a0\nchar* trimTrailingWhitespace(char *strMessage, int length) {\nchar *retMessage;\nchar *message = malloc(sizeof(char)*(length+1));\n// copy input string to a temporary string\nchar message[length+1];\nint index;\nfor (index = 0; index < length; index++) {message[index] = strMessage[index];\n}\nmessage[index] = '\\0';\n// trim trailing whitespace\nint len = index-1;\nwhile (isspace(message[len])) {message[len] = '\\0';\nlen--;\n}\n// return string without trailing whitespace\nretMessage = message;\nreturn retMessage;\n}\nExample: 2\nC\n(bad code)\u00a0\nint main() {...\nstrncpy(destBuf, &srcBuf[find(srcBuf, ch)], 1024);\n...\n}", "start_char_idx": 0, "end_char_idx": 1072, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57b764fc-d315-4f0d-b90b-47e3929d1fe1": {"__data__": {"id_": "57b764fc-d315-4f0d-b90b-47e3929d1fe1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2be702ef-686f-4c6b-ab06-85c00b9ddc23", "node_type": "4", "metadata": {}, "hash": "35313d4c25e81cbbe0ca8e564f9f8245c482b2850974e40927f48d4670c308ac", "class_name": "RelatedNodeInfo"}}, "text": "CWE-295: Improper Certificate Validation\nDescription :\nThe product does not validate, or incorrectly validates, a certificate. \nExample: 1\nC\n(bad code)\u00a0\nif ((cert = SSL_get_peer_certificate(ssl)) && host)foo=SSL_get_verify_result(ssl);\nif ((X509_V_OK==foo) || X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN==foo))\n// certificate looks good, host can be trusted\nExample: 2\nC\n(bad code)\u00a0\ncert = SSL_get_peer_certificate(ssl);\nif (cert && (SSL_get_verify_result(ssl)==X509_V_OK)) {\n// do secret things\n}\nExample: 3\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer(certificate(ssl)) {\nfoo=SSL_get_verify_result(ssl);\nif ((X509_V_OK==foo) || (X509_V_ERR_CERT_HAS_EXPIRED==foo))\n//do stuff\nExample: 4\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer_certificate(ssl)) {\n// got a certificate, do secret things\nExample: 5\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer_certificate(ssl)) {\n// got certificate, host can be trusted\n//foo=SSL_get_verify_result(ssl);\n//if (X509_V_OK==foo) ...\n}", "start_char_idx": 0, "end_char_idx": 941, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "32aaaa74-8688-40bd-99c0-f56e9840ddc5": {"__data__": {"id_": "32aaaa74-8688-40bd-99c0-f56e9840ddc5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "83d25222-b11e-4ec0-a0a8-e5558ed5cd8b", "node_type": "4", "metadata": {}, "hash": "cdfb39ea229fb0b3c09297cae57833ef5d38c086fedeb91fcfd9044e91afa069", "class_name": "RelatedNodeInfo"}}, "text": "CWE-329: Generation of Predictable IV with CBC Mode\nDescription :\nThe product generates and uses a predictable initialization Vector (IV) with Cipher Block Chaining (CBC) Mode, which causes algorithms to be susceptible to dictionary attacks when they are encrypted under the same key. \nExtended Description :\nCBC mode eliminates a weakness of Electronic Code Book (ECB) mode by allowing identical plaintext blocks to be encrypted to different ciphertext blocks. This is possible by the XOR-ing of an IV with the initial plaintext block so that every plaintext block in the chain is XOR'd with a different value before encryption. If IVs are reused, then identical plaintexts would be encrypted to identical ciphertexts. However, even if IVs are not identical but are predictable, then they still break the security of CBC mode against Chosen Plaintext Attacks (CPA). \nExample: 1\nC\n(bad code)\u00a0\nEVP_CIPHER_CTX ctx;\nchar key[EVP_MAX_KEY_LENGTH];\nchar iv[EVP_MAX_IV_LENGTH];\nRAND_bytes(key, b);\nmemset(iv,0,EVP_MAX_IV_LENGTH);\nEVP_EncryptInit(&ctx,EVP_bf_cbc(), key,iv);", "start_char_idx": 0, "end_char_idx": 1066, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c6e6275-45bb-40db-b2b4-d2c235776fb9": {"__data__": {"id_": "5c6e6275-45bb-40db-b2b4-d2c235776fb9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "61fe7159-cd8c-4466-98ca-61af78aad400", "node_type": "4", "metadata": {}, "hash": "14932b34a813f6cb50f780bff09cf8367394367338f7572c68d93bac907a96fa", "class_name": "RelatedNodeInfo"}}, "text": "CWE-798: Use of Hard-coded Credentials\nDescription :\nThe product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. \nExtended Description :\nHard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the product administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the product contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials. Outbound: the product connects to another system or component, and it contains hard-coded credentials for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple. \nExample: 1\nJava\n(bad code)\u00a0\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\nExample: 2\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {\nif (strcmp(password, \"Mew!\")) {\n                                 printf(\"Incorrect Password!\\n\");\nreturn(0)\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}\nExample: 3\nJava\n(bad code)\u00a0\nint VerifyAdmin(String password) {if (!password.equals(\"Mew!\")) {return(0)\n}\n//Diagnostic Mode\nreturn(1);\n}\nExample: 4\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {\nif (strcmp(password,\"68af404b513073584c4b6f22b6c63e6b\")) {\nprintf(\"Incorrect Password!\\n\");\nreturn(0);\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}", "start_char_idx": 0, "end_char_idx": 2790, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cff34956-de04-4eed-b14f-d6f70b0bdf19": {"__data__": {"id_": "cff34956-de04-4eed-b14f-d6f70b0bdf19", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "99ad159a-f1e2-4836-a6a4-433d3603ac29", "node_type": "4", "metadata": {}, "hash": "217ee5a472bb6f47ebc196976bc1c14641597a96683c5cf861cd2d266eca557d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nDescription :\nThe product does not properly prevent sensitive system-level information from being accessed by unauthorized actors who do not have the same level of access to the underlying system as the product does. \nExtended Description :\nNetwork-based products, such as web applications, often run on top of an operating system or similar environment. When the product communicates with outside parties, details about the underlying system are expected to remain hidden, such as path names for data files, other OS users, installed packages, the application environment, etc. This system information may be provided by the product itself, or buried within diagnostic or debugging messages. Debugging information helps an adversary learn about the system and form an attack plan. An information exposure occurs when system data or debugging information leaves the program through an output stream or logging function that makes it accessible to unauthorized parties. Using other weaknesses, an attacker could cause errors to occur; the response to these errors can reveal detailed system information, along with other impacts. An attacker can use messages that reveal technologies, operating systems, and product versions to tune the attack against known vulnerabilities in these technologies. A product may use diagnostic methods that provide significant implementation details such as stack traces as part of its error handling mechanism. \nExample: 1\nC\n(bad code)\u00a0\nchar* path = getenv(\"PATH\");\n...\nsprintf(stderr, \"cannot find exe on path %s\\n\", path);\nExample: 2\nPHP\n(bad code)\u00a0\n//assume getCurrentUser() returns a username that is guaranteed to be alphanumeric (avoiding CWE-78) \n$userName = getCurrentUser();\n$command = 'ps aux | grep ' . $userName;\nsystem($command);\nExample: 3\nJava\n(bad code)\u00a0\ntry {...\n} catch (Exception e) {e.printStackTrace();\n}", "start_char_idx": 0, "end_char_idx": 1941, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92b5e2ab-7452-49ad-bdf8-1a91b1299d9c": {"__data__": {"id_": "92b5e2ab-7452-49ad-bdf8-1a91b1299d9c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "38dace05-21ee-4c13-89f2-6236f79d170e", "node_type": "4", "metadata": {}, "hash": "bdcfe5bb6015a450410356b4d788965159dc479d4aa2bd206f459550786c43fd", "class_name": "RelatedNodeInfo"}}, "text": "CWE-176: Improper Handling of Unicode Encoding\nDescription :\nThe product does not properly handle when an input contains Unicode encoding. \nExample: 1\nC\n(bad code)\u00a0\nvoid getUserInfo(char *username, struct _USER_INFO_2 info){WCHAR unicodeUser[UNLEN+1];\nMultiByteToWideChar(CP_ACP, 0, username, -1, unicodeUser, sizeof(unicodeUser));\nNetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&info);\n}", "start_char_idx": 0, "end_char_idx": 388, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7aa83ea5-6c1d-4f4a-9042-c28dbd2af802": {"__data__": {"id_": "7aa83ea5-6c1d-4f4a-9042-c28dbd2af802", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b5deb37c-93be-40e4-a39d-0b67d3c481d7", "node_type": "4", "metadata": {}, "hash": "1131a1d282a2e8586f466a5583e995e4675cb79157789c7db9633832f895e7a1", "class_name": "RelatedNodeInfo"}}, "text": "CWE-321: Use of Hard-coded Cryptographic Key\nDescription :\nThe use of a hard-coded cryptographic key significantly increases the possibility that encrypted data may be recovered. \nExample: 1\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {\nif (strcmp(password,\"68af404b513073584c4b6f22b6c63e6b\")) {\nprintf(\"Incorrect Password!\\n\");\nreturn(0);\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}\nExample: 2\nJava\n(bad code)\u00a0\npublic boolean VerifyAdmin(String password) {if (password.equals(\"68af404b513073584c4b6f22b6c63e6b\")) {System.out.println(\"Entering Diagnostic Mode...\");\nreturn true;\n}\nSystem.out.println(\"Incorrect Password!\");\nreturn false;", "start_char_idx": 0, "end_char_idx": 651, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4c5b343-fd3e-42e6-bcc1-41d087fc455c": {"__data__": {"id_": "e4c5b343-fd3e-42e6-bcc1-41d087fc455c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9562521f-463f-403e-8619-715d9ae99b41", "node_type": "4", "metadata": {}, "hash": "59bf30586e000ac5e09d45af5f6e2e54e183ef5a6233b77ea0c3430b0c73dbeb", "class_name": "RelatedNodeInfo"}}, "text": "CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nDescription :\nThe product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently. \nExtended Description :\nThis can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single \"x++\" statement may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x). The interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product. \nExample: 1\nPerl\n(bad code)\u00a0\n$transfer_amount = GetTransferAmount();\n$balance = GetBalanceFromDatabase();\nif ($transfer_amount < 0) {FatalError(\"Bad Transfer Amount\");\n}\n$newbalance = $balance - $transfer_amount;\nif (($balance - $transfer_amount) < 0) {FatalError(\"Insufficient Funds\");\n}\nSendNewBalanceToDatabase($newbalance);\nNotifyUser(\"Transfer of $transfer_amount succeeded.\");\nNotifyUser(\"New balance: $newbalance\");\nExample: 2\nOther\n(attack code)\u00a0\nIn the following pseudocode, the attacker makes two simultaneous calls of the program, CALLER-1 and CALLER-2. Both callers are for the same user account.\nCALLER-1 (the attacker) is associated with PROGRAM-1 (the instance that handles CALLER-1). CALLER-2 is associated with PROGRAM-2.\nCALLER-1 makes a transfer request of 80.00.\nPROGRAM-1 calls GetBalanceFromDatabase and sets $balance to 100.00\nPROGRAM-1 calculates $newbalance as 20.00, then calls SendNewBalanceToDatabase().\nDue to high server load, the PROGRAM-1 call to SendNewBalanceToDatabase() encounters a delay.\nCALLER-2 makes a transfer request of 1.00.\nPROGRAM-2 calls GetBalanceFromDatabase() and sets $balance to 100.00. This happens because the previous PROGRAM-1 request was not processed yet.\nPROGRAM-2 determines the new balance as 99.00.\nAfter the initial delay, PROGRAM-1 commits its balance to the database, setting it to 20.00.\nPROGRAM-2 sends a request to update the database, setting the balance to 99.00\nExample: 3\nC\n(bad code)\u00a0\nvoid f(pthread_mutex_t *mutex) {\npthread_mutex_lock(mutex);\n/* access shared resource */\npthread_mutex_unlock(mutex);\n}", "start_char_idx": 0, "end_char_idx": 3857, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "afc030f5-3ce0-471b-b6d1-7f11d42018c1": {"__data__": {"id_": "afc030f5-3ce0-471b-b6d1-7f11d42018c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a2da8790-b411-43af-ab7e-9e7591621ee6", "node_type": "4", "metadata": {}, "hash": "8cbe11f8fa77ec4401d7e5138a5023e58e889b58aa383c4962e9c50dcbf97089", "class_name": "RelatedNodeInfo"}}, "text": "CWE-128: Wrap-around Error\nDescription :\nWrap around errors occur whenever a value is incremented past the maximum value for its type and therefore \"wraps around\" to a very small, negative, or undefined value. \nExample: 1\nC\n(bad code)\u00a0\nimg_t table_ptr; /*struct containing img data, 10kB each*/\nint num_imgs;\n...\nnum_imgs = get_num_imgs();\ntable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n...", "start_char_idx": 0, "end_char_idx": 395, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c05ee29-e94a-4a6e-b6fe-e15b01ab43b0": {"__data__": {"id_": "1c05ee29-e94a-4a6e-b6fe-e15b01ab43b0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c00a8094-b323-4998-9eca-942c63c6cfb1", "node_type": "4", "metadata": {}, "hash": "ba40f1005b7ab8a0ec16e5543b45822bbb82bdea766a17ef47cf48f6b036e4d1", "class_name": "RelatedNodeInfo"}}, "text": "CWE-298: Improper Validation of Certificate Expiration\nDescription :\nA certificate expiration is not validated or is incorrectly validated, so trust may be assigned to certificates that have been abandoned due to age. \nExample: 1\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer(certificate(ssl)) {\nfoo=SSL_get_verify_result(ssl);\nif ((X509_V_OK==foo) || (X509_V_ERR_CERT_HAS_EXPIRED==foo))\n//do stuff", "start_char_idx": 0, "end_char_idx": 390, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6e9f1cd1-5ec6-456b-ae9b-3ba095960c24": {"__data__": {"id_": "6e9f1cd1-5ec6-456b-ae9b-3ba095960c24", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "53a501b8-8ab8-4aea-9c40-4d7ecbb16f09", "node_type": "4", "metadata": {}, "hash": "b2e9ca73f4bc1d6fd8fe20059d922b8a942989f9a2678045e73cc89ba6db35a6", "class_name": "RelatedNodeInfo"}}, "text": "CWE-404: Improper Resource Shutdown or Release\nDescription :\nThe product does not release or incorrectly releases a resource before it is made available for re-use. \nExtended Description :\nWhen a resource is created or allocated, the developer is responsible for properly releasing the resource as well as accounting for all potential paths of expiration or invalidation, such as a set period of time or revocation. \nExample: 1\nJava\n(bad code)\u00a0\nprivate void processFile(string fName)\n{BufferReader fil = new BufferReader(new FileReader(fName));\nString line;\nwhile ((line = fil.ReadLine()) != null)\n{processLine(line);\n}\n}\nExample: 2\nJava\n(good code)\u00a0\nprivate void processFile(string fName)\n{BufferReader fil = new BufferReader(new FileReader(fName));\nString line;\nwhile ((line = fil.ReadLine()) != null)\n{processLine(line);\n}\nfil.Close();\n}\nExample: 3\nJava\n(bad code)\u00a0\ntry {Connection con = DriverManager.getConnection(some_connection_string);\n}\ncatch ( Exception e ) {log( e );\n}\nExample: 4\nC#\n(bad code)\u00a0\n...\nSqlConnection conn = new SqlConnection(connString);\nSqlCommand cmd = new SqlCommand(queryString);\ncmd.Connection = conn;\nconn.Open();\nSqlDataReader rdr = cmd.ExecuteReader();\nHarvestResults(rdr);\nconn.Connection.Close();\n...\nExample: 5\nC\n(bad code)\u00a0\nint decodeFile(char* fName) {\nchar buf[BUF_SZ];\nFILE* f = fopen(fName, \"r\");\nif (!f) {printf(\"cannot open %s\\n\", fName);\nreturn DECODE_FAIL;\n}\nelse {\nwhile (fgets(buf, BUF_SZ, f)) {if (!checkChecksum(buf)) {return DECODE_FAIL;\n}\nelse {decodeBlock(buf);\n}\n}\n}\nfclose(f);\nreturn DECODE_SUCCESS;\n}\nExample: 6\nC++\n(bad code)\u00a0\nclass A {void foo();\n};\nvoid A::foo(){int *ptr;\nptr = (int*)malloc(sizeof(int));\ndelete ptr;\n}", "start_char_idx": 0, "end_char_idx": 1677, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "608420b8-992d-4e2c-a8c2-9e6e239cdd1d": {"__data__": {"id_": "608420b8-992d-4e2c-a8c2-9e6e239cdd1d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c2778437-5427-4022-8ecd-fe6935941285", "node_type": "4", "metadata": {}, "hash": "9207b09b0000508d55c6eee8c4455fc781c1a594cf6d99a508f04209f5bbc750", "class_name": "RelatedNodeInfo"}}, "text": "CWE-297: Improper Validation of Certificate with Host Mismatch\nDescription :\nThe product communicates with a host that provides a certificate, but the product does not properly ensure that the certificate is actually associated with that host. \nExample: 1\nC\n(bad code)\u00a0\ncert = SSL_get_peer_certificate(ssl);\nif (cert && (SSL_get_verify_result(ssl)==X509_V_OK)) {\n// do secret things\n}", "start_char_idx": 0, "end_char_idx": 384, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45461118-4020-4448-9c5a-0f8936552ad4": {"__data__": {"id_": "45461118-4020-4448-9c5a-0f8936552ad4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "058d49b5-6266-4528-816c-fd42c4016797", "node_type": "4", "metadata": {}, "hash": "6db144260504ecee4c9b03653192820c555d13f27f9afdb7080e36325e8cac1e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-243: Creation of chroot Jail Without Changing Working Directory\nDescription :\nThe product uses the chroot() system call to create a jail, but does not change the working directory afterward. This does not prevent access to files outside of the jail. \nExtended Description :\nImproper use of chroot() may allow attackers to escape from the chroot jail. The chroot() function call does not change the process's current working directory, so relative paths may still refer to file system resources outside of the chroot jail after chroot() has been called. \nExample: 1\nC\n(bad code)\u00a0\nchroot(\"/var/ftproot\");\n...\nfgets(filename, sizeof(filename), network);\nlocalfile = fopen(filename, \"r\");\nwhile ((len = fread(buf, 1, sizeof(buf), localfile)) != EOF) {fwrite(buf, 1, sizeof(buf), network);\n}\nfclose(localfile);\nExemple \n(bad code)\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <unistd.h>\nvoid chroot_fail(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n}\n// these are safe according to http://www.unixwiz.net/techtips/chroot-practices.html\nvoid chroot_safe1(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  setuid(1077);\n}\nvoid chroot_safe2(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  setresuid(1077, 1077, 1077);\n}\nvoid chroot_safe3(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  setreuid(1077, 44);\n}\nvoid chroot_safe4(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  seteuid(1077);\n}\nvoid chroot_safe5(){\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  chdir(\"/\");\n}\nint main(void) {\n  chroot_fail();\n  chroot_safe1();\n  chroot_safe2();\n  chroot_safe3();\n  chroot_safe4();\n  chroot_safe5();\n}\nExemple bonus \n(good code)\nvoid chroot_safe1(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  setuid(1077);\n}\nvoid chroot_safe2(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  setresuid(1077, 1077, 1077);\n}\nvoid chroot_safe3(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  setreuid(1077, 44);\n}\nvoid chroot_safe4(){\n  chdir(\"/tmp\");\n  if (chroot(\"/tmp\") != 0) {\n    perror(\"chroot /tmp\");\n  }\n  seteuid(1077);\n}\nint main(void) {\n  chroot_safe1();\n  chroot_safe2();\n  chroot_safe3();\n  chroot_safe4();\n}", "start_char_idx": 0, "end_char_idx": 2385, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aaeba83e-e4a6-4f44-8a28-5974fd74ab5b": {"__data__": {"id_": "aaeba83e-e4a6-4f44-8a28-5974fd74ab5b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f2746f9b-0a23-4d91-b658-3a37569a2275", "node_type": "4", "metadata": {}, "hash": "01bc90cb766b8793ecdfb92e4a4ba9134b45336f96ca1144dff1545dca3d4ba5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\nDescription :\nThe developer builds a security-critical protection mechanism into the software, but the compiler optimizes the program such that the mechanism is removed or modified. \nExample: 1\nC\n(bad code)\u00a0\nvoid GetData(char *MFAddr) {\nchar pwd[64];\nif (GetPasswordFromUser(pwd, sizeof(pwd))) {\nif (ConnectToMainframe(MFAddr, pwd)) {\n// Interaction with mainframe\n}\n}\nmemset(pwd, 0, sizeof(pwd));\n}", "start_char_idx": 0, "end_char_idx": 480, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "898d4564-10e1-4a60-86ee-90d68fc226a4": {"__data__": {"id_": "898d4564-10e1-4a60-86ee-90d68fc226a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7318402d-2773-4f3d-b1c5-121256b95d5d", "node_type": "4", "metadata": {}, "hash": "a850767a7082c8dcf0cb4668630329b32969a7c3deb6171a7e43699da7b07734", "class_name": "RelatedNodeInfo"}}, "text": "CWE-312: Cleartext Storage of Sensitive Information\nDescription :\nThe product stores sensitive information in cleartext within a resource that might be accessible to another control sphere. \nExtended Description :\nBecause the information is stored in cleartext (i.e., unencrypted), attackers could potentially read it. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information. When organizations adopt cloud services, it can be easier for attackers to access the data from anywhere on the Internet. In some systems/environments such as cloud, the use of \"double encryption\" (at both the software and hardware layer) might be required, and the developer might be solely responsible for both layers, instead of shared responsibility with the administrator of the broader system/environment. \nExample: 3\nC\n(bad code)\u00a0\nserver.sin_family = AF_INET; hp = gethostbyname(argv[1]);\nif (hp==NULL) error(\"Unknown host\");\nmemcpy( (char *)&server.sin_addr,(char *)hp->h_addr,hp->h_length);\nif (argc < 3) port = 80;\nelse port = (unsigned short)atoi(argv[3]);\nserver.sin_port = htons(port);\nif (connect(sock, (struct sockaddr *)&server, sizeof server) < 0) error(\"Connecting\");\n...\nwhile ((n=read(sock,buffer,BUFSIZE-1))!=-1) {\nwrite(dfd,password_buffer,n);\n...", "start_char_idx": 0, "end_char_idx": 1354, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d0de13c-b3a0-49db-95a6-020a46cfe66e": {"__data__": {"id_": "1d0de13c-b3a0-49db-95a6-020a46cfe66e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "77e5aa73-4800-4c76-9603-42afe8f66907", "node_type": "4", "metadata": {}, "hash": "3196b967f584e020e2d1b07b816d3a443b5d410849ae05406993dc18a25d7f08", "class_name": "RelatedNodeInfo"}}, "text": "CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')\nDescription :\nThe product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type. \nExtended Description :\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access. While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways. This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues. \nExample: 1\nC\n(bad code)\u00a0\n#define NAME_TYPE 1\n#define ID_TYPE 2\nstruct MessageBuffer\n{int msgType;\nunion {char *name;\nint nameID;\n};\n};\nint main (int argc, char **argv) {\nstruct MessageBuffer buf;\nchar *defaultMessage = \"Hello World\";\nbuf.msgType = NAME_TYPE;\nbuf.name = defaultMessage;\nprintf(\"Pointer of buf.name is %p\\n\", buf.name);\n/* This particular value for nameID is used to make the code architecture-independent. If coming from untrusted input, it could be any value. */\nbuf.nameID = (int)(defaultMessage + 1);\nprintf(\"Pointer of buf.name is now %p\\n\", buf.name);\nif (buf.msgType == NAME_TYPE) {printf(\"Message: %s\\n\", buf.name);\n}\nelse {printf(\"Message: Use ID %d\\n\", buf.nameID);\n}\n}\nExample: 2\nPHP\n(bad code)\u00a0\n$value = $_GET['value'];\n$sum = $value + 5;\necho \"value parameter is '$value'<p>\";\necho \"SUM is $sum\";\nExample: 3\nPerl\n(bad code)\u00a0\nmy $UserPrivilegeArray = [\"user\", \"user\", \"admin\", \"user\"];\nmy $userID = get_current_user_ID();\nif ($UserPrivilegeArray eq \"user\") {print \"Regular user!\\n\";\n}\nelse {print \"Admin!\\n\";\n}\nprint \"\\$UserPrivilegeArray = $UserPrivilegeArray\\n\";", "start_char_idx": 0, "end_char_idx": 2235, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "16156a5c-3863-4134-87b8-0dba8ca24772": {"__data__": {"id_": "16156a5c-3863-4134-87b8-0dba8ca24772", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a520791c-9866-4cf3-a82f-9f303c1ce8b9", "node_type": "4", "metadata": {}, "hash": "822b5e87dd6943539814d69d40edf6c8302003e57f47fbdc0681411a31f06c70", "class_name": "RelatedNodeInfo"}}, "text": "CWE-456: Missing Initialization of a Variable\nDescription :\nThe product does not initialize critical variables, which causes the execution environment to use unexpected values. \nExample: 1\nC\n(bad code)\u00a0\nvoid parse_data(char *untrusted_input){\nint m, n, error;\nerror = sscanf(untrusted_input, \"%d:%d\", &m, &n);\nif ( EOF == error ){die(\"Did not specify integer value. Die evil hacker!\\n\");\n}\n/* proceed assuming n and m are initialized correctly */\n}\nExample: 2\nJava\n(bad code)\u00a0\nprivate User user;\npublic void someMethod() {\n// Do something interesting.\n...\n// Throws NPE if user hasn't been properly initialized.\nString username = user.getName();\n}\nExample: 3\nPHP\n(bad code)\u00a0\nif (authenticate($username,$password) && setAdmin($username)){$isAdmin = true;\n}\n/.../\nif ($isAdmin){deleteUser($userToDelete);\n}\nExample: 4\nJava\n(bad code)\u00a0\npublic class BankManager {\n// user allowed to perform bank manager tasks\nprivate User user = null;\nprivate boolean isUserAuthentic = false;\n// constructor for BankManager class\npublic BankManager() {...\n}\n// retrieve user from database of users\npublic User getUserFromUserDatabase(String username){...\n}\n// set user variable using username\npublic void setUser(String username) {this.user = getUserFromUserDatabase(username);\n}\n// authenticate user\npublic boolean authenticateUser(String username, String password) {if (username.equals(user.getUsername()) && password.equals(user.getPassword())) {isUserAuthentic = true;\n}\nreturn isUserAuthentic;\n}\n// methods for performing bank manager tasks\n...\n}", "start_char_idx": 0, "end_char_idx": 1531, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a2cc456a-2bd8-4af2-a9df-acb511448c85": {"__data__": {"id_": "a2cc456a-2bd8-4af2-a9df-acb511448c85", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "940c0067-7952-4ea8-9cbe-309bbd801ed7", "node_type": "4", "metadata": {}, "hash": "33c6e329ad30ddf3b227c588b1783f9a6c5e7420f3890e439e606b3239e7532a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-308: Use of Single-factor Authentication\nDescription :\nThe use of single-factor authentication can lead to unnecessary risk of compromise when compared with the benefits of a dual-factor authentication scheme. \nExample: 1\nC\n(bad code)\u00a0\nunsigned char *check_passwd(char *plaintext) {ctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n//Login if hash matches stored hash\nif (equal(ctext, secret_password())) {login_user();\n}\n}", "start_char_idx": 0, "end_char_idx": 442, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff6fc434-a447-45ff-b5da-d16a0b925bc9": {"__data__": {"id_": "ff6fc434-a447-45ff-b5da-d16a0b925bc9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "417f4b3f-3b6a-419b-9d9c-beb88f34b630", "node_type": "4", "metadata": {}, "hash": "26fdde6abea69f9d73dd6ebdc313325b9975b783df615f226677674f5477f8d1", "class_name": "RelatedNodeInfo"}}, "text": "CWE-588: Attempt to Access Child of a Non-structure Pointer\nDescription :\nCasting a non-structure type to a structure type and accessing a field can lead to memory access errors or data corruption. \nExample: 1\nC\n(bad code)\u00a0\nstruct foo\n{int i;\n}\n...\nint main(int argc, char **argv)\n{*foo = (struct foo *)main;\nfoo->i = 2;\nreturn foo->i;\n}", "start_char_idx": 0, "end_char_idx": 337, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b0f9943b-4f48-42a7-8c82-02192273fb58": {"__data__": {"id_": "b0f9943b-4f48-42a7-8c82-02192273fb58", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ec34bbc-b547-4d43-84aa-ae2ff2a80a0f", "node_type": "4", "metadata": {}, "hash": "6926236ceca48f7b793ae15e43ec9560b8b49178987334344632695fa9c6650e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-369: Divide By Zero\nDescription :\nThe product divides a value by zero. \nExtended Description :\nThis weakness typically occurs when an unexpected value is provided to the product, or if an error occurs that is not properly detected. It frequently occurs in calculations involving physical dimensions such as size, length, width, and height. \nExample: 1\nJava\n(bad code)\u00a0\npublic int computeAverageResponseTime (int totalTime, int numRequests) {return totalTime / numRequests;\n}\nExample: 2\nC\n(bad code)\u00a0\ndouble divide(double x, double y){return x/y;\n}\nExemple bonus : \nC\n(bad code)\u00a0\nint main()\n{\n    int x;\n    int y=0;\n    if (!y)\n    {\n        x=4/y;\n    }\n    return 0;\n}\nC\n(bad code)\u00a0\nint main()\n{\n    int x;\n    int y=0;\n    x=2/y;\n    return 0;\n}\nC\n(bad code)\u00a0 \nint main()\n{\n    int x;\n    x=1/0;\n    return 0;\n}", "start_char_idx": 0, "end_char_idx": 818, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3343926b-6c5e-4dd0-b83a-027f06cbf5f8": {"__data__": {"id_": "3343926b-6c5e-4dd0-b83a-027f06cbf5f8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa21149b-e1ab-4fda-9eda-c309d4cc8a23", "node_type": "4", "metadata": {}, "hash": "94b1395fa5769749fa880956f5feebf6bb2a6092b5b12552286e1ad4e6dfe04e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-587: Assignment of a Fixed Address to a Pointer\nDescription :\nThe product sets a pointer to a specific address other than NULL or 0. \nExtended Description :\nUsing a fixed address is not portable, because that address will probably not be valid in all environments or platforms. \nExample: 1\nC\n(bad code)\u00a0\nint (*pt2Function) (float, char, char)=0x08040000;\nint result2 = (*pt2Function) (12, 'a', 'b');\n// Here we can inject code to execute.", "start_char_idx": 0, "end_char_idx": 442, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ca104edf-c6b9-4069-8858-2b8dd8437fc1": {"__data__": {"id_": "ca104edf-c6b9-4069-8858-2b8dd8437fc1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "256707a6-0549-4385-bd3f-e03e6b6f9de5", "node_type": "4", "metadata": {}, "hash": "d6b9b00d61d3acb1958a2bacfc83c345c53baed936235e8b4df62f1ba58ae102", "class_name": "RelatedNodeInfo"}}, "text": "CWE-135: Incorrect Calculation of Multi-Byte String Length\nDescription :\nThe product does not correctly calculate the length of strings that can contain wide or multi-byte characters. \nExample: 1\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <strings.h>\n#include <wchar.h>\nint main() {\nwchar_t wideString[] = L\"The spazzy orange tiger jumped \" \\\n\"over the tawny jaguar.\";\nwchar_t *newString;\nprintf(\"Strlen() output: %d\\nWcslen() output: %d\\n\",\nstrlen(wideString), wcslen(wideString));\n/* Wrong because the number of chars in a string isn't related to its length in bytes //\nnewString = (wchar_t *) malloc(strlen(wideString));\n*/\n/* Wrong because wide characters aren't 1 byte long! //\nnewString = (wchar_t *) malloc(wcslen(wideString));\n*/\n/* Wrong because wcslen does not include the terminating null */\nnewString = (wchar_t *) malloc(wcslen(wideString) * sizeof(wchar_t));\n/* correct! */\nnewString = (wchar_t *) malloc((wcslen(wideString) + 1) * sizeof(wchar_t));\n/* ... */\n}", "start_char_idx": 0, "end_char_idx": 974, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2dca516b-3a82-4d7d-bea4-ac2d0c4aff45": {"__data__": {"id_": "2dca516b-3a82-4d7d-bea4-ac2d0c4aff45", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d12442a9-f9c2-465b-a04e-48fee91f3265", "node_type": "4", "metadata": {}, "hash": "f453e04321c75bc795de609fabadf064c3915d0130e19ecd1c80cdbf8d1245c3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-114: Process Control\nDescription :\nExecuting commands or loading libraries from an untrusted source or in an untrusted environment can cause an application to execute malicious commands (and payloads) on behalf of an attacker. \nExtended Description :\nProcess control vulnerabilities take two forms: An attacker can change the command that the program executes: the attacker explicitly controls what the command is. An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means. Process control vulnerabilities of the first type occur when either data enters the application from an untrusted source and the data is used as part of a string representing a command that is executed by the application. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. \nExample: 1\nJava\n(bad code)\u00a0\n...\nSystem.loadLibrary(\"library.dll\");\n...\nExample: 2\nC\n(bad code)\u00a0\n...\nRegQueryValueEx(hkey, \"APPHOME\",\n0, 0, (BYTE*)home, &size);\nchar* lib=(char*)malloc(strlen(home)+strlen(INITLIB));\nif (lib) {\nstrcpy(lib,home);\nstrcat(lib,INITCMD);\nLoadLibrary(lib);\n}\n...\nExample: 3\nC\n(bad code)\u00a0\nLoadLibrary(\"liberty.dll\");", "start_char_idx": 0, "end_char_idx": 1240, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5a76c44d-79db-40a8-b1f6-69e35ce2b3ab": {"__data__": {"id_": "5a76c44d-79db-40a8-b1f6-69e35ce2b3ab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0ffd3982-f064-48d5-a68b-797a71b399d1", "node_type": "4", "metadata": {}, "hash": "1730b38cf75e8bfd9785e44505dfd1385fe2973bd93ad7fc9221dc781ce6ba0f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-666: Operation on Resource in Wrong Phase of Lifetime\nDescription :\nThe product performs an operation on a resource at the wrong phase of the resource's lifecycle, which can lead to unexpected behaviors. \nExtended Description :\nA resource's lifecycle includes several phases: initialization, use, and release. For each phase, it is important to follow the specifications outlined for how to operate on the resource and to ensure that the resource is in the expected phase. Otherwise, if a resource is in one phase but the operation is not valid for that phase (i.e., an incorrect phase of the resource's lifetime), then this can produce resultant weaknesses. For example, using a resource before it has been fully initialized could cause corruption or incorrect data to be used. \nExample: 1\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\n\t\t\t\t   ...\n\t\t\t\t   if (abrt) {\n\t\t\t\t\t free(ptr);\n\t\t\t\t   }\n\t\t\t\t   ...\n\t\t\t\t   free(ptr);", "start_char_idx": 0, "end_char_idx": 927, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "de0808f0-3c90-4141-a6b6-bae9a1423e36": {"__data__": {"id_": "de0808f0-3c90-4141-a6b6-bae9a1423e36", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "726f98ec-f991-4cdf-a0c6-1623c03380db", "node_type": "4", "metadata": {}, "hash": "84e326f3178c2bf4fb3b785a3f7306403a8277f0c3a674216c4615be25c2c6d5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-691: Insufficient Control Flow Management\nDescription :\nThe code does not sufficiently manage its control flow during execution, creating conditions in which the control flow can be modified in unexpected ways. \nExample: 1\nC\n(bad code)\u00a0\nvoid f(pthread_mutex_t *mutex) {\npthread_mutex_lock(mutex);\n/* access shared resource */\npthread_mutex_unlock(mutex);\n}\nExample: 2\nC\n(good code)\u00a0\nint f(pthread_mutex_t *mutex) {\nint result;\nresult = pthread_mutex_lock(mutex);\nif (0 != result)return result;\n/* access shared resource */\nreturn pthread_mutex_unlock(mutex);\n}\nExample: 3\nC\n(bad code)\u00a0\nif (condition==true)Do_X();\nDo_Y();", "start_char_idx": 0, "end_char_idx": 625, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f0708548-fb19-4026-8326-99cd57fb8bb1": {"__data__": {"id_": "f0708548-fb19-4026-8326-99cd57fb8bb1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4d6872a6-1959-4f57-8cbf-eb2a1e423908", "node_type": "4", "metadata": {}, "hash": "d61d8d75e918ffc34f1c1b99a79a381202e972139f7fd335cac53186dc93c2a6", "class_name": "RelatedNodeInfo"}}, "text": "CWE-463: Deletion of Data Structure Sentinel\nDescription :\nThe accidental deletion of a data-structure sentinel can cause serious programming logic problems. \nExtended Description :\nOften times data-structure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety. \nExample: 1\nC\n(bad code)\u00a0\nchar *foo;\nint counter;\nfoo=calloc(sizeof(char)*10);\nfor (counter=0;counter!=10;counter++) {foo[counter]='a';\nprintf(\"%s\\n\",foo);\n}", "start_char_idx": 0, "end_char_idx": 798, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04282650-be8e-465b-87b0-2c57c7c5d22c": {"__data__": {"id_": "04282650-be8e-465b-87b0-2c57c7c5d22c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "09121923-dafd-430e-85fa-27f0d1c5c108", "node_type": "4", "metadata": {}, "hash": "28a79a15cfb61c4c074bb83262e8b487dfb18dc039079845330441ebf0a80b80", "class_name": "RelatedNodeInfo"}}, "text": "CWE-697: Incorrect Comparison\nDescription :\nThe product compares two entities in a security-relevant context, but the comparison is incorrect, which may lead to resultant weaknesses. \nExample: 1\nJava\n(bad code)\u00a0\npublic class Truck {\nprivate String make;\nprivate String model;\nprivate int year;\npublic boolean equals(Object o) {\nif (o == null) return false;\nif (o == this) return true;\nif (!(o instanceof Truck)) return false;\nTruck t = (Truck) o;\nreturn (this.make.equals(t.getMake()) && this.model.equals(t.getModel()));\n}\n}\nExample: 2\nC\n(bad code)\u00a0\n/* Ignore CWE-259 (hard-coded password) and CWE-309 (use of password system for authentication) for this example. */ \nchar *username = \"admin\";\nchar *pass = \"password\";\nint AuthenticateUser(char *inUser, char *inPass) {if (strncmp(username, inUser, strlen(inUser))) {logEvent(\"Auth failure of username using strlen of inUser\");\nreturn(AUTH_FAIL);\n}\nif (! strncmp(pass, inPass, strlen(inPass))) {logEvent(\"Auth success of password using strlen of inUser\");\nreturn(AUTH_SUCCESS);\n}\nelse {logEvent(\"Auth fail of password using sizeof\");\nreturn(AUTH_FAIL);\n}\n}\nint main (int argc, char **argv) {\n                     int authResult;\nif (argc < 3) {ExitError(\"Usage: Provide a username and password\");\n}\nauthResult = AuthenticateUser(argv[1], argv[2]);\nif (authResult == AUTH_SUCCESS) {DoAuthenticatedTask(argv[1]);\n}\nelse {ExitError(\"Authentication failed\");\n}\n}", "start_char_idx": 0, "end_char_idx": 1409, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fadd678c-faee-43ba-9bf0-ed792f5b70b8": {"__data__": {"id_": "fadd678c-faee-43ba-9bf0-ed792f5b70b8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "52ffb245-526f-4653-82dd-f004fdf72f09", "node_type": "4", "metadata": {}, "hash": "089791389fd16ff1f4578af93253d2e2db771bfba4c24fa546c0776c55fb2d77", "class_name": "RelatedNodeInfo"}}, "text": "CWE-675: Multiple Operations on Resource in Single-Operation Context\nDescription :\nThe product performs the same operation on a resource two or more times, when the operation should only be applied once. \nExample: 1\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\n...\nif (abrt) {free(ptr);\n}\n...\nfree(ptr);\nExample: 2\nC\n(bad code)\u00a0\nvoid bind_socket(void) {\nint server_sockfd;\nint server_len;\nstruct sockaddr_in server_address;\n/*unlink the socket if already bound to avoid an error when bind() is called*/\nunlink(\"server_socket\");\nserver_sockfd = socket(AF_INET, SOCK_STREAM, 0);\nserver_address.sin_family = AF_INET;\nserver_address.sin_port = 21;\nserver_address.sin_addr.s_addr = htonl(INADDR_ANY);\nserver_len = sizeof(struct sockaddr_in);\nbind(server_sockfd, (struct sockaddr *) &s1, server_len);\n}", "start_char_idx": 0, "end_char_idx": 799, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97acb953-74bd-45f7-9e55-406c762eb3ec": {"__data__": {"id_": "97acb953-74bd-45f7-9e55-406c762eb3ec", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "365adf3d-99f8-4c13-b44b-3b1fe312ba22", "node_type": "4", "metadata": {}, "hash": "2a74893574d2ae6ba7d7e69fe8a3e53a649d2e3b27fe1fe998501da968db5f63", "class_name": "RelatedNodeInfo"}}, "text": "CWE-560: Use of umask() with chmod-style Argument\n+ Description\nThe product calls umask() with an incorrect argument that is specified as if it is an argument to chmod().\nExemple bonus \nC\n(bad code)\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\nvoid umask_incorrect(){\n        umask(0666);\n        int fd = open(\"some_random_file\", O_CREAT|O_WRONLY, 0666);\n        close(fd);\n}\nvoid umask_correct(){\n        umask(022);\n        int fd = open(\"some_random_file\", O_CREAT|O_WRONLY, 0666);\n        close(fd);\n}\nint main(){\n        umask_correct();\n        umask_incorrect();\n        return 0;\n}\nExemples de umask Correctes\numask(022) : Cette valeur est souvent utilis\u00e9e pour assurer que les nouveaux fichiers soient lisibles et ex\u00e9cutables par tout le monde, mais modifiables seulement par le propri\u00e9taire. Les fichiers seront cr\u00e9\u00e9s avec des permissions 755 pour les r\u00e9pertoires et 644 pour les fichiers, dans un contexte o\u00f9 les permissions par d\u00e9faut sont 777 pour les r\u00e9pertoires et 666 pour les fichiers.\numask(002) : Utilis\u00e9e dans des environnements o\u00f9 les fichiers doivent \u00eatre modifiables par les membres d'un m\u00eame groupe. Les fichiers seront cr\u00e9\u00e9s avec des permissions 775 pour les r\u00e9pertoires et 664 pour les fichiers, permettant aux membres du groupe de modifier les fichiers.\numask(077) : Pour un environnement hautement s\u00e9curis\u00e9 o\u00f9 les fichiers ne doivent \u00eatre accessibles qu'au propri\u00e9taire. Les fichiers seront cr\u00e9\u00e9s avec des permissions 700 pour les r\u00e9pertoires et 600 pour les fichiers.\nExemples de umask Incorrectes\numask(000) ou umask(777): Cela signifie qu'aucune permission ne sera retir\u00e9e, et les fichiers seront cr\u00e9\u00e9s avec les permissions les plus permissives possibles (777 pour les r\u00e9pertoires et 666 pour les fichiers). C'est g\u00e9n\u00e9ralement consid\u00e9r\u00e9 comme une mauvaise pratique de s\u00e9curit\u00e9, car cela laisse les fichiers et r\u00e9pertoires ouverts \u00e0 la modification par n'importe quel utilisateur.\numask(0666) : C'est un exemple incorrect non seulement parce que 0666 est au-del\u00e0 de l'espace de valeurs valides pour umask (qui devrait \u00eatre entre 000 et 0777), mais aussi parce que l'intention semble \u00eatre de retirer toutes les permissions, ce qui n'est pas pratique et m\u00e8ne \u00e0 la confusion.", "start_char_idx": 0, "end_char_idx": 2281, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f5b83331-b18a-4d0d-9bb5-8e40854b9edd": {"__data__": {"id_": "f5b83331-b18a-4d0d-9bb5-8e40854b9edd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "dd7ef8a7-8687-4e4e-a28d-44a3de999039", "node_type": "4", "metadata": {}, "hash": "954d98b2778c9112a008be13ac58904675cb634ab86d687d0a8ea2bd0b1aefb4", "class_name": "RelatedNodeInfo"}}, "text": "CWE-477: Use of Obsolete Function\nDescription :\nThe code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained. \nExtended Description :\nAs programming languages evolve, functions occasionally become obsolete due to: Advances in the language Improved understanding of how operations should be performed effectively and securely Changes in the conventions that govern certain operations Functions that are removed are usually replaced by newer counterparts that perform the same task in some different and hopefully improved way. \nExample: 1\nC\n(bad code)\u00a0\n...\ngetpw(uid, pwdline);\nfor (i=0; i<3; i++){cryptpw=strtok(pwdline, \":\");\npwdline=0;\n}\nresult = strcmp(crypt(plainpw,cryptpw), cryptpw) == 0;\n...", "start_char_idx": 0, "end_char_idx": 759, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3fc6684c-cb83-47af-b4dd-9c6c031852f1": {"__data__": {"id_": "3fc6684c-cb83-47af-b4dd-9c6c031852f1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ac01e08-3616-4d38-84fa-64cce6dec27d", "node_type": "4", "metadata": {}, "hash": "dcc8d94e90f0b911833f4e386597955103e1eb8bfb0570128a2dd8586622c0f2", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\nDescription :\nThe product receives input that is expected to specify an index, position, or offset into an indexable resource such as a buffer or file, but it does not validate or incorrectly validates that the specified index/position/offset has the required properties. \nExample: 1\nC\n(bad code)\u00a0\n/* capture the sizes of all messages */\nint getsizes(int sock, int count, int *sizes) {\n...\nchar buf[BUFFER_SIZE];\nint ok;\nint num, size;\n// read values from socket and added to sizes array\nwhile ((ok = gen_recv(sock, buf, sizeof(buf))) == 0)\n{\n// continue read from socket until buf only contains '.'\nif (DOTLINE(buf))break;\nelse if (sscanf(buf, \"%d %d\", &num, &size) == 2)sizes[num - 1] = size;\n}...\n}\nExample: 2\nC\n(good code)\u00a0\n/* capture the sizes of all messages */\nint getsizes(int sock, int count, int *sizes) {\n...\nchar buf[BUFFER_SIZE];\nint ok;\nint num, size;\n// read values from socket and added to sizes array\nwhile ((ok = gen_recv(sock, buf, sizeof(buf))) == 0)\n{\n// continue read from socket until buf only contains '.'\nif (DOTLINE(buf))break;\nelse if (sscanf(buf, \"%d %d\", &num, &size) == 2) {\nif (num > 0 && num <= (unsigned)count)sizes[num - 1] = size;\nelse\n/* warn about possible attempt to induce buffer overflow */\nreport(stderr, \"Warning: ignoring bogus data for message sizes returned by server.\\n\");\n}\n}...\n}\nExample: 3\nJava\n(bad code)\u00a0\n// Method called from servlet to obtain product information\npublic String displayProductSummary(int index) {\nString productSummary = new String(\"\");\ntry {String productSummary = getProductSummary(index);\n} catch (Exception ex) {...}\nreturn productSummary;\n}\npublic String getProductSummary(int index) {return products[index];\n}", "start_char_idx": 0, "end_char_idx": 1762, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9160f2a0-a411-4c1b-9908-38e38c9f4478": {"__data__": {"id_": "9160f2a0-a411-4c1b-9908-38e38c9f4478", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "89eda4d2-0ecf-421f-bd59-bddbb1396dfc", "node_type": "4", "metadata": {}, "hash": "290cb6fd6acf8c342b8f10f0fef08c97ee7b270a64de3cf901f97055c6b502c5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-415: Double Free\nDescription :\nThe product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations. \nExtended Description :\nWhen a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack. \nExample: 1\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\n\t\t\t\t   ...\n\t\t\t\t   if (abrt) {\n\t\t\t\t\t free(ptr);\n\t\t\t\t   }\n\t\t\t\t   ...\n\t\t\t\t   free(ptr);\nExample: 2\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <unistd.h>\n#define BUFSIZE1 512\n#define BUFSIZE2 ((BUFSIZE1/2) - 8)\nint main(int argc, char **argv) {char *buf1R1;\nchar *buf2R1;\nchar *buf1R2;\nbuf1R1 = (char *) malloc(BUFSIZE2);\nbuf2R1 = (char *) malloc(BUFSIZE2);\nfree(buf1R1);\nfree(buf2R1);\nbuf1R2 = (char *) malloc(BUFSIZE1);\nstrncpy(buf1R2, argv[1], BUFSIZE1-1);\nfree(buf2R1);\nfree(buf1R2);\n}", "start_char_idx": 0, "end_char_idx": 1205, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91e1da35-e0f0-45d7-8299-42ef5768fcc5": {"__data__": {"id_": "91e1da35-e0f0-45d7-8299-42ef5768fcc5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "43b50e3f-a302-4fb8-ac40-11f06fc61919", "node_type": "4", "metadata": {}, "hash": "a818cd766570fcd700e0170f34488c3f35d157a290a21a41cfb417abb30a4145", "class_name": "RelatedNodeInfo"}}, "text": "CWE-291: Reliance on IP Address for Authentication\nDescription :\nThe product uses an IP address for authentication. \nExample: 1\nC\n(bad code)\u00a0\nsd = socket(AF_INET, SOCK_DGRAM, 0);\nserv.sin_family = AF_INET;\nserv.sin_addr.s_addr = htonl(INADDR_ANY);\nservr.sin_port = htons(1008);\nbind(sd, (struct sockaddr *) & serv, sizeof(serv));\nwhile (1) {memset(msg, 0x0, MAX_MSG);\nclilen = sizeof(cli);\nif (inet_ntoa(cli.sin_addr)==getTrustedAddress()) {n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);\n}\n}", "start_char_idx": 0, "end_char_idx": 515, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ddd5236b-0ff1-4b0e-aa15-7b55b1a4180c": {"__data__": {"id_": "ddd5236b-0ff1-4b0e-aa15-7b55b1a4180c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6776b70a-5c1b-4edc-8dff-e6feea74f170", "node_type": "4", "metadata": {}, "hash": "43a79770c79d6d243c2846862ec26a6ff5de39b68afb8967fcbb44f5e8e026c4", "class_name": "RelatedNodeInfo"}}, "text": "CWE-328: Use of Weak Hash\nDescription :\nThe product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack). \nExtended Description :\nA hash function is defined as an algorithm that maps arbitrarily sized data into a fixed-sized digest (output) such that the following properties hold: The algorithm is not invertible (also called \"one-way\" or \"not reversible\") The algorithm is deterministic; the same input produces the same digest every time Building on this definition, a cryptographic hash function must also ensure that a malicious actor cannot leverage the hash function to have a reasonable chance of success at determining any of the following: the original input (preimage attack), given only the digest another input that can produce the same digest (2nd preimage attack), given the original input a set of two or more inputs that evaluate to the same digest (birthday attack), given the actor can arbitrarily choose the inputs to be hashed and can do so a reasonable amount of times What is regarded as \"reasonable\" varies by context and threat model, but in general, \"reasonable\" could cover any attack that is more efficient than brute force (i.e., on average, attempting half of all possible combinations). Note that some attacks might be more efficient than brute force but are still not regarded as achievable in the real world. Any algorithm that does not meet the above conditions will generally be considered weak for general use in hashing. In addition to algorithmic weaknesses, a hash function can be made weak by using the hash in a security context that breaks its security guarantees. For example, using a hash function without a salt for storing passwords (that are sufficiently short) could enable an adversary to create a \"rainbow table\" [REF-637] to recover the password under certain conditions; this attack works against such hash functions as MD5, SHA-1, and SHA-2. \nExample: 1\nC\n(bad code)\u00a0\nunsigned char *check_passwd(char *plaintext) {ctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n//Login if hash matches stored hash\nif (equal(ctext, secret_password())) {login_user();\n}\n}", "start_char_idx": 0, "end_char_idx": 2420, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71043004-cf5f-4e7b-8f2e-e057d118fedf": {"__data__": {"id_": "71043004-cf5f-4e7b-8f2e-e057d118fedf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2d9178b5-acea-41c4-9857-b20031c9f6b9", "node_type": "4", "metadata": {}, "hash": "d80f9f747d9536e9c5ecd6db08838323e19af3b13915b2374818de8e13cf80a0", "class_name": "RelatedNodeInfo"}}, "text": "CWE-354: Improper Validation of Integrity Check Value\nDescription :\nThe product does not validate or incorrectly validates the integrity check values or \"checksums\" of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission. \nExample: 1\nC\n(bad code)\u00a0\nsd = socket(AF_INET, SOCK_DGRAM, 0); serv.sin_family = AF_INET;\nserv.sin_addr.s_addr = htonl(INADDR_ANY);\nservr.sin_port = htons(1008);\nbind(sd, (struct sockaddr *) & serv, sizeof(serv));\nwhile (1) {\nmemset(msg, 0x0, MAX_MSG);\nclilen = sizeof(cli);\nif (inet_ntoa(cli.sin_addr)==...) n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);\n}", "start_char_idx": 0, "end_char_idx": 655, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3517aee2-144d-46e7-b9b5-4a3c97007fdf": {"__data__": {"id_": "3517aee2-144d-46e7-b9b5-4a3c97007fdf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c4a87ce8-0d6d-42ff-8a52-580d353756da", "node_type": "4", "metadata": {}, "hash": "f82d3ba35a0374070260dc96d1074429914b365baf1603da1ae64272f9de0378", "class_name": "RelatedNodeInfo"}}, "text": "CWE-364: Signal Handler Race Condition\nDescription :\nThe product uses a signal handler that introduces a race condition. \nExtended Description :\nRace conditions frequently occur in signal handlers, since signal handlers support asynchronous actions. These race conditions have a variety of root causes and symptoms. Attackers may be able to exploit a signal handler race condition to cause the product state to be corrupted, possibly leading to a denial of service or even code execution. These issues occur when non-reentrant functions, or state-sensitive actions occur in the signal handler, where they may be called at any time. These behaviors can violate assumptions being made by the \"regular\" code that is interrupted, or by other signal handlers that may also be invoked. If these functions are called at an inopportune moment - such as while a non-reentrant function is already running - memory corruption could occur that may be exploitable for code execution. Another signal race condition commonly found occurs when free is called within a signal handler, resulting in a double free and therefore a write-what-where condition. Even if a given pointer is set to NULL after it has been freed, a race condition still exists between the time the memory was freed and the pointer was set to NULL. This is especially problematic if the same signal handler has been set for more than one signal -- since it means that the signal handler itself may be reentered. There are several known behaviors related to signal handlers that have received the label of \"signal handler race condition\": Shared state (e.g. global data or static variables) that are accessible to both a signal handler and \"regular\" code Shared state between a signal handler and other signal handlers Use of non-reentrant functionality within a signal handler - which generally implies that shared state is being used. For example, malloc() and free() are non-reentrant because they may use global or static data structures for managing memory, and they are indirectly used by innocent-seeming functions such as syslog(); these functions could be exploited for memory corruption and, possibly, code execution. Association of the same signal handler function with multiple signals - which might imply shared state, since the same code and resources are accessed. For example, this can be a source of double-free and use-after-free weaknesses. Use of setjmp and longjmp, or other mechanisms that prevent a signal handler from returning control back to the original functionality While not technically a race condition, some signal handlers are designed to be called at most once, and being called more than once can introduce security problems, even when there are not any concurrent calls to the signal handler. This can be a source of double-free and use-after-free weaknesses. Signal handler vulnerabilities are often classified based on the absence of a specific protection mechanism, although this style of classification is discouraged in CWE because programmers often have a choice of several different mechanisms for addressing the weakness. Such protection mechanisms may preserve exclusivity of access to the shared resource, and behavioral atomicity for the relevant code: Avoiding shared state Using synchronization in the signal handler Using synchronization in the regular code Disabling or masking other signals, which provides atomicity (which effectively ensures exclusivity) \nExample: 1\nC\n(bad code)\u00a0\nchar *logMessage;\nvoid handler (int sigNum) {\nsyslog(LOG_NOTICE, \"%s\\n\", logMessage);\nfree(logMessage);\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\nsleep(10);\nexit(0);\n}\nint main (int argc, char* argv[]) {\nlogMessage = strdup(argv[1]);\n/* Register signal handlers. */\nsignal(SIGHUP, handler);\nsignal(SIGTERM, handler);\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\nsleep(10);\n}\nExample: 2\nC\n(bad code)\u00a0\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\nvoid *global1, *global2;\nchar *what;\nvoid sh (int dummy) {\nsyslog(LOG_NOTICE,\"%s\\n\",what);\nfree(global2);\nfree(global1);\n/* Sleep statements added to expand timing window for race condition */\nsleep(10);\nexit(0);\n}\nint main (int argc,char* argv[]) {\nwhat=argv[1];\nglobal1=strdup(argv[2]);\nglobal2=malloc(340);\nsignal(SIGHUP,sh);\nsignal(SIGTERM,sh);\n/* Sleep statements added to expand timing window for race condition */\nsleep(10);\nexit(0);\n}", "start_char_idx": 0, "end_char_idx": 4534, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4519ac59-dfd5-47c3-848a-94486cff1217": {"__data__": {"id_": "4519ac59-dfd5-47c3-848a-94486cff1217", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a7e15a6b-4dde-49da-bcd3-2ce3e14c8098", "node_type": "4", "metadata": {}, "hash": "57ac2c75d5ff864e6a3312400aae4a9777f82919dd0e83ecf881b4c616acd752", "class_name": "RelatedNodeInfo"}}, "text": "CWE-672: Operation on a Resource after Expiration or Release\nDescription :\nThe product uses, accesses, or otherwise operates on a resource after that resource has been expired, released, or revoked. \nExample: 1\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\nif (err) {abrt = 1;\nfree(ptr);\n}\n...\nif (abrt) {logError(\"operation aborted before commit\", ptr);\n}\nExample: 2\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\n...\nif (abrt) {free(ptr);\n}\n...\nfree(ptr);\nExample: 3\nC\n(bad code)\u00a0\n#define FAIL 0\n#define SUCCESS 1\n#define ERROR -1\n#define MAX_MESSAGE_SIZE 32\nint processMessage(char **message)\n{\nint result = SUCCESS;\nint length = getMessageLength(message[0]);\nchar *messageBody;\nif ((length > 0) && (length < MAX_MESSAGE_SIZE)) {\nmessageBody = (char*)malloc(length*sizeof(char));\nmessageBody = &message[1][0];\nint success = processMessageBody(messageBody);\nif (success == ERROR) {result = ERROR;\nfree(messageBody);\n}\n}\nelse {printf(\"Unable to process message; invalid message length\");\nresult = FAIL;\n}\nif (result == ERROR) {logError(\"Error processing message\", messageBody);\n}\nreturn result;\n}", "start_char_idx": 0, "end_char_idx": 1100, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "53003f8f-bb03-4728-9f31-81415858c275": {"__data__": {"id_": "53003f8f-bb03-4728-9f31-81415858c275", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8f2d85bc-2dda-4ba2-b52e-e4f0f00a9a9e", "node_type": "4", "metadata": {}, "hash": "a77fe20f5160b8129313952d887fe15bad21d8d1c7633184efd1893173dfb97a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-192: Integer Coercion Error\nDescription :\nInteger coercion refers to a set of flaws pertaining to the type casting, extension, or truncation of primitive data types. \nExtended Description :\nSeveral flaws fall under the category of integer coercion errors. For the most part, these errors in and of themselves result only in availability and data integrity issues. However, in some circumstances, they may result in other, more complicated security related flaws, such as buffer overflow conditions. \nExample: 1\nC\n(bad code)\u00a0\nDataPacket *packet;\nint numHeaders;\nPacketHeader *headers;\nsock=AcceptSocketConnection();\nReadPacket(packet, sock);\nnumHeaders =packet->headers;\nif (numHeaders > 100) {ExitError(\"too many headers!\");\n}\nheaders = malloc(numHeaders * sizeof(PacketHeader);\nParsePacketHeaders(packet, headers);\nExample: 2\nC\n(bad code)\u00a0\nint GetUntrustedInt () {return(0x0000FFFF);\n}\nvoid main (int argc, char **argv) {\nchar path[256];\nchar *input;\nint i;\nshort s;\nunsigned int sz;\ni = GetUntrustedInt();\ns = i;\n/* s is -1 so it passes the safety check - CWE-697 */ \nif (s > 256) {DiePainfully(\"go away!\\n\");\n}\n/* s is sign-extended and saved in sz */\nsz = s;\n/* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */\nprintf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\ninput = GetUserInput(\"Enter pathname:\");\n/* strncpy interprets s as unsigned int, so it's treated as MAX_INT\n(CWE-195), enabling buffer overflow (CWE-119) */ \nstrncpy(path, input, s);\npath[255] = '\\0'; /* don't want CWE-170 */ \nprintf(\"Path is: %s\\n\", path);\n}", "start_char_idx": 0, "end_char_idx": 1535, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b92c6267-7625-49ec-9d2c-e255b0040dd1": {"__data__": {"id_": "b92c6267-7625-49ec-9d2c-e255b0040dd1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c3c798b5-c291-4b60-8bdb-e814cab0fe4e", "node_type": "4", "metadata": {}, "hash": "c82e43dc6832821bd45a19e81a0ffc1b1231cf103485f2187a7442451afe8b71", "class_name": "RelatedNodeInfo"}}, "text": "CWE-482: Comparing instead of Assigning\nDescription :\nThe code uses an operator for comparison when the intention was to perform an assignment. \nExtended Description :\nIn many languages, the compare statement is very close in appearance to the assignment statement; they are often confused. \nExample: 1\nJava\n(bad code)\u00a0\nvoid called(int foo) {foo==1;\nif (foo==1) System.out.println(\"foo\\n\");\n}\nint main() {\ncalled(2);\nreturn 0;\n}\nExample: 2\nC\n(bad code)\u00a0\n#define SIZE 50\nint *tos, *p1, stack[SIZE];\nvoid push(int i) {\np1++;\nif(p1==(tos+SIZE)) {\n// Print stack overflow error message and exit\n}\n*p1 == i;\n}\nint pop(void) {\nif(p1==tos) {\n// Print stack underflow error message and exit\n}\np1--;\nreturn *(p1+1);\n}\nint main(int argc, char *argv[]) {\n// initialize tos and p1 to point to the top of stack\ntos = stack;\np1 = stack;\n// code to add and remove items from stack\n...\nreturn 0;\n}", "start_char_idx": 0, "end_char_idx": 881, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be3fce81-875c-47e7-b9fb-0c9658eacdd3": {"__data__": {"id_": "be3fce81-875c-47e7-b9fb-0c9658eacdd3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2689b1c7-2c21-461e-b7ca-54f1e8659f69", "node_type": "4", "metadata": {}, "hash": "230b4ea86a7f041c9780a1d0990d8f48a59f76a53f23c2bdc128ef8523a73e0a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-134: Use of Externally-Controlled Format String\nDescription :\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source. \nExtended Description :\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems. It should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability. \nExample: 1\nC\n(bad code)\u00a0\n#include <stdio.h>\nvoid printWrapper(char *string) {\nprintf(string);\n}\nint main(int argc, char **argv) {\nchar buf[5012];\nmemcpy(buf, argv[1], 5012);\nprintWrapper(argv[1]);\nreturn (0);\n}\nExample: 2\nC\n(bad code)\u00a0\nint main(int argc, char **argv){char buf[128];\n...\nsnprintf(buf,128,argv[1]);\n}\nExample: 3\nC\n(bad code)\u00a0\nprintf(\"%d %d %1$d %1$d\\n\", 5, 9);\nExemple Bonus \n#include <stdio.h>\nint main (int argc, char **argv)\n{\n\tchar buf [100];\n\tint x = 1 ; \n\tsnprintf(buf,sizeof buf, argv [1]);\n\tbuf[sizeof buf -1 ] = 0;\n\tprintf(\"Buffer size is: (%d) \\n Data input: %s \\n\",strlen(buf),buf);\n\tprintf(\"X equals: %d in hex: %#x\\n Memory address for x: (%p) \\n\",x,x,&x);\n\treturn 0 ;\n}", "start_char_idx": 0, "end_char_idx": 1421, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f0de95fb-8e3e-45ba-9393-04d96bdfdb7a": {"__data__": {"id_": "f0de95fb-8e3e-45ba-9393-04d96bdfdb7a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9625f6bd-9e33-4642-9127-a55ae53f6a08", "node_type": "4", "metadata": {}, "hash": "aab9debd0ed0283a041196dc55cc7e2a1ac7d37522be980435bc8a32fea0fbd3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-799: Improper Control of Interaction Frequency\nDescription :\nThe product does not properly limit the number or frequency of interactions that it has with an actor, such as the number of incoming requests. \nExample: 1\nC\n(bad code)\u00a0\nchar username[USERNAME_SIZE];\nchar password[PASSWORD_SIZE];\nwhile (isValidUser == 0) {\nif (getNextMessage(socket, username, USERNAME_SIZE) > 0) {if (getNextMessage(socket, password, PASSWORD_SIZE) > 0) {isValidUser = AuthenticateUser(username, password);\n}\n}\n}\nreturn(SUCCESS);", "start_char_idx": 0, "end_char_idx": 512, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34fd9d9c-00ee-424d-8f08-c2cf28453ca0": {"__data__": {"id_": "34fd9d9c-00ee-424d-8f08-c2cf28453ca0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9fc92f02-de3e-4b70-8a5d-67aeae3d7304", "node_type": "4", "metadata": {}, "hash": "46297380a8cc455d3324a7fff3169808d37d7601aa62f40c6d3314c0852dc799", "class_name": "RelatedNodeInfo"}}, "text": "CWE-662: Improper Synchronization\nDescription :\nThe product utilizes multiple threads or processes to allow temporary access to a shared resource that can only be exclusive to one process at a time, but it does not properly synchronize these actions, which might cause simultaneous accesses of this resource by multiple threads or processes. \nExtended Description :\nSynchronization refers to a variety of behaviors and mechanisms that allow two or more independently-operating processes or threads to ensure that they operate on shared resources in predictable ways that do not interfere with each other. Some shared resource operations cannot be executed atomically; that is, multiple steps must be guaranteed to execute sequentially, without any interference by other processes. Synchronization mechanisms vary widely, but they may include locking, mutexes, and semaphores. When a multi-step operation on a shared resource cannot be guaranteed to execute independent of interference, then the resulting behavior can be unpredictable. Improper synchronization could lead to data or memory corruption, denial of service, etc. \nExample: 1\nC\n(bad code)\u00a0\nvoid f(pthread_mutex_t *mutex) {\npthread_mutex_lock(mutex);\n/* access shared resource */\npthread_mutex_unlock(mutex);\n}", "start_char_idx": 0, "end_char_idx": 1271, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08ee7821-4ac3-4dfe-aa24-74446cc35f2d": {"__data__": {"id_": "08ee7821-4ac3-4dfe-aa24-74446cc35f2d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "65827295-3c23-4dcb-b5eb-6ead1499cc0b", "node_type": "4", "metadata": {}, "hash": "9b50fca41891068263703623dd5d0902d68600ea7bd00a18375ee7a00e9e413e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-783: Operator Precedence Logic Error\nDescription :\nThe product uses an expression in which operator precedence causes incorrect logic to be used. \nExtended Description :\nWhile often just a bug, operator precedence logic errors can have serious consequences if they are used in security-critical code, such as making an authentication decision. \nExample: 1\nC\n(bad code)\u00a0\n#define FAIL 0\n#define SUCCESS 1\n...\nint validateUser(char *username, char *password) {\nint isUser = FAIL;\n// call method to authenticate username and password\n// if authentication fails then return failure otherwise return success\nif (isUser = AuthenticateUser(username, password) == FAIL) {return isUser;\n}\nelse {isUser = SUCCESS;\n}\nreturn isUser;\n}\nExample: 2\nC\n(good code)\u00a0\n...\nif ((isUser = AuthenticateUser(username, password)) == FAIL) {\n...", "start_char_idx": 0, "end_char_idx": 822, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be1e99b9-d90d-487f-85a7-acd5bb65a9f6": {"__data__": {"id_": "be1e99b9-d90d-487f-85a7-acd5bb65a9f6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f7aa0047-39c8-4916-8675-b6fd9ac65235", "node_type": "4", "metadata": {}, "hash": "26b6e36530110c414633b09e39cf77f78ab6f6a6524e44b6805a13f0bf7d5c63", "class_name": "RelatedNodeInfo"}}, "text": "CWE-299: Improper Check for Certificate Revocation\nDescription :\nThe product does not check or incorrectly checks the revocation status of a certificate, which may cause it to use a certificate that has been compromised. \nExample: 1\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer_certificate(ssl)) {\n// got a certificate, do secret things", "start_char_idx": 0, "end_char_idx": 329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7b340ae2-180d-4cbd-994d-5cdb170541b8": {"__data__": {"id_": "7b340ae2-180d-4cbd-994d-5cdb170541b8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62a7717e-0078-4fd9-a9a9-eb8bf84d8a73", "node_type": "4", "metadata": {}, "hash": "9aa97397911103d451ce6c427f9e57fbd1ccf92f0e32d7b4f9a3e7e72d2a2558", "class_name": "RelatedNodeInfo"}}, "text": "CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')\nDescription :\nThe product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop. \nExtended Description :\nIf the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. \nExample: 1\nC\n(bad code)\u00a0\nint processMessagesFromServer(char *hostaddr, int port) {\n...\nint servsock;\nint connected;\nstruct sockaddr_in servaddr;\n// create socket to connect to server\nservsock = socket( AF_INET, SOCK_STREAM, 0);\nmemset( &servaddr, 0, sizeof(servaddr));\nservaddr.sin_family = AF_INET;\nservaddr.sin_port = htons(port);\nservaddr.sin_addr.s_addr = inet_addr(hostaddr);\ndo {\n// establish connection to server\nconnected = connect(servsock, (struct sockaddr *)&servaddr, sizeof(servaddr));\n// if connected then read and process messages from server\nif (connected > -1) {\n// read and process messages\n...\n}\n// keep trying to establish connection to the server\n} while (connected < 0);\n// close socket and return success or failure\n...\n}\nExample: 2\nC\n(good code)\u00a0\nint processMessagesFromServer(char *hostaddr, int port) {\n...\n// initialize number of attempts counter\nint count = 0;\ndo {\n// establish connection to server\nconnected = connect(servsock, (struct sockaddr *)&servaddr, sizeof(servaddr));\n// increment counter\ncount++;\n// if connected then read and process messages from server\nif (connected > -1) {\n// read and process messages\n...\n}\n// keep trying to establish connection to the server\n// up to a maximum number of attempts\n} while (connected < 0 && count < MAX_ATTEMPTS);\n// close socket and return success or failure\n...\n}", "start_char_idx": 0, "end_char_idx": 1696, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d487ea4d-4a1b-4b20-9b7d-dba51e362ff3": {"__data__": {"id_": "d487ea4d-4a1b-4b20-9b7d-dba51e362ff3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "651879fe-13df-40ee-9ed5-164166a9c755", "node_type": "4", "metadata": {}, "hash": "01e76b4a52b8454e69bc6568f0f45c7fc04e44e5ff2a5c30cd0d7a43f735ada0", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1177: Use of Prohibited Code\nDescription :\nThe product uses a function, library, or third party component that has been explicitly prohibited, whether by the developer or the customer. \nVoici une liste non exhaustive de fonctions en C qui sont souvent consid\u00e9r\u00e9es comme dangereuses (\"bad functions\") en raison de leur potentiel \u00e0 introduire des vuln\u00e9rabilit\u00e9s de s\u00e9curit\u00e9, notamment des d\u00e9bordements de tampon, lorsqu'elles sont mal utilis\u00e9es. Cette liste comprend principalement des fonctions de manipulation de cha\u00eenes et de m\u00e9moire qui ne v\u00e9rifient pas la taille du tampon de destination :\nstrcpy() - Copie une cha\u00eene dans une autre sans v\u00e9rifier la taille du tampon de destination.\nstrcat() - Concat\u00e8ne deux cha\u00eenes sans v\u00e9rifier la taille du tampon de destination.\nsprintf() - \u00c9crit dans une cha\u00eene format\u00e9e sans v\u00e9rifier la taille du tampon de destination.\ngets() - Lit une ligne depuis l'entr\u00e9e standard (stdin) sans v\u00e9rifier la taille du tampon de destination; cette fonction a \u00e9t\u00e9 supprim\u00e9e dans la norme C11 en raison de son dangerosit\u00e9.\nscanf() (et ses variantes comme fscanf(), sscanf(), etc.) - Peuvent causer des d\u00e9bordements de tampon si les sp\u00e9cificateurs de format ne limitent pas la longueur de l'entr\u00e9e pour les cha\u00eenes.\nDes alternatives plus s\u00fbres existent pour chacune de ces fonctions, souvent avec des suffixes tels que \"n\", qui permettent de sp\u00e9cifier la taille du tampon et ainsi \u00e9viter les d\u00e9bordements. Par exemple :\nstrncpy() au lieu de strcpy()\nstrncat() au lieu de strcat()\nsnprintf() au lieu de sprintf()\nfgets() au lieu de gets()\nscanf() avec des limites de champ dans les sp\u00e9cificateurs de format (ex. \"%255s\") pour limiter la taille de la cha\u00eene lue.\nExample: 1\nC\n(bad code)\u00a0\nchar buf[24];\nprintf(\"Please enter your name and press <Enter>\\n\");\ngets(buf);\n...\n}\nExample: 2\nC\n(bad code)\u00a0\nvoid manipulate_string(char * string){char buf[24];\nstrcpy(buf, string);\n...\n}", "start_char_idx": 0, "end_char_idx": 1902, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f84a4ac0-c222-4dab-a400-9e7149760cbf": {"__data__": {"id_": "f84a4ac0-c222-4dab-a400-9e7149760cbf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7c7f2b04-5d9a-46be-9608-7ba0aaa1e12c", "node_type": "4", "metadata": {}, "hash": "9443513a3ee56ddc7d7ad228f3a74ec0699a4892585b6da907758573fa954c5d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-690: Unchecked Return Value to NULL Pointer Dereference\nDescription :\nThe product does not check for an error after calling a function that can return with a NULL pointer if the function fails, which leads to a resultant NULL pointer dereference. \nExtended Description :\nWhile unchecked return value weaknesses are not limited to returns of NULL pointers (see the examples in CWE-252), functions often return NULL to indicate an error status. When this error condition is not checked, a NULL pointer dereference can occur. \nExample: 1\nJava\n(bad code)\u00a0\nString username = getUserName();\nif (username.equals(ADMIN_USER)) {...\n}\nExample: 2\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}", "start_char_idx": 0, "end_char_idx": 1043, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b3cdaf5-d7e9-43db-88d2-e22115be275e": {"__data__": {"id_": "0b3cdaf5-d7e9-43db-88d2-e22115be275e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5d33be96-697b-43fb-888a-6885fa98dd22", "node_type": "4", "metadata": {}, "hash": "b8aa8be1641c8ce50fdf278d7187c40b3b75f503a839982e571956a6b2837eac", "class_name": "RelatedNodeInfo"}}, "text": "CWE-834: Excessive Iteration\nDescription :\nThe product performs an iteration or loop without sufficiently limiting the number of times that the loop is executed. \nExample: 1\nC\n(bad code)\u00a0\nvoid do_something_recursive (int flg)\n\t       {\n\t\t ... // Do some real work here, but the value of flg is unmodified\n\t\t if (flg) { do_something_recursive (flg); }    // flg is never modified so it is always TRUE - this call will continue until the stack explodes\n\t       }\n\t       int flag = 1; // Set to TRUE\n\t       do_something_recursive (flag);\nExample: 2\nC\n(good code)\u00a0\nvoid do_something_recursive (int flg)\n\t       {\n\t\t ... // Do some real work here\n\t\t // Modify value of flg on done condition\n\t\t if (flg) { do_something_recursive (flg); }    // returns when flg changes to 0\n\t       }\n\t       int flag = 1; // Set to TRUE\n\t       do_something_recursive (flag);", "start_char_idx": 0, "end_char_idx": 855, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "53abd67b-b1a8-4f7a-ac9b-5d17d9bdb393": {"__data__": {"id_": "53abd67b-b1a8-4f7a-ac9b-5d17d9bdb393", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9fc140ae-0d86-44a1-85c3-e8f57bffbc5f", "node_type": "4", "metadata": {}, "hash": "603235e31872d8b4ede1b264158e01032ec73fb14ea3d6f394a287a5ca86c4a7", "class_name": "RelatedNodeInfo"}}, "text": "CWE-680: Integer Overflow to Buffer Overflow\nDescription :\nThe product performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow. \nExample: 1\nC\n(bad code)\u00a0\nimg_t table_ptr; /*struct containing img data, 10kB each*/\nint num_imgs;\n...\nnum_imgs = get_num_imgs();\ntable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n...", "start_char_idx": 0, "end_char_idx": 440, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f129b99-55f0-4f14-8eea-60befaee57ce": {"__data__": {"id_": "2f129b99-55f0-4f14-8eea-60befaee57ce", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "07213341-1d6b-4965-993d-19d398da6154", "node_type": "4", "metadata": {}, "hash": "7f3f6cbfe417bb2de9275cc9c52aaffd20dac6d6a8ae4b9d2ff6f039fd73088e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-335: Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\nDescription :\nThe product uses a Pseudo-Random Number Generator (PRNG) but does not correctly manage seeds. \nExtended Description :\nPRNGs are deterministic and, while their output appears random, they cannot actually create entropy. They rely on cryptographically secure and unique seeds for entropy so proper seeding is critical to the secure operation of the PRNG. Management of seeds could be broken down into two main areas: (1) protecting seeds as cryptographic material (such as a cryptographic key); (2) whenever possible, using a uniquely generated seed from a cryptographically secure source PRNGs require a seed as input to generate a stream of numbers that are functionally indistinguishable from random numbers. While the output is, in many cases, sufficient for cryptographic uses, the output of any PRNG is directly determined by the seed provided as input. If the seed can be ascertained by a third party, the entire output of the PRNG can be made known to them. As such, the seed should be kept secret and should ideally not be able to be guessed. For example, the current time may be a poor seed. Knowing the approximate time the PRNG was seeded greatly reduces the possible key space. Seeds do not necessarily need to be unique, but reusing seeds may open up attacks if the seed is discovered. \nExample: 3\nC\n(bad code)\u00a0\nsrand(time());\nint randNum = rand();", "start_char_idx": 0, "end_char_idx": 1449, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3b3a77f2-aaf5-409e-a207-6342b8b7340d": {"__data__": {"id_": "3b3a77f2-aaf5-409e-a207-6342b8b7340d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af051c0a-ad14-4dc3-aead-8544b3fa076d", "node_type": "4", "metadata": {}, "hash": "f8ba26f3446d3b77f200eda80d391e4cc2d8de9e46d84e67b6a384afdb43e916", "class_name": "RelatedNodeInfo"}}, "text": "CWE-806: Buffer Access Using Size of Source Buffer\nDescription :\nThe product uses the size of a source buffer when reading from or writing to a destination buffer, which may cause it to access memory that is outside of the bounds of the buffer. \nExtended Description :\nWhen the size of the destination is smaller than the size of the source, a buffer overflow could occur. \nExample: 1\nC\n(bad code)\u00a0\n...\nchar source[21] = \"the character string\";\nchar dest[12];\nstrncpy(dest, source, sizeof(source)-1);\n...\nExample: 2\nC\n(good code)\u00a0\n...\nchar source[21] = \"the character string\";\nchar dest[12];\nstrncpy(dest, source, sizeof(dest)-1);\n...", "start_char_idx": 0, "end_char_idx": 634, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6d43193-d89f-41ef-aece-3731dcec1e28": {"__data__": {"id_": "b6d43193-d89f-41ef-aece-3731dcec1e28", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d2209471-ff08-4980-8a7b-1cb17462b2de", "node_type": "4", "metadata": {}, "hash": "ac6901dd673f40804c1ac84fdc24c066609ccd25191b82ec0fd2698f7f990272", "class_name": "RelatedNodeInfo"}}, "text": "CWE-271: Privilege Dropping / Lowering Errors\nDescription :\nThe product does not drop privileges before passing control of a resource to an actor that does not have those privileges. \nExample: 1\nC\n(bad code)\u00a0\nchroot(APP_HOME);\nchdir(\"/\");\nFILE* data = fopen(argv[1], \"r+\");\n...", "start_char_idx": 0, "end_char_idx": 277, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b4f2403e-350b-4e04-9a5e-76d12ee9df55": {"__data__": {"id_": "b4f2403e-350b-4e04-9a5e-76d12ee9df55", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5bee927f-748e-45d2-9212-186165e967b6", "node_type": "4", "metadata": {}, "hash": "ab60986f675291ca139a5e045356b5d65900ce156666bf78d64fc2007b52e71b", "class_name": "RelatedNodeInfo"}}, "text": "CWE-333: Improper Handling of Insufficient Entropy in TRNG\nDescription :\nTrue random number generators (TRNG) generally have a limited source of entropy and therefore can fail or block. \nExample: 1\nC\n(bad code)\u00a0\nwhile (1){\nif (haveNewConnection()){if (hwRandom()){int sessionID = hwRandom();\ncreateNewConnection(sessionID);\n} } }", "start_char_idx": 0, "end_char_idx": 329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0402c027-5614-4ac7-87f3-62750199200a": {"__data__": {"id_": "0402c027-5614-4ac7-87f3-62750199200a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "31d78f62-b563-4fc8-8543-928e02a1468e", "node_type": "4", "metadata": {}, "hash": "bd66e2e2afc0b7287ec862dc86018fbac9d728bb36c79d7ce9f18522f08a8929", "class_name": "RelatedNodeInfo"}}, "text": "CWE-301: Reflection Attack in an Authentication Protocol\nDescription :\nSimple authentication protocols are subject to reflection attacks if a malicious user can use the target machine to impersonate a trusted user. \nExample: 1\nC\n(bad code)\u00a0\nunsigned char *simple_digest(char *alg,char *buf,unsigned int len, int *olen) {const EVP_MD *m;\nEVP_MD_CTX ctx;\nunsigned char *ret;\nOpenSSL_add_all_digests();\nif (!(m = EVP_get_digestbyname(alg))) return NULL;\nif (!(ret = (unsigned char*)malloc(EVP_MAX_MD_SIZE))) return NULL;\nEVP_DigestInit(&ctx, m);\nEVP_DigestUpdate(&ctx,buf,len);\nEVP_DigestFinal(&ctx,ret,olen);\nreturn ret;\n}\nunsigned char *generate_password_and_cmd(char *password_and_cmd) {simple_digest(\"sha1\",password,strlen(password_and_cmd)\n...\n);\n}", "start_char_idx": 0, "end_char_idx": 750, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5365dc19-037d-4cc7-9d07-b0645f84e8ea": {"__data__": {"id_": "5365dc19-037d-4cc7-9d07-b0645f84e8ea", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ee46d1c2-e402-4980-8f84-4c4faf4d8cde", "node_type": "4", "metadata": {}, "hash": "e0a3483dcc9ff9625637bd9690f1f21b23be530909493436390ca4cfea7538db", "class_name": "RelatedNodeInfo"}}, "text": "CWE-481: Assigning instead of Comparing\nDescription :\nThe code uses an operator for assignment when the intention was to perform a comparison. \nExtended Description :\nIn many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate. \nExample: 1\nC\n(bad code)\u00a0\nint isValid(int value) {if (value=100) {printf(\"Value is valid\\n\");\nreturn(1);\n}\nprintf(\"Value is not valid\\n\");\nreturn(0);\n}\nExample: 2\nC#\n(bad code)\u00a0\nbool isValid(int value) {if (value=100) {Console.WriteLine(\"Value is valid.\");\nreturn true;\n}\nConsole.WriteLine(\"Value is not valid.\");\nreturn false;\n}\nExample: 3\nC\n(bad code)\u00a0\nvoid processString (char *str) {\nint i;\nfor(i=0; i<strlen(str); i++) {if (isalnum(str[i])){processChar(str[i]);\n}\nelse if (str[i] = ':') {movingToNewInput();}\n}\n}\n}\nExample: 4\nJava\n(bad code)\u00a0\npublic void checkValid(boolean isValid) {if (isValid = true) {System.out.println(\"Performing processing\");\ndoSomethingImportant();\n}\nelse {System.out.println(\"Not Valid, do not perform processing\");\nreturn;\n}\n}", "start_char_idx": 0, "end_char_idx": 1279, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60ab5a64-c59a-4f02-b2cf-86dd888e4e85": {"__data__": {"id_": "60ab5a64-c59a-4f02-b2cf-86dd888e4e85", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d7e52f96-d83d-49a1-95cc-1b70fc24d4c5", "node_type": "4", "metadata": {}, "hash": "c14d3967134330b53335718a3def46d988560e5b9a89fa44245a135e5db14dcb", "class_name": "RelatedNodeInfo"}}, "text": "CWE-266: Incorrect Privilege Assignment\nDescription :\nA product incorrectly assigns a privilege to a particular actor, creating an unintended sphere of control for that actor. \nExample: 1\nC\n(bad code)\u00a0\nseteuid(0);\n/* do some stuff */\nseteuid(getuid());\nExample: 2\nJava\n(bad code)\u00a0\nAccessController.doPrivileged(new PrivilegedAction() {\npublic Object run() {\n// privileged code goes here, for example:\nSystem.loadLibrary(\"awt\");\nreturn null;\n// nothing to return\n}\nExample: 3\nJava\n(bad code)\u00a0\nIntent intent = new Intent();\nintent.setAction(\"com.example.BackupUserData\");\nintent.setData(file_uri);\nintent.addFlags(FLAG_GRANT_READ_URI_PERMISSION);\nsendBroadcast(intent);", "start_char_idx": 0, "end_char_idx": 667, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4143cab1-d718-4368-9ea0-23bc7374f70f": {"__data__": {"id_": "4143cab1-d718-4368-9ea0-23bc7374f70f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1389bb08-82b4-4a6f-b5d1-1fc4d7d19df9", "node_type": "4", "metadata": {}, "hash": "8a54f8e3c60dcd79cef8d35835eeca2cb3a983232b331a7fa15a705d2ae73d8f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-908: Use of Uninitialized Resource\nDescription :\nThe product uses or accesses a resource that has not been initialized. \nExample: 1\nJava\n(bad code)\u00a0\nprivate boolean initialized = true;\npublic void someMethod() {\nif (!initialized) {\n// perform initialization tasks\n...\ninitialized = true;\n}\nExample: 2\nPerl\n(bad code)\u00a0\n$username = GetCurrentUser();\n$state = GetStateData($username);\nif (defined($state)) {$uid = ExtractUserID($state);\n}\n# do stuff\nif ($uid == 0) {DoAdminThings();\n}\nExample: 3\nC\n(bad code)\u00a0\nchar str[20];\nstrcat(str, \"hello world\");\nprintf(\"%s\", str);\nExample: 4\nC\n(bad code)\u00a0\nchar *test_string;\n                if (i != err_val)\n                {\ntest_string = \"Hello World!\";\n                }\n                printf(\"%s\", test_string);", "start_char_idx": 0, "end_char_idx": 758, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d0d82868-6a88-4ff8-8bf4-522a215a1945": {"__data__": {"id_": "d0d82868-6a88-4ff8-8bf4-522a215a1945", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2330ae9a-ea50-4685-b922-b7253a2fee4b", "node_type": "4", "metadata": {}, "hash": "ef80780fa5bae542cd5333393d50582ad1bb4d2e7fd973c06f92ce6359134ba0", "class_name": "RelatedNodeInfo"}}, "text": "CWE-599: Missing Validation of OpenSSL Certificate\nDescription :\nThe product uses OpenSSL and trusts or uses a certificate without using the SSL_get_verify_result() function to ensure that the certificate satisfies all necessary security requirements. \nExample: 1\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer_certificate(ssl)) {\n// got certificate, host can be trusted\n//foo=SSL_get_verify_result(ssl);\n//if (X509_V_OK==foo) ...\n}", "start_char_idx": 0, "end_char_idx": 423, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87e17769-74d4-4655-9d53-195c0a05d1ef": {"__data__": {"id_": "87e17769-74d4-4655-9d53-195c0a05d1ef", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c25a1a3d-8fe1-46a4-a7ac-c4f1be69b49e", "node_type": "4", "metadata": {}, "hash": "083b02e62ec637461df61b48704724fb5e92da1c383db8b6f5d7f0e2059bb574", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1420: Exposure of Sensitive Information during Transient Execution\nDescription :\nA processor event or prediction may allow incorrect operations (or correct operations with incorrect data) to execute transiently, potentially exposing data over a covert channel. \nExample: 1\nC\n(bad code)\u00a0\nif (x < array1_size)\ny = array2[array1[x] * 4096];", "start_char_idx": 0, "end_char_idx": 341, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31966f3b-428d-4781-bdc4-8c7a16d84c90": {"__data__": {"id_": "31966f3b-428d-4781-bdc4-8c7a16d84c90", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9b6bf889-c931-4066-969a-7aa49b8f4b75", "node_type": "4", "metadata": {}, "hash": "96cbc09dd5223ea76b7bedbac99d4fcd7f5e983ec5164d7e0c4f8ce4c89c4872", "class_name": "RelatedNodeInfo"}}, "text": "CWE-483: Incorrect Block Delimitation\nDescription :\nThe code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error. \nExtended Description :\nIn some languages, braces (or other delimiters) are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. In some cases, the logic error can have security implications. \nExample: 1\nC\n(bad code)\u00a0\nif (condition==true)Do_X();\nDo_Y();\nExample: 2\nC\n(bad code)\u00a0\nif (condition==true) Do_X();Do_Y();", "start_char_idx": 0, "end_char_idx": 584, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0f0d05cb-c799-410b-8ede-9538d4347cae": {"__data__": {"id_": "0f0d05cb-c799-410b-8ede-9538d4347cae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560e756f-52fd-46a1-a16a-184f0cad5e93", "node_type": "4", "metadata": {}, "hash": "32ef7550e72b0193f50ca21147c0fa29897fcadfe649207ca36e98f91956b766", "class_name": "RelatedNodeInfo"}}, "text": "CWE-782: Exposed IOCTL with Insufficient Access Control\nDescription\nThe product implements an IOCTL with functionality that should be restricted, but it does not properly enforce access control for the IOCTL.\n+ Extended Description\nWhen an IOCTL contains privileged functionality and is exposed unnecessarily, attackers may be able to access this functionality by invoking the IOCTL. Even if the functionality is benign, if the programmer has assumed that the IOCTL would only be accessed by a trusted process, there may be little or no validation of the incoming data, exposing weaknesses that would never be reachable if the attacker cannot call the IOCTL directly.\nThe implementations of IOCTLs will differ between operating system types and versions, so the methods of attack and prevention may vary widely.\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <unistd.h>\nint main(int argc, char *argv[argc])\n{\n        int fd = open(\"/dev/my_driver\", O_WRONLY, O_NONBLOCK);\n        if (fd == -1){\n                printf(\"Could not open my_driver.\\n\");\n                exit(1);\n        }\n        if (ioctl(fd, 0x42) == -1){\n                printf(\"ioctl failed.\\n\");\n        }\n        if (close(fd) == -1){\n                printf(\"Could not properly close my_driver.\\n\");\n                exit(1);\n        }\n        return 0;\n}", "start_char_idx": 0, "end_char_idx": 1411, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b660278c-71d7-4c5b-81eb-2e4dcbf35b47": {"__data__": {"id_": "b660278c-71d7-4c5b-81eb-2e4dcbf35b47", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "583cc2a1-4522-42e1-97a2-9eb43af009c7", "node_type": "4", "metadata": {}, "hash": "082c38a71296568ba4b8202e4b6f2e621e361d1245e47646c3540d7a94cc77d6", "class_name": "RelatedNodeInfo"}}, "text": "CWE-570: Expression is Always False\nDescription :\nThe product contains an expression that will always evaluate to false. \nExample: 1\nJava\n(bad code)\u00a0\npublic void updateUserAccountOrder(String productNumber, String accountNumber) {\nboolean isValidProduct = false;\nboolean isValidAccount = false;\nif (validProductNumber(productNumber)) {isValidProduct = true;\nupdateInventory(productNumber);\n}\nelse {return;\n}\nif (validAccountNumber(accountNumber)) {isValidProduct = true;\nupdateAccount(accountNumber, productNumber);\n}\nif (isValidProduct && isValidAccount) {updateAccountOrder(accountNumber, productNumber);\n}\n}\nExample: 2\nC\n(bad code)\u00a0\n#define BIT_READ 0x0001 // 00000001\n#define BIT_WRITE 0x0010 // 00010000\nunsigned int mask = BIT_READ & BIT_WRITE; /* intended to use \"|\" */\n// using \"&\", mask = 00000000\n// using \"|\", mask = 00010001\n// determine if user has read and write access\nint hasReadWriteAccess(unsigned int userMask) {\n// if the userMask has read and write bits set\n// then return 1 (true)\nif (userMask & mask) {return 1;\n}\n// otherwise return 0 (false)\nreturn 0;\n}", "start_char_idx": 0, "end_char_idx": 1078, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "16afdd85-7778-4377-b2ed-6c953920d182": {"__data__": {"id_": "16afdd85-7778-4377-b2ed-6c953920d182", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "83e4072d-69c9-45b7-aa84-df03a189dbbd", "node_type": "4", "metadata": {}, "hash": "7ce7a160bdbbfc524ae2554a41994befc3c0c8f6e64542d5d3b074db6209cd8d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-269: Improper Privilege Management\nDescription :\nThe product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. \nExample: 1\nPython\n(bad code)\u00a0\ndef makeNewUserDir(username):\nif invalidUsername(username):\n#avoid CWE-22 and CWE-78 \nprint('Usernames cannot contain invalid characters')\nreturn False\ntry:raisePrivileges()\nos.mkdir('/home/' + username)\nlowerPrivileges()\nexcept OSError:print('Unable to create new user directory for user:' + username)\nreturn False\nreturn True\nExample: 2\nC\n(bad code)\u00a0\nseteuid(0);\n/* do some stuff */\nseteuid(getuid());\nExample: 3\nJava\n(bad code)\u00a0\nAccessController.doPrivileged(new PrivilegedAction() {\npublic Object run() {\n// privileged code goes here, for example:\nSystem.loadLibrary(\"awt\");\nreturn null;\n// nothing to return\n}\nExample: 4\nJava\n(bad code)\u00a0\npublic enum Roles {ADMIN,USER,GUEST\n}\npublic void printDebugInfo(User requestingUser){\nif(isAuthenticated(requestingUser)){\nswitch(requestingUser.role){\ncase GUEST:System.out.println(\"You are not authorized to perform this command\");\nbreak;\ndefault:System.out.println(currentDebugState());\nbreak;\n}\n}\nelse{System.out.println(\"You must be logged in to perform this command\");\n}\n}\nExample: 5\nJava\n(bad code)\u00a0\npublic enum Roles {ADMIN,OPERATOR,USER,GUEST\n}\npublic void resetPassword(User requestingUser, User user, String password ){\nif(isAuthenticated(requestingUser)){\nswitch(requestingUser.role){\ncase GUEST:System.out.println(\"You are not authorized to perform this command\");\nbreak;\ncase USER:System.out.println(\"You are not authorized to perform this command\");\nbreak;\ndefault:setPassword(user,password);\nbreak;\n}\n}\nelse{System.out.println(\"You must be logged in to perform this command\");\n}\n}", "start_char_idx": 0, "end_char_idx": 1767, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3641de24-697d-4d2d-8e90-13c5471a53f8": {"__data__": {"id_": "3641de24-697d-4d2d-8e90-13c5471a53f8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5fd8b6cb-fdd6-4ee9-83d8-378cc053b5cf", "node_type": "4", "metadata": {}, "hash": "bbe2fd19cf4b6c6dc350400069554be38645807425d7d0195a63194262b9bf6a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-194: Unexpected Sign Extension\nDescription :\nThe product performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type. When the original number is negative, this can produce unexpected values that lead to resultant weaknesses. \nExample: 1\nC\n(bad code)\u00a0\nint GetUntrustedInt () {return(0x0000FFFF);\n}\nvoid main (int argc, char **argv) {\nchar path[256];\nchar *input;\nint i;\nshort s;\nunsigned int sz;\ni = GetUntrustedInt();\ns = i;\n/* s is -1 so it passes the safety check - CWE-697 */ \nif (s > 256) {DiePainfully(\"go away!\\n\");\n}\n/* s is sign-extended and saved in sz */\nsz = s;\n/* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */\nprintf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\ninput = GetUserInput(\"Enter pathname:\");\n/* strncpy interprets s as unsigned int, so it's treated as MAX_INT\n(CWE-195), enabling buffer overflow (CWE-119) */ \nstrncpy(path, input, s);\npath[255] = '\\0'; /* don't want CWE-170 */ \nprintf(\"Path is: %s\\n\", path);\n}", "start_char_idx": 0, "end_char_idx": 1002, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4e1917ad-3b00-4d14-8b35-8a27ed49a9bb": {"__data__": {"id_": "4e1917ad-3b00-4d14-8b35-8a27ed49a9bb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2df91a24-28ac-4e38-ac89-756004ac32da", "node_type": "4", "metadata": {}, "hash": "cc536034e057b590ff1f6a731e6a0c70b26287122db4fe19bcce4c66f117efab", "class_name": "RelatedNodeInfo"}}, "text": "CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\n+ Description\nA Pseudo-Random Number Generator (PRNG) is initialized from a predictable seed, such as the process ID or system time.\n+ Demonstrative Examples\nExample 1\nBoth of these examples use a statistical PRNG seeded with the current value of the system clock to generate a random number:\n(bad code)\nExample Language: Java \nRandom random = new Random(System.currentTimeMillis());\nint accountID = random.nextInt();\n(bad code)\nExample Language: C \n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\nint main() {\n    int a, b;\n    srand((unsigned)time(NULL)); // CWE-337: Predictable Seed in PRNG\n    a = rand(); // CWE-332: Insufficient Entropy in PRNG\n    b = rand() % 100; // Exemple d'utilisation du PRNG pour une valeur sp\u00e9cifique\n    printf(\"%d\\n\", a);\n    printf(\"%d\\n\", b);\n    return 0;\n}", "start_char_idx": 0, "end_char_idx": 871, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3367177-ca46-4712-a496-118b456da6a1": {"__data__": {"id_": "b3367177-ca46-4712-a496-118b456da6a1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "647a6fd9-b454-4162-b4c0-43fcb7aebd81", "node_type": "4", "metadata": {}, "hash": "2d5e4aa634ff1bb41186502961e243e01b71f9e3b73c235ac313ae64b34c19aa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6bb18606-62f9-42f2-b9fe-988e7331ccb9", "node_type": "1", "metadata": {}, "hash": "c6c5955e729d674d941aab971df0617a8762afedb0802b8e2dffb26bb0f19a9d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\nDescription :\nThe product performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \nExtended Description :\nCertain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data. As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash. \nExample: 1\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}\nExample: 2\nC\n(bad code)\u00a0\nchar * copy_input(char *user_supplied_string){\nint i, dst_index;\nchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\nif ( MAX_SIZE <= strlen(user_supplied_string) ){die(\"user string too long, die evil hacker!\");\n}\ndst_index = 0;\nfor ( i = 0; i < strlen(user_supplied_string); i++ ){\nif( '&' == user_supplied_string[i] ){dst_buf[dst_index++] = '&';\ndst_buf[dst_index++] = 'a';\ndst_buf[dst_index++] = 'm';\ndst_buf[dst_index++] = 'p';\ndst_buf[dst_index++] = ';';\n}\nelse if ('<' == user_supplied_string[i] ){\n/* encode to &lt; */\n}\nelse dst_buf[dst_index++] = user_supplied_string[i];\n}\nreturn dst_buf;\n}\nExample Bonus : \n#define MAX_SIZE 16\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n/*This example applies an encoding procedure to an input string and stores it into a buffer.*/\nint main(int argc, char *argv[]){\n    int i, j=0;\n    char a[MAX_SIZE];\n    /*checks if the user provided an input*/\n    if (argc<2) return 0;\n    /*checks if the input provided by the user fits in the array a*/\n    if (MAX_SIZE <= strlen(argv[1])){\n       printf(\"user string too long\");\n       return 0;\n    }\n    /*performs the encoding*/\n    for (i=0; i < strlen(argv[1]); i++){\n        if( '&' == argv[1][i] ){\n            a[j++] = '&';\n            a[j++] = 'a';\n            a[j++] = 'm';\n            a[j++] = 'p';\n            a[j++] = ';';\n        }\n        else a[j++]=argv[1][i]; \n     }\n     printf(\"The encoded string is %s \\n\",a);\n     return 0;\n}\n/*The programmer attempts to encode the ampersand character in the user-controlled string,\n however the length of the string is validated before the encoding procedure is applied. \nFurthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4,\nwhile the encoding of the ampersand expands by 5. As a result, \nwhen the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands.*\nExemple Bonus\n#include <stdio.h>\n/*The following example asks a user for an offset into an array to select an item.", "start_char_idx": 0, "end_char_idx": 3308, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6bb18606-62f9-42f2-b9fe-988e7331ccb9": {"__data__": {"id_": "6bb18606-62f9-42f2-b9fe-988e7331ccb9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "647a6fd9-b454-4162-b4c0-43fcb7aebd81", "node_type": "4", "metadata": {}, "hash": "2d5e4aa634ff1bb41186502961e243e01b71f9e3b73c235ac313ae64b34c19aa", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b3367177-ca46-4712-a496-118b456da6a1", "node_type": "1", "metadata": {}, "hash": "316866c9c40d55f99fb39179b6a7de2171ff07546d6d505689f32bbafb7a24d6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "61d97130-d50f-4346-92f8-177bb4c2572f", "node_type": "1", "metadata": {}, "hash": "103700144585a5caf431ba23d58bf5329eecd1171123eb03a9fd9bb93a079613", "class_name": "RelatedNodeInfo"}}, "text": "Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4,\nwhile the encoding of the ampersand expands by 5. As a result, \nwhen the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands.*\nExemple Bonus\n#include <stdio.h>\n/*The following example asks a user for an offset into an array to select an item.*/\nint GetUntrustedOffset(){\n    int x=-1;\n    return x;\n}\nint main (int argc, char **argv) {\n    char *items[] = {\"boat\", \"car\", \"truck\", \"train\"};\n    int index = GetUntrustedOffset();\n    printf(\"You selected %s\\n\", items[index-1]);\n}\nExemple Bonus \nExemple Bonus\n/* An example of an ERROR for some 64-bit architectures,\nif \"unsigned int\" is 32 bits and \"size_t\" is 64 bits: */\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdlib.h>\nvoid *mymalloc(unsigned int size) { return malloc(size); }\nint main()\n{\n    char *buf;\n    size_t len;\n    read(0, &len, sizeof(len));\n    /* we forgot to check the maximum length */\n    /* 64-bit size_t gets truncated to 32-bit unsigned int */\n    buf = mymalloc(len);\n    read(0, buf, len);\n    return 0;\n}\nExample: 3\nC\n(bad code)\u00a0\nint main (int argc, char **argv) {char *items[] = {\"boat\", \"car\", \"truck\", \"train\"};\nint index = GetUntrustedOffset();\nprintf(\"You selected %s\\n\", items[index-1]);\n}\nExample: 4\nC\n(bad code)\u00a0\nint getValueFromArray(int *array, int len, int index) {\nint value;\n// check that the array index is less than the maximum\n// length of the array\nif (index < len) {\n// get the value at the specified index of the array\nvalue = array[index];\n}\n// if array index is invalid then output error message\n// and return value indicating error\nelse {printf(\"Value is: %d\\n\", array[index]);\nvalue = -1;\n}\nreturn value;\n}\nExample: 5\nC\n(good code)\u00a0\n...\n// check that the array index is within the correct\n// range of values for the array\nif (index >= 0 && index < len) {\n...\nExample Bonus\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n// To use Frama-C's \"Frama_C_interval\" to generate a nondeterministic value\n#include \"__fc_builtin.h\"\nstatic void validate_addr_form(char *v) {\n  // naive, simplistic validation\n  if (strspn(v, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-0123456789.\")", "start_char_idx": 2869, "end_char_idx": 5202, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "61d97130-d50f-4346-92f8-177bb4c2572f": {"__data__": {"id_": "61d97130-d50f-4346-92f8-177bb4c2572f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "647a6fd9-b454-4162-b4c0-43fcb7aebd81", "node_type": "4", "metadata": {}, "hash": "2d5e4aa634ff1bb41186502961e243e01b71f9e3b73c235ac313ae64b34c19aa", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6bb18606-62f9-42f2-b9fe-988e7331ccb9", "node_type": "1", "metadata": {}, "hash": "c6c5955e729d674d941aab971df0617a8762afedb0802b8e2dffb26bb0f19a9d", "class_name": "RelatedNodeInfo"}}, "text": "< strlen(v)) {\n    fprintf(stderr, \"hostname contains invalid characters\");\n    exit(1);\n  }\n}\nstatic int my_strcmp(const char *s1, const char *s2)\n{\n  size_t i;\n  for (i = 0; s1[i] == s2[i]; i++) {\n    if (s1[i] == 0) return 0;\n  }\n  return (((unsigned char *)s1)[i] - ((unsigned char *)s2)[i]);\n}\n// simplified version\nstatic in_addr_t my_inet_addr(const char *cp) {\n  if (my_strcmp(cp, \"127.0.0.1\") == 0) {\n    return 0;\n  } else {\n    return Frama_C_nondet(1,UINT_MAX);\n  }\n}\n// simplified version\nstatic struct hostent *my_gethostbyaddr(const void *addr,\n                                     socklen_t len, int type) {\n  static struct hostent res;\n  // actual lookup code omitted\n  if ((in_addr_t*)addr == 0) {\n    res.h_name = \"www.example.com\";\n  } else {\n    res.h_name = \"hypermegagigaterasupercalifragilisticexpialidocious2.example.com\";\n  }\n  return &res;\n}\nvoid host_lookup(char *user_supplied_addr){\n  struct hostent *hp;\n  in_addr_t *addr;\n  char hostname[64];\n  /* routine that ensures user_supplied_addr is in the right format for conversion */\n  validate_addr_form(user_supplied_addr);\n  addr = my_inet_addr(user_supplied_addr);\n  hp = my_gethostbyaddr(addr, sizeof(struct in_addr), AF_INET);\n  strcpy(hostname, hp->h_name);\n}\nint main() {\n  char *very_large_but_valid_hostname = \"127.0.0.1\";\n  host_lookup(very_large_but_valid_hostname);\n  char *overly_large_hostname = \"127.0.0.2\";\n  host_lookup(overly_large_hostname);\n  return 0;\n}\nExemple bonus\nC\n(bad code)\u00a0\n#include <stdlib.h>\n#include <stdio.h>\nvoid set_array_elements(int* array) {\n    for(int i = 0; i<= 10; i++) {\n        array[i] = i*i; // Out-of-bounds write for arrays that are too small.\n    }\n}\nvoid print_array_sum(int* array) {\n    int sum = 0;\n    for(int i = 0; i<= 10; i++) {\n        sum += array[i]; // Out-of-bounds read for arrays that are too small.\n    }\n    printf(\"%d\\n\", sum);\n}\nint main() {\n    int* array = calloc(5, sizeof(int));\n    // intraprocedural buffer overflow\n    for(int i = 0; i<= 10; i++) {\n        array[i] = i*i; // Out-of-bounds write for arrays that are too small.\n    }\n    // interprocedural buffer overflow\n    set_array_elements(array);\n    free(array);\n    array = malloc(5 * sizeof(int));\n    // intraprocedural buffer overflow\n    int sum = 0;\n    for(int i = 0; i<= 10; i++) {\n        sum += array[i]; // Out-of-bounds read for arrays that are too small.\n    }\n    printf(\"%d\\n\", sum);\n    // interprocedural buffer overflow\n    print_array_sum(array);\n    puts((void*) array - 1); // Parameter is an out-of-bounds pointer.\n    free(array);\n}", "start_char_idx": 5203, "end_char_idx": 7768, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "175ebbd4-c6ce-4d9f-b8d0-5dd6213dc8a6": {"__data__": {"id_": "175ebbd4-c6ce-4d9f-b8d0-5dd6213dc8a6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fa68fa24-1cd9-4956-977c-0cec993497f9", "node_type": "4", "metadata": {}, "hash": "4c65c74f47ba1635b8e203f5714f48dab001787aea10d35de6fc32ca46a87c02", "class_name": "RelatedNodeInfo"}}, "text": "CWE-547: Use of Hard-coded, Security-relevant Constants\nDescription :\nThe product uses hard-coded constants instead of symbolic names for security-critical values, which increases the likelihood of mistakes during code maintenance or security policy change. \nExtended Description :\nIf the developer does not find all occurrences of the hard-coded constants, an incorrect policy decision may be made if one of the constants is not changed. Making changes to these values will require code changes that may be difficult or impossible once the system is released to the field. In addition, these hard-coded values may become available to attackers if the code is ever disclosed. \nExample: 1\nC\n(bad code)\u00a0\nchar buffer[1024];\n...\nfgets(buffer, 1024, stdin);", "start_char_idx": 0, "end_char_idx": 752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a9a22eaa-72df-41b2-bddf-56471da8553c": {"__data__": {"id_": "a9a22eaa-72df-41b2-bddf-56471da8553c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "67fff742-5934-42eb-985c-f9c7b1f9511a", "node_type": "4", "metadata": {}, "hash": "9af88a39098851b369482ba187b01d67500efefbfcf70e7cee13ebcfb949da08", "class_name": "RelatedNodeInfo"}}, "text": "CWE-787: Out-of-bounds Write\nDescription :\nThe product writes data past the end, or before the beginning, of the intended buffer. \nExtended Description :\nTypically, this can result in corruption of data, a crash, or code execution. The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent write operation then produces undefined or unexpected results. \nExample: 1\nC\n(bad code)\u00a0\nint id_sequence[3];\n/* Populate the id array. */\nid_sequence[0] = 123;\nid_sequence[1] = 234;\nid_sequence[2] = 345;\nid_sequence[3] = 456;\nExample: 2\nC\n(bad code)\u00a0\nint returnChunkSize(void *) {\n/* if chunk info is valid, return the size of usable memory,\n* else, return -1 to indicate an error\n*/\n...\n}\nint main() {...\nmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n...\n}\nExample: 3\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}\nExample: 4\nC\n(bad code)\u00a0\nchar * copy_input(char *user_supplied_string){\nint i, dst_index;\nchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\nif ( MAX_SIZE <= strlen(user_supplied_string) ){die(\"user string too long, die evil hacker!\");\n}\ndst_index = 0;\nfor ( i = 0; i < strlen(user_supplied_string); i++ ){\nif( '&' == user_supplied_string[i] ){dst_buf[dst_index++] = '&';\ndst_buf[dst_index++] = 'a';\ndst_buf[dst_index++] = 'm';\ndst_buf[dst_index++] = 'p';\ndst_buf[dst_index++] = ';';\n}\nelse if ('<' == user_supplied_string[i] ){\n      dst_buf[dst_index++] = '&';\n      dst_buf[dst_index++] = 'l';\n      dst_buf[dst_index++] = 't';\n    }\n    else dst_buf[dst_index++] = user_supplied_string[i];\n  }\n  return dst_buf;\n}\nint main() {\n  char *benevolent_string = \"<a href='ab&c'>\";\n  copy_input(benevolent_string);\n  char *malicious_string  = \"&&&&&&&&&&&&&&&\";\n  copy_input(malicious_string);\n  return 0;\n}\nExample: 5\nC\n(bad code)\u00a0\nchar* trimTrailingWhitespace(char *strMessage, int length) {\nchar *retMessage;\nchar *message = malloc(sizeof(char)*(length+1));\n// copy input string to a temporary string\nchar message[length+1];\nint index;\nfor (index = 0; index < length; index++) {message[index] = strMessage[index];\n}\nmessage[index] = '\\0';\n// trim trailing whitespace\nint len = index-1;\nwhile (isspace(message[len])) {message[len] = '\\0';\nlen--;\n}\n// return string without trailing whitespace\nretMessage = message;\nreturn retMessage;\n}\nExample: 6\nC\n(bad code)\u00a0\nint i;\nunsigned int numWidgets;\nWidget **WidgetList;\nnumWidgets = GetUntrustedSizeValue();\nif ((numWidgets == 0) || (numWidgets > MAX_NUM_WIDGETS)) {ExitError(\"Incorrect number of widgets requested!\");\n}\nWidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));\nprintf(\"WidgetList ptr=%p\\n\", WidgetList);\nfor(i=0; i<numWidgets; i++) {WidgetList[i] = InitializeWidget();\n}\nWidgetList[numWidgets] = NULL;\nshowWidgets(WidgetList);\nExample: 7\nC\n(bad code)\u00a0\nint main() {...\nstrncpy(destBuf, &srcBuf[find(srcBuf, ch)], 1024);\n...\n}", "start_char_idx": 0, "end_char_idx": 3268, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "161ef1a3-de59-472a-bdcf-5ef96d7a39c7": {"__data__": {"id_": "161ef1a3-de59-472a-bdcf-5ef96d7a39c7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8eab868c-53a7-4843-b798-37cc5094e4f7", "node_type": "4", "metadata": {}, "hash": "5cb7572c49ad690ae23fe23fe55223e84d952679b7e58f8c74c9a57bdcaa90f5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-197: Numeric Truncation Error\nDescription :\nTruncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion. \nExtended Description :\nWhen a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred. \nExample: 1\nC\n(bad code)\u00a0\nint intPrimitive;\nshort shortPrimitive;\nintPrimitive = (int)(~((int)0) ^ (1 << (sizeof(int)*8-1)));\nshortPrimitive = intPrimitive;\nprintf(\"Int MAXINT: %d\\nShort MAXINT: %d\\n\", intPrimitive, shortPrimitive);", "start_char_idx": 0, "end_char_idx": 985, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e2c37621-12bb-4230-a45f-77fddfff2c72": {"__data__": {"id_": "e2c37621-12bb-4230-a45f-77fddfff2c72", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c8d1f8aa-5fdb-4a96-b021-1e0d7d044978", "node_type": "4", "metadata": {}, "hash": "2205eba15ea57d88a42eb8c0e9a9dee4b21f7dd6a629f27a9f7544749201fcf3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-170: Improper Null Termination\nDescription :\nThe product does not terminate or incorrectly terminates a string or array with a null character or equivalent terminator. \nExtended Description :\nNull termination errors frequently occur in two different ways. An off-by-one error could cause a null to be written out of bounds, leading to an overflow. Or, a program could use a strncpy() function call incorrectly, which prevents a null terminator from being added at all. Other scenarios are possible. \nExample: 1\nC\n(bad code)\u00a0\n#define MAXLEN 1024\n...\nchar *pathbuf[MAXLEN];\n...\nread(cfgfile,inputbuf,MAXLEN); //does not null terminate\nstrcpy(pathbuf,inputbuf); //requires null terminated input\n...\nExample: 2\nC\n(bad code)\u00a0\nchar buf[MAXPATH];\n...\nreadlink(pathname, buf, MAXPATH);\nint length = strlen(buf);\n...\nExample: 3\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <string.h>\nint main() {\nchar longString[] = \"String signifying nothing\";\nchar shortString[16];\nstrncpy(shortString, longString, 16);\nprintf(\"The last character in shortString is: %c (%1$x)\\n\", shortString[15]);\nreturn (0);\n}\nExemple bonus \nC\n(bad code)\u00a0\n#include<stdio.h> \n#include<string.h>\n#include <unistd.h>\n#define MAXLEN 1024\nint main(){\n    char *inputbuf;\n    char *pathbuf[MAXLEN];\n    /*for some file descriptor fd*/\n    read(0,inputbuf,MAXLEN); \n    strcpy(pathbuf,inputbuf);\n    return 0;\n}", "start_char_idx": 0, "end_char_idx": 1367, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8cf9d884-630d-4233-a196-f67b43712194": {"__data__": {"id_": "8cf9d884-630d-4233-a196-f67b43712194", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "604e3dff-9cfb-4748-9492-688e1f174d6c", "node_type": "4", "metadata": {}, "hash": "128499c477a406e261ff143668930c3c3572fdabf8f978dab0e33fdf51e2f2d4", "class_name": "RelatedNodeInfo"}}, "text": "CWE-590: Free of Memory not on the Heap\nDescription :\nThe product calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc(). \nExtended Description :\nWhen free() is called on an invalid pointer, the program's memory management data structures may become corrupted. This corruption can cause the program to crash or, in some circumstances, an attacker may be able to cause free() to operate on controllable memory locations to modify critical program variables or execute code. \nExample: 1\nC\n(bad code)\u00a0\nvoid foo(){\nrecord_t bar[MAX_SIZE];\n/* do something interesting with bar */\n...\nfree(bar);\n}", "start_char_idx": 0, "end_char_idx": 679, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5a9bd15-f454-4241-bdcf-daf824d53d6f": {"__data__": {"id_": "e5a9bd15-f454-4241-bdcf-daf824d53d6f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7d6c80d2-3afd-4df4-b6d7-0b340b392b36", "node_type": "4", "metadata": {}, "hash": "08f1557dea2e85f30cc854f99b10c5b857e088dde67b3caec2ab6100f3f7818d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-522: Insufficiently Protected Credentials\nDescription :\nThe product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval. \nExample: 1\nPHP\n(bad code)\u00a0\n$user = $_GET['user'];\n$pass = $_GET['pass'];\n$checkpass = $_GET['checkpass'];\nif ($pass == $checkpass) {SetUserPassword($user, $pass);\n}\nExample: 2\nJava\n(bad code)\u00a0\n...\nProperties prop = new Properties();\nprop.load(new FileInputStream(\"config.properties\"));\nString password = prop.getProperty(\"password\");\nDriverManager.getConnection(url, usr, password);\n...\nExample: 3\nJava\n(bad code)\u00a0\n...\nString password = regKey.GetValue(passKey).toString();\nNetworkCredential netCred = new NetworkCredential(username,password,domain);\n...\nExample: 4\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {if (strcmp(compress(password), compressed_password)) {printf(\"Incorrect Password!\\n\");\nreturn(0);\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}\nExample: 5\nJava\n(bad code)\u00a0\nint VerifyAdmin(String password) {if (passwd.Equals(compress(password), compressed_password)) {return(0);\n}\n//Diagnostic Mode\nreturn(1);\n}\nExample: 6\nJava\n(bad code)\u00a0\n# Java Web App ResourceBundle properties file\n...\nwebapp.ldap.username=secretUsername\nwebapp.ldap.password=secretPassword\n...", "start_char_idx": 0, "end_char_idx": 1306, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e29a242-400b-454e-9bed-c3abfe771195": {"__data__": {"id_": "5e29a242-400b-454e-9bed-c3abfe771195", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e5a412a5-a9a3-4fa2-970f-bf4058bdcbe0", "node_type": "4", "metadata": {}, "hash": "17e5d03b81c1b42b20ee79d3da1b68ddb884ea6f3236dea80287d9f9bc729644", "class_name": "RelatedNodeInfo"}}, "text": "CWE-195: Signed to Unsigned Conversion Error\nDescription :\nThe product uses a signed primitive and performs a cast to an unsigned primitive, which can produce an unexpected value if the value of the signed primitive can not be represented using an unsigned primitive. \nExtended Description :\nIt is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program. Often, functions will return negative values to indicate a failure. When the result of a function is to be used as a size parameter, using these negative return values can have unexpected results. For example, if negative size values are passed to the standard memory copy or allocation functions they will be implicitly cast to a large unsigned value. This may lead to an exploitable buffer overflow or underflow condition. \nExample: 1\nC\n(bad code)\u00a0\nunsigned int readdata () {int amount = 0;\n...\nif (result == ERROR)\namount = -1;\n...\nreturn amount;\n}\nExample: 2\nC\n(bad code)\u00a0\nunsigned int readdata () {int amount = 0;\n...\namount = accessmainframe();\n...\nreturn amount;\n}\nExample: 3\nC\n(bad code)\u00a0\nDataPacket *packet;\nint numHeaders;\nPacketHeader *headers;\nsock=AcceptSocketConnection();\nReadPacket(packet, sock);\nnumHeaders =packet->headers;\nif (numHeaders > 100) {ExitError(\"too many headers!\");\n}\nheaders = malloc(numHeaders * sizeof(PacketHeader);\nParsePacketHeaders(packet, headers);\nExample: 4\nC\n(bad code)\u00a0\nchar* processNext(char* strm) {char buf[512];\nshort len = *(short*) strm;\nstrm += sizeof(len);\nif (len <= 512) {memcpy(buf, strm, len);\nprocess(buf);\nreturn strm + len;\n}\nelse {return -1;\n}\n}\nExample: 5\nC\n(bad code)\u00a0\nint returnChunkSize(void *) {\n/* if chunk info is valid, return the size of usable memory,\n* else, return -1 to indicate an error\n*/\n...\n}\nint main() {...\nmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n...\n}\nExample: 6\nC\n(bad code)\u00a0\nint proc_msg(char *s, int msg_len)\n\t\t {\n// Note space at the end of the string - assume all strings have preamble with space\n\t\t    int pre_len = sizeof(\"preamble: \");\n\t\t    char buf[pre_len - msg_len];\n... Do processing here if we get this far\n\t\t  }\n\t\t  char *s = \"preamble: message\\n\";\n\t\t  char *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\n\t\t  int jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\n\t\t  int ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack", "start_char_idx": 0, "end_char_idx": 2534, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7a0dbe6-37da-44df-bf37-8243b7708f06": {"__data__": {"id_": "d7a0dbe6-37da-44df-bf37-8243b7708f06", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9594be9a-4993-4601-9f4e-a3981d4a04c0", "node_type": "4", "metadata": {}, "hash": "2d4b1b17befbc053a9924e5c4baf5d1a9fe9be0d57f937d77fcbade48068e3e7", "class_name": "RelatedNodeInfo"}}, "text": "CWE-253: Incorrect Check of Function Return Value\nDescription :\nThe product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions. \nExtended Description :\nImportant and common functions will return some value about the success of its actions. This will alert the program whether or not to handle any errors caused by that function. \nExample: 1\nC\n(bad code)\u00a0\ntmp = malloc(sizeof(int) * 4);\nif (tmp < 0 ) {\nperror(\"Failure\");\n//should have checked if the call returned 0\n}", "start_char_idx": 0, "end_char_idx": 533, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7e27f9d0-840c-450f-a1fc-4fd3a1ea2816": {"__data__": {"id_": "7e27f9d0-840c-450f-a1fc-4fd3a1ea2816", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c0711243-08bf-4086-b9fc-5774a0ee2e25", "node_type": "4", "metadata": {}, "hash": "e9aa27e53fdbb433314e0d2a47ef74a2494e5c1980d076c4663ef800f947d875", "class_name": "RelatedNodeInfo"}}, "text": "CWE-670: Always-Incorrect Control Flow Implementation\nDescription :\nThe code contains a control flow path that does not reflect the algorithm that the path is intended to implement, leading to incorrect behavior any time this path is navigated. \nExtended Description :\nThis weakness captures cases in which a particular code segment is always incorrect with respect to the algorithm that it is implementing. For example, if a C programmer intends to include multiple statements in a single block but does not include the enclosing braces (CWE-483), then the logic is always incorrect. This issue is in contrast to most weaknesses in which the code usually behaves correctly, except when it is externally manipulated in malicious ways. \nExample: 1\nPHP\n(bad code)\u00a0\n$requestingIP = $_SERVER['REMOTE_ADDR'];\nif(!in_array($requestingIP,$ipAllowList)){echo \"You are not authorized to view this page\";\nhttp_redirect($errorPageURL);\n}\n$status = getServerStatus();\necho $status;\n...\nExample: 2\nC\n(bad code)\u00a0\nif (condition==true)Do_X();\nDo_Y();\nExample: 3\nJava\n(bad code)\u00a0\npublic void printMessage(int month){\nswitch (month) {\ncase 1: print(\"January\");\ncase 2: print(\"February\");\ncase 3: print(\"March\");\ncase 4: print(\"April\");\ncase 5: print(\"May\");\ncase 6: print(\"June\");\ncase 7: print(\"July\");\ncase 8: print(\"August\");\ncase 9: print(\"September\");\ncase 10: print(\"October\");\ncase 11: print(\"November\");\ncase 12: print(\"December\");\n}\nprintln(\" is a great month\");\n}\nExample: 4\nC\n(bad code)\u00a0\nvoid printMessage(int month){\nswitch (month) {\ncase 1: printf(\"January\");\ncase 2: printf(\"February\");\ncase 3: printf(\"March\");\ncase 4: printf(\"April\");\ncase 5: printff(\"May\");\ncase 6: printf(\"June\");\ncase 7: printf(\"July\");\ncase 8: printf(\"August\");\ncase 9: printf(\"September\");\ncase 10: printf(\"October\");\ncase 11: printf(\"November\");\ncase 12: printf(\"December\");\n}\nprintf(\" is a great month\");\n}", "start_char_idx": 0, "end_char_idx": 1878, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0295739d-bdeb-405f-84b4-e1f1cd7561cc": {"__data__": {"id_": "0295739d-bdeb-405f-84b4-e1f1cd7561cc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d588ffd3-5711-4f64-98f5-bf79c3956dc9", "node_type": "4", "metadata": {}, "hash": "6e768e956218739b30694bd23d9939d9b61e9e8d1142455425d3255870324328", "class_name": "RelatedNodeInfo"}}, "text": "CWE-240: Improper Handling of Inconsistent Structural Elements\nDescription :\nThe product does not handle or incorrectly handles when two or more structural elements should be consistent, but are not. \nExample: 1\nC\n(bad code)\u00a0\nint processMessageFromSocket(int socket) {\nint success;\nchar buffer[BUFFER_SIZE];\nchar message[MESSAGE_SIZE];\n// get message from socket and store into buffer\n//Ignoring possibliity that buffer > BUFFER_SIZE\nif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n// place contents of the buffer into message structure\nExMessage *msg = recastBuffer(buffer);\n// copy message body into string for processing\nint index;\nfor (index = 0; index < msg->msgLength; index++) {message[index] = msg->msgBody[index];\n}\nmessage[index] = '\\0';\n// process message\nsuccess = processMessage(message);\n}\nreturn success;\n}", "start_char_idx": 0, "end_char_idx": 824, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b4af83a2-0ea1-400f-bb3c-2d6ca33ac8fd": {"__data__": {"id_": "b4af83a2-0ea1-400f-bb3c-2d6ca33ac8fd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f1909eff-0d9c-4b18-852a-2dccf0ccf82f", "node_type": "4", "metadata": {}, "hash": "fed2a7b80cca3308721afe7ad2c0940e152217e35fd1724b4dc3657d672a6f8c", "class_name": "RelatedNodeInfo"}}, "text": "CWE-642: External Control of Critical State Data\nDescription :\nThe product stores security-critical state information about its users, or the product itself, in a location that is accessible to unauthorized actors. \nExample: 1\nJava\n(bad code)\u00a0\nCookie[] cookies = request.getCookies();\nfor (int i =0; i< cookies.length; i++) {Cookie c = cookies[i];\nif (c.getName().equals(\"authenticated\") && Boolean.TRUE.equals(c.getValue())) {authenticated = true;\n}\n}\nExample: 2\nJava\n(bad code)\u00a0\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\nExample: 3\nJava\n(bad code)\u00a0\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\nExample: 4\nC\n(bad code)\u00a0\n#define DIR \"/restricted/directory\"\nchar cmd[500];\nsprintf(cmd, \"ls -l %480s\", DIR);\n/* Raise privileges to those needed for accessing DIR. */\nRaisePrivileges(...);\nsystem(cmd);\nDropPrivileges(...);\n...", "start_char_idx": 0, "end_char_idx": 963, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "db88b18b-bbd2-4e36-9be0-47b76709bee6": {"__data__": {"id_": "db88b18b-bbd2-4e36-9be0-47b76709bee6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "410eb1d9-a93e-4c26-bc5d-183e320a0ea0", "node_type": "4", "metadata": {}, "hash": "133c3c12d3e9f4561bee587d2bf27fde91c68acfb5ab946381503b9179ecb9e6", "class_name": "RelatedNodeInfo"}}, "text": "CWE-188: Reliance on Data/Memory Layout\nDescription :\nThe product makes invalid assumptions about how protocol data or memory is organized at a lower level, resulting in unintended program behavior. \nExtended Description :\nWhen changing platforms or protocol versions, in-memory organization of data may change in unintended ways. For example, some architectures may place local variables A and B right next to each other with A on top; some may place them next to each other with B on top; and others may add some padding to each. The padding size may vary to ensure that each variable is aligned to a proper word size. In protocol implementations, it is common to calculate an offset relative to another field to pick out a specific piece of data. Exceptional conditions, often involving new protocol versions, may add corner cases that change the data layout in an unusual way. The result can be that an implementation accesses an unintended field in the packet, treating data of one type as data of another type. \nExample: 1\nC\n(bad code)\u00a0\nvoid example() {char a;\nchar b;\n*(&a + 1) = 0;\n}", "start_char_idx": 0, "end_char_idx": 1091, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a4b989d-98ea-41b5-9478-d71b6cc75ad7": {"__data__": {"id_": "7a4b989d-98ea-41b5-9478-d71b6cc75ad7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c95f1c73-afa0-4f75-9e25-212c0928ef55", "node_type": "4", "metadata": {}, "hash": "a9a01addf0b761c2f790c51b92e218c1a08732668f73b96b2d7eee7b7dc22c3a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1204: Generation of Weak Initialization Vector (IV)\nDescription :\nThe product uses a cryptographic primitive that uses an Initialization Vector (IV), but the product does not generate IVs that are sufficiently unpredictable or unique according to the expected cryptographic requirements for that primitive. \nExample: 1\nC\n(bad code)\u00a0\nEVP_CIPHER_CTX ctx;\nchar key[EVP_MAX_KEY_LENGTH];\nchar iv[EVP_MAX_IV_LENGTH];\nRAND_bytes(key, b);\nmemset(iv,0,EVP_MAX_IV_LENGTH);\nEVP_EncryptInit(&ctx,EVP_bf_cbc(), key,iv);\nExample: 2\nJava\n(bad code)\u00a0\npublic class SymmetricCipherTest {\npublic static void main() {\nbyte[] text =\"Secret\".getBytes();\nbyte[] iv ={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n};\nKeyGenerator kg = KeyGenerator.getInstance(\"DES\");\nkg.init(56);\nSecretKey key = kg.generateKey();\nCipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\nIvParameterSpec ips = new IvParameterSpec(iv);\ncipher.init(Cipher.ENCRYPT_MODE, key, ips);\nreturn cipher.doFinal(inpBytes);\n}\n}", "start_char_idx": 0, "end_char_idx": 976, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ec27e9f-e50f-4b55-8779-ebf63cc585a3": {"__data__": {"id_": "2ec27e9f-e50f-4b55-8779-ebf63cc585a3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bc973d61-03ab-4256-b701-9ff350baab69", "node_type": "4", "metadata": {}, "hash": "a3b5f5105af92b55a886ad2f545cf2608f7eea49feeec041b48f9ce7cfa69b1a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nDescription :\nThe product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow. \nExtended Description :\nA buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the \"classic\" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections. \nExample: 1\nC\n(bad code)\u00a0\nchar last_name[20];\nprintf (\"Enter your last name: \");\nscanf (\"%s\", last_name);\nExample: 2\nC\n(bad code)\u00a0\nvoid manipulate_string(char * string){char buf[24];\nstrcpy(buf, string);\n...\n}\nExample: 3\nC\n(bad code)\u00a0\nchar buf[24];\nprintf(\"Please enter your name and press <Enter>\\n\");\ngets(buf);\n...\n}\nExample: 4\nC\n(bad code)\u00a0\n...\nstruct hostent *clienthp;\nchar hostname[MAX_LEN];\n// create server socket, bind to server address and listen on socket\n...\n// accept client connections and process requests\nint count = 0;\nfor (count = 0; count < MAX_CONNECTIONS; count++) {\nint clientlen = sizeof(struct sockaddr_in);\nint clientsocket = accept(serversocket, (struct sockaddr *)&clientaddr, &clientlen);\nif (clientsocket >= 0) {\nclienthp = gethostbyaddr((char*) &clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET);\nstrcpy(hostname, clienthp->h_name);\nlogOutput(\"Accepted client connection from host \", hostname);\n// process client request\n...\nclose(clientsocket);\n}\n}\nclose(serversocket);\n...", "start_char_idx": 0, "end_char_idx": 1861, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7cc043c9-087d-4e14-bb4e-a85fb836ae3d": {"__data__": {"id_": "7cc043c9-087d-4e14-bb4e-a85fb836ae3d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a052ba0a-7806-441e-b5a2-79e6ed5fc1ea", "node_type": "4", "metadata": {}, "hash": "04a85ed08c3d8523cf5f3eb0215cae43f4ee3a9a1da21e9c9e38c42f684fa600", "class_name": "RelatedNodeInfo"}}, "text": "CWE-676: Use of Potentially Dangerous Function\nDescription :\nThe product invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely. \nstrcpy() / wcscpy() - Copie une cha\u00eene dans une autre sans v\u00e9rification de la taille du tampon de destination.\nstrcat() / wcscat() - Concat\u00e8ne deux cha\u00eenes sans v\u00e9rification de la taille du tampon de destination.\nsprintf() - \u00c9crit dans une cha\u00eene sans v\u00e9rification de la taille du tampon.\ngets() - Lit une ligne depuis l'entr\u00e9e standard (stdin) sans v\u00e9rifier la taille du tampon de destination (obsol\u00e8te en C11).\nscanf() - Peut causer des d\u00e9bordements de tampon si les sp\u00e9cificateurs de format ne limitent pas les entr\u00e9es lues.\nExample: 1\nC\n(bad code)\u00a0\nvoid manipulate_string(char * string){char buf[24];\nstrcpy(buf, string);\n...\n}\n#include <stdio.h>\n#include <string.h>\nint main ()\n{\n  char str1[]=\"Hello World!\";\n  char str2[40];\n  strcpy (str2,str1);\n  return 0;\n}\nExample: 2\nC\n(bad code)\u00a0\n#include <stdio.h>\nint main() {\n    char tampon[256];\n    printf(\"Entrez du texte : \");\n    gets(tampon); // Dangereux: gets() ne v\u00e9rifie pas la taille du tampon\n    printf(\"Vous avez entr\u00e9 : %s\\n\", tampon);\n    return 0;\n}\nNote importante : La fonction gets() a \u00e9t\u00e9 officiellement supprim\u00e9e de la norme ISO C11 en raison de ses probl\u00e8mes de s\u00e9curit\u00e9 inh\u00e9rents. Il est fortement recommand\u00e9 d'utiliser des alternatives plus s\u00fbres telles que fgets() pour la lecture de cha\u00eenes de caract\u00e8res, car fgets() permet de sp\u00e9cifier la taille du tampon et \u00e9vite ainsi le risque de d\u00e9bordement de tampon :\nfgets(tampon, sizeof(tampon), stdin);", "start_char_idx": 0, "end_char_idx": 1645, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3bc37c15-2206-4c6e-970c-05c8906c5a24": {"__data__": {"id_": "3bc37c15-2206-4c6e-970c-05c8906c5a24", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "04ca65dc-19ee-4f8d-871e-331e0cd07fd1", "node_type": "4", "metadata": {}, "hash": "f8fcd1126d66f6f0d5b19a3aa1087d98685a58b243c1d5ab614cd8884984bb3c", "class_name": "RelatedNodeInfo"}}, "text": "CWE-390: Detection of Error Condition Without Action\nDescription :\nThe product detects a specific error, but takes no actions to handle the error. \nExample: 1\nC\n(bad code)\u00a0\nfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\nif (foo==NULL) {//We do nothing so we just ignore the error.\n}\nExample: 2\nC\n(good code)\u00a0\nfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\nif (foo==NULL) {printf(\"Malloc failed to allocate memory resources\");\nreturn -1;\n}\nExample: 3\nC++\n(bad code)\u00a0\nchar* readfile (char *filename) {\ntry {\n// open input file\nifstream infile;\ninfile.open(filename);\nif (!infile.is_open()) {throw \"Unable to open file \" + filename;\n}\n// get length of file\ninfile.seekg (0, ios::end);\nint length = infile.tellg();\ninfile.seekg (0, ios::beg);\n// allocate memory\nchar *buffer = new char [length];\n// read data from file\ninfile.read (buffer,length);\nif (!infile.good()) {throw \"Unable to read from file \" + filename;\n}\ninfile.close();\nreturn buffer;\n}\ncatch (...) {/* bug: insert code to handle this later */\n}\n}", "start_char_idx": 0, "end_char_idx": 1058, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ada8da20-2fd0-4b74-b020-a02839fe7c1e": {"__data__": {"id_": "ada8da20-2fd0-4b74-b020-a02839fe7c1e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e2b71924-c4b9-495e-80b8-b14f84ba5649", "node_type": "4", "metadata": {}, "hash": "825330087433d572e7c6ba2f2b865a5fbc2895d241d0b4dd4738905ceb300446", "class_name": "RelatedNodeInfo"}}, "text": "CWE-242: Use of Inherently Dangerous Function\nDescription :\nThe product calls a function that can never be guaranteed to work safely. \nExtended Description :\nCertain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account. The gets() function is unsafe because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to gets() and overflow the destination buffer. Similarly, the >> operator is unsafe to use when reading into a statically-allocated character array because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to the >> operator and overflow the destination buffer. \nVoici une liste non exhaustive de fonctions en C qui sont souvent consid\u00e9r\u00e9es comme dangereuses (\"bad functions\") en raison de leur potentiel \u00e0 introduire des vuln\u00e9rabilit\u00e9s de s\u00e9curit\u00e9, notamment des d\u00e9bordements de tampon, lorsqu'elles sont mal utilis\u00e9es. Cette liste comprend principalement des fonctions de manipulation de cha\u00eenes et de m\u00e9moire qui ne v\u00e9rifient pas la taille du tampon de destination :\nstrcpy() - Copie une cha\u00eene dans une autre sans v\u00e9rifier la taille du tampon de destination.\nstrcat() - Concat\u00e8ne deux cha\u00eenes sans v\u00e9rifier la taille du tampon de destination.\nsprintf() - \u00c9crit dans une cha\u00eene format\u00e9e sans v\u00e9rifier la taille du tampon de destination.\ngets() - Lit une ligne depuis l'entr\u00e9e standard (stdin) sans v\u00e9rifier la taille du tampon de destination; cette fonction a \u00e9t\u00e9 supprim\u00e9e dans la norme C11 en raison de son dangerosit\u00e9.\nscanf() (et ses variantes comme fscanf(), sscanf(), etc.) - Peuvent causer des d\u00e9bordements de tampon si les sp\u00e9cificateurs de format ne limitent pas la longueur de l'entr\u00e9e pour les cha\u00eenes.\nDes alternatives plus s\u00fbres existent pour chacune de ces fonctions, souvent avec des suffixes tels que \"n\", qui permettent de sp\u00e9cifier la taille du tampon et ainsi \u00e9viter les d\u00e9bordements. Par exemple :\nstrncpy() au lieu de strcpy()\nstrncat() au lieu de strcat()\nsnprintf() au lieu de sprintf()\nfgets() au lieu de gets()\nscanf() avec des limites de champ dans les sp\u00e9cificateurs de format (ex. \"%255s\") pour limiter la taille de la cha\u00eene lue.\nExample: 1\nC\n(bad code)\u00a0\nchar buf[BUFSIZE];\ngets(buf);\nExample: 2\nC\n(bad code)\u00a0\nchar buf[24];\nprintf(\"Please enter your name and press <Enter>\\n\");\ngets(buf);\n...\n}", "start_char_idx": 0, "end_char_idx": 2473, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "203ea0e8-1a38-4e33-92d5-c96e324c103a": {"__data__": {"id_": "203ea0e8-1a38-4e33-92d5-c96e324c103a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "303eb7ae-d60c-43d0-9f1e-ae450942d931", "node_type": "4", "metadata": {}, "hash": "6045654fbd22e60d1b8c1715c6da916b3a7db26712aa9d9280d4677fadb54b02", "class_name": "RelatedNodeInfo"}}, "text": "CWE-788: Access of Memory Location After End of Buffer\nDescription :\nThe product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer. \nExtended Description :\nThis typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer. \nExample: 1\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}\nExample: 2\nC\n(bad code)\u00a0\nint returnChunkSize(void *) {\n/* if chunk info is valid, return the size of usable memory,\n* else, return -1 to indicate an error\n*/\n...\n}\nint main() {...\nmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n...\n}\nExample: 3\nC\n(bad code)\u00a0\nchar * copy_input(char *user_supplied_string){\nint i, dst_index;\nchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\nif ( MAX_SIZE <= strlen(user_supplied_string) ){die(\"user string too long, die evil hacker!\");\n}\ndst_index = 0;\nfor ( i = 0; i < strlen(user_supplied_string); i++ ){\nif( '&' == user_supplied_string[i] ){dst_buf[dst_index++] = '&';\ndst_buf[dst_index++] = 'a';\ndst_buf[dst_index++] = 'm';\ndst_buf[dst_index++] = 'p';\ndst_buf[dst_index++] = ';';\n}\nelse if ('<' == user_supplied_string[i] ){\n/* encode to &lt; */\n}\nelse dst_buf[dst_index++] = user_supplied_string[i];\n}\nreturn dst_buf;\n}\nExample: 4\nC\n(bad code)\u00a0\nint processMessageFromSocket(int socket) {\nint success;\nchar buffer[BUFFER_SIZE];\nchar message[MESSAGE_SIZE];\n// get message from socket and store into buffer\n//Ignoring possibliity that buffer > BUFFER_SIZE\nif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n// place contents of the buffer into message structure\nExMessage *msg = recastBuffer(buffer);\n// copy message body into string for processing\nint index;\nfor (index = 0; index < msg->msgLength; index++) {message[index] = msg->msgBody[index];\n}\nmessage[index] = '\\0';\n// process message\nsuccess = processMessage(message);\n}\nreturn success;\n}", "start_char_idx": 0, "end_char_idx": 2298, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed8d8cc6-c397-4dcf-bb1f-ac62c76bef4c": {"__data__": {"id_": "ed8d8cc6-c397-4dcf-bb1f-ac62c76bef4c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9de7cbd6-341b-48ee-a017-ce9ef6b84743", "node_type": "4", "metadata": {}, "hash": "4eecae22d87433d2e7e0ea80b9fbfa4bd6d26cdcf8e9959877b01a8c0d2039b9", "class_name": "RelatedNodeInfo"}}, "text": "CWE-416: Use After Free\nDescription :\nReferencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code. \nExtended Description :\nThe use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for freeing the memory. In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process. If the newly allocated data happens to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved. \nExample: 1\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <unistd.h>\n#define BUFSIZER1 512\n#define BUFSIZER2 ((BUFSIZER1/2) - 8)\nint main(int argc, char **argv) {char *buf1R1;\nchar *buf2R1;\nchar *buf2R2;\nchar *buf3R2;\nbuf1R1 = (char *) malloc(BUFSIZER1);\nbuf2R1 = (char *) malloc(BUFSIZER1);\nfree(buf2R1);\nbuf2R2 = (char *) malloc(BUFSIZER2);\nbuf3R2 = (char *) malloc(BUFSIZER2);\nstrncpy(buf2R1, argv[1], BUFSIZER1-1);\nfree(buf1R1);\nfree(buf2R2);\nfree(buf3R2);\n}\nExample: 2\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\nif (err) {abrt = 1;\nfree(ptr);\n}\n...\nif (abrt) {logError(\"operation aborted before commit\", ptr);\n}\nExemple bonus\nC\n(bad code)\u00a0\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#define SIZE 64\nint main (){\n    int abrt=0;\n    int err=1;\n    char* ptr = (char*) malloc(SIZE*sizeof(char));\n    strcpy(ptr,\"This string is in the heap\");\n    if (err) {\n        abrt = 1;\n        free(ptr);\n        char* ptr2 = (char*) malloc(2*sizeof(char));\n    }\n    if (abrt) {\n        printf(\"operation aborted before commit. Pointer value is ptr: %s\",ptr);\n    }\n    return 0;\n}", "start_char_idx": 0, "end_char_idx": 2380, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55d3658c-741b-4857-b31e-bdc4c945fc73": {"__data__": {"id_": "55d3658c-741b-4857-b31e-bdc4c945fc73", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1a1ffe1c-b31f-44e0-8952-496d3d5a8e33", "node_type": "4", "metadata": {}, "hash": "2890e332f373df80acf49fe55b535fc81ab41561a781da7786e49118f727f0a4", "class_name": "RelatedNodeInfo"}}, "text": "CWE-250: Execution with Unnecessary Privileges\nDescription :\nThe product performs an operation at a privilege level that is higher than the minimum level required, which creates new weaknesses or amplifies the consequences of other weaknesses. \nExtended Description :\nNew weaknesses can be exposed because running with extra privileges, such as root or Administrator, can disable the normal security checks being performed by the operating system or surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if they occur while operating at raised privileges. Privilege management functions can behave in some less-than-obvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one non-root user to another. Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as root when a signal fires or a sub-process is executed, the signal handler or sub-process will operate with root privileges. \nExample: 2\nC\n(bad code)\u00a0\nchroot(APP_HOME);\nchdir(\"/\");\nFILE* data = fopen(argv[1], \"r+\");\n...", "start_char_idx": 0, "end_char_idx": 1165, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a3c4e9f0-8e4a-45ad-a627-9b3099f74499": {"__data__": {"id_": "a3c4e9f0-8e4a-45ad-a627-9b3099f74499", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8c0d146a-8fc7-4a78-bf18-469ff90acd77", "node_type": "4", "metadata": {}, "hash": "773ace0c6931f0e779ccd36ace925cc94885a954f21bd8d724f55d6c0a187a44", "class_name": "RelatedNodeInfo"}}, "text": "CWE-122: Heap-based Buffer Overflow\nDescription :\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc(). \nExample: 1\nC\n(bad code)\u00a0\n#define BUFSIZE 256\nint main(int argc, char **argv) {char *buf;\nbuf = (char *)malloc(sizeof(char)*BUFSIZE);\nstrcpy(buf, argv[1]);\n}\nExample: 2\nC\n(bad code)\u00a0\nchar * copy_input(char *user_supplied_string){\nint i, dst_index;\nchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\nif ( MAX_SIZE <= strlen(user_supplied_string) ){die(\"user string too long, die evil hacker!\");\n}\ndst_index = 0;\nfor ( i = 0; i < strlen(user_supplied_string); i++ ){\nif( '&' == user_supplied_string[i] ){dst_buf[dst_index++] = '&';\ndst_buf[dst_index++] = 'a';\ndst_buf[dst_index++] = 'm';\ndst_buf[dst_index++] = 'p';\ndst_buf[dst_index++] = ';';\n}\nelse if ('<' == user_supplied_string[i] ){\n/* encode to &lt; */\n}\nelse dst_buf[dst_index++] = user_supplied_string[i];\n}\nreturn dst_buf;\n}", "start_char_idx": 0, "end_char_idx": 1054, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0854306d-e195-4e08-80c6-ae7f10faac70": {"__data__": {"id_": "0854306d-e195-4e08-80c6-ae7f10faac70", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "50978624-76ed-4428-b2d1-6c4e0c5f8069", "node_type": "4", "metadata": {}, "hash": "16dae3e083991ee5cdb1cc3b4d296531e27c959e6cbb4991be85e83ca09190ba", "class_name": "RelatedNodeInfo"}}, "text": "CWE-426: Untrusted Search Path\nDescription :\nThe product searches for critical resources using an externally-supplied search path that can point to resources that are not under the product's direct control. \nExtended Description :\nThis might allow attackers to execute their own programs, access unauthorized data files, or modify configuration in unexpected ways. If the product uses a search path to locate critical resources such as programs, then an attacker could modify that search path to point to a malicious program, which the targeted product would then execute. The problem extends to any type of critical resource that the product trusts. Some of the most common variants of untrusted search path are: In various UNIX and Linux-based systems, the PATH environment variable may be consulted to locate executable programs, and LD_PRELOAD may be used to locate a separate library. In various Microsoft-based systems, the PATH environment variable is consulted to locate a DLL, if the DLL is not found in other paths that appear earlier in the search order. \nExample: 1\nC\n(bad code)\u00a0\n#define DIR \"/restricted/directory\"\nchar cmd[500];\nsprintf(cmd, \"ls -l %480s\", DIR);\n/* Raise privileges to those needed for accessing DIR. */\nRaisePrivileges(...);\nsystem(cmd);\nDropPrivileges(...);\n...\nExample: 2\nPHP\n(bad code)\u00a0\n//assume getCurrentUser() returns a username that is guaranteed to be alphanumeric (avoiding CWE-78) \n$userName = getCurrentUser();\n$command = 'ps aux | grep ' . $userName;\nsystem($command);\nExemple bonus :\nC\n(bad code)\u00a0\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <stdio.h>\nvoid sub(){\n  gid_t gid;\n  uid_t uid;\n  gid = getegid();\n  uid = geteuid();\n  setresgid(gid, gid, gid);\n  setresuid(uid, uid, uid);\n  system(\"/usr/bin/env echo and now what?\");\n}\nint main(int argc, char **argv, char **envp)\n{\n  sub();\n}", "start_char_idx": 0, "end_char_idx": 1901, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "badd3ef3-55c2-43d2-b4e6-278bc6738ec6": {"__data__": {"id_": "badd3ef3-55c2-43d2-b4e6-278bc6738ec6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "49051029-1266-4d0a-b451-0fc451657621", "node_type": "4", "metadata": {}, "hash": "354138f179a1804986b0d99fbe7cbc65ba774cd5fc4a141420392333c7401ac3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-770: Allocation of Resources Without Limits or Throttling\nDescription :\nThe product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor. \nExample: 1\nC\n(bad code)\u00a0\nsock=socket(AF_INET, SOCK_STREAM, 0);\nwhile (1) {newsock=accept(sock, ...);\nprintf(\"A connection has been accepted\\n\");\npid = fork();\n}\nExample: 2\nC\n(bad code)\u00a0\nint writeDataFromSocketToFile(char *host, int port)\n{\nchar filename[FILENAME_SIZE];\nchar buffer[BUFFER_SIZE];\nint socket = openSocketConnection(host, port);\nif (socket < 0) {printf(\"Unable to open socket connection\");\nreturn(FAIL);\n}\nif (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\nif (openFileToWrite(filename) > 0) {\nwhile (getNextMessage(socket, buffer, BUFFER_SIZE) > 0){if (!(writeToFile(buffer) > 0))break;\n}\n}\ncloseFile();\n}\ncloseSocket(socket);\n}\nExample: 3\nC\n(bad code)\u00a0\n/* process message accepts a two-dimensional character array of the form [length][body] containing the message to be processed */\nint processMessage(char **message)\n{\nchar *body;\nint length = getMessageLength(message[0]);\nif (length > 0) {body = &message[1][0];\nprocessMessageBody(body);\nreturn(SUCCESS);\n}\nelse {printf(\"Unable to process message; invalid message length\");\nreturn(FAIL);\n}\n}\nExample: 4\nC\n(good code)\u00a0\nunsigned int length = getMessageLength(message[0]);\nif ((length > 0) && (length < MAX_LENGTH)) {...}\nExample: 5\nJava\n(bad code)\u00a0\npublic void acceptConnections() {\ntry {ServerSocket serverSocket = new ServerSocket(SERVER_PORT);\nint counter = 0;\nboolean hasConnections = true;\nwhile (hasConnections) {Socket client = serverSocket.accept();\nThread t = new Thread(new ClientSocketThread(client));\nt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\nt.start();\n}\nserverSocket.close();\n} catch (IOException ex) {...}\n}\nExample: 6\nJava\n(good code)\u00a0\npublic static final int SERVER_PORT = 4444;\npublic static final int MAX_CONNECTIONS = 10;\n...\npublic void acceptConnections() {\ntry {ServerSocket serverSocket = new ServerSocket(SERVER_PORT);\nint counter = 0;\nboolean hasConnections = true;\nwhile (hasConnections) {hasConnections = checkForMoreConnections();\nSocket client = serverSocket.accept();\nThread t = new Thread(new ClientSocketThread(client));\nt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\nExecutorService pool = Executors.newFixedThreadPool(MAX_CONNECTIONS);\npool.execute(t);\n}\nserverSocket.close();\n} catch (IOException ex) {...}\n}", "start_char_idx": 0, "end_char_idx": 2582, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d7ab131-d7d7-4c1b-a68c-733294763926": {"__data__": {"id_": "1d7ab131-d7d7-4c1b-a68c-733294763926", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1eb4658d-9cfe-4913-b61f-448361be95af", "node_type": "4", "metadata": {}, "hash": "bd919c9bf50af39ab554d5c7c3bb6685791094266b82a96efe57785b2f89a5a2", "class_name": "RelatedNodeInfo"}}, "text": "CWE-130: Improper Handling of Length Parameter Inconsistency\nDescription :\nThe product parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data. \nExtended Description :\nIf an attacker can manipulate the length parameter associated with an input such that it is inconsistent with the actual length of the input, this can be leveraged to cause the target application to behave in unexpected, and possibly, malicious ways. One of the possible motives for doing so is to pass in arbitrarily large input to the application. Another possible motivation is the modification of application state by including invalid data for subsequent properties of the application. Such weaknesses commonly lead to attacks such as buffer overflows and execution of arbitrary code. \nExample: 1\nC\n(bad code)\u00a0\nint processMessageFromSocket(int socket) {\nint success;\nchar buffer[BUFFER_SIZE];\nchar message[MESSAGE_SIZE];\n// get message from socket and store into buffer\n//Ignoring possibliity that buffer > BUFFER_SIZE\nif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n// place contents of the buffer into message structure\nExMessage *msg = recastBuffer(buffer);\n// copy message body into string for processing\nint index;\nfor (index = 0; index < msg->msgLength; index++) {message[index] = msg->msgBody[index];\n}\nmessage[index] = '\\0';\n// process message\nsuccess = processMessage(message);\n}\nreturn success;\n}", "start_char_idx": 0, "end_char_idx": 1495, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cb165726-348b-4517-9b09-4c1b1c23da88": {"__data__": {"id_": "cb165726-348b-4517-9b09-4c1b1c23da88", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "69e90cff-2402-440d-82bb-f3a66fad6231", "node_type": "4", "metadata": {}, "hash": "41a6af106ff85dcd6cea8b0d90a8b9c3bebe5fd218c16cf60d10538f662ed7e7", "class_name": "RelatedNodeInfo"}}, "text": "CWE-324: Use of a Key Past its Expiration Date\nDescription :\nThe product uses a cryptographic key or password past its expiration date, which diminishes its safety significantly by increasing the timing window for cracking attacks against that key. \nExample: 1\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer_certificate(ssl)) {\nfoo=SSL_get_verify_result(ssl);\nif ((X509_V_OK==foo) || (X509_V_ERRCERT_NOT_YET_VALID==foo))\n//do stuff\n}", "start_char_idx": 0, "end_char_idx": 424, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12e59f0e-2b21-4476-9c81-45787e604310": {"__data__": {"id_": "12e59f0e-2b21-4476-9c81-45787e604310", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ef7d7d2b-1c05-4139-a198-78fb9d94ede0", "node_type": "4", "metadata": {}, "hash": "63cc27f0ed95f661bd825c3373fd447272ca084c3c97f77b3594b866de4211e6", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1247: Improper Protection Against Voltage and Clock Glitches\nDescription :\nThe device does not contain or contains incorrectly implemented circuitry or sensors to detect and mitigate voltage and clock glitches and protect sensitive information or software contained on the device. \nExample: 1\nC\n(bad code)\u00a0\n...\n            if (signature_matches)  // <-Glitch Here\n            {\n              load_runtime_firmware();\n            }\n            else\n            {\n              do_not_load_runtime_firmware();\n            }\n            ...", "start_char_idx": 0, "end_char_idx": 541, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d10134a1-7f73-4ab7-9fb0-50cf094150d9": {"__data__": {"id_": "d10134a1-7f73-4ab7-9fb0-50cf094150d9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f852e23-ea78-46c0-978b-bbe69590e74e", "node_type": "4", "metadata": {}, "hash": "1c1ff127dfee80c4945569ae679c2ecd18fbf2581dc5e524d5f8937bdabbd62f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-370: Missing Check for Certificate Revocation after Initial Check\nDescription :\nThe product does not check the revocation status of a certificate after its initial revocation check, which can cause the product to perform privileged actions even after the certificate is revoked at a later time. \nExample: 1\nC\n(bad code)\u00a0\nif (cert = SSL_get_peer_certificate(ssl)) {\nfoo=SSL_get_verify_result(ssl);\nif (X509_V_OK==foo)\n//do stuff\nfoo=SSL_get_verify_result(ssl);\n//do more stuff without the check.", "start_char_idx": 0, "end_char_idx": 498, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aed10371-6873-4344-bff5-7be16c26b32c": {"__data__": {"id_": "aed10371-6873-4344-bff5-7be16c26b32c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "77656bbd-bc68-4de4-8c05-9ee50849a589", "node_type": "4", "metadata": {}, "hash": "8c735b5debcc893a3289e3f45399225a0190643b865c5c7bfca0c70738871cf1", "class_name": "RelatedNodeInfo"}}, "text": "CWE-129: Improper Validation of Array Index\nDescription :\nThe product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array. \nExample: 1\nJava\n(bad code)\u00a0\npublic String getValue(int index) {return array[index];\n}\nExample: 2\nJava\n(bad code)\u00a0\nprivate void buildList ( int untrustedListSize ){if ( 0 > untrustedListSize ){die(\"Negative value supplied for list size, die evil hacker!\");\n}\nWidget[] list = new Widget [ untrustedListSize ];\nlist[0] = new Widget();\n}\nExample: 3\nC\n(bad code)\u00a0\nint getValueFromArray(int *array, int len, int index) {\nint value;\n// check that the array index is less than the maximum\n// length of the array\nif (index < len) {\n// get the value at the specified index of the array\nvalue = array[index];\n}\n// if array index is invalid then output error message\n// and return value indicating error\nelse {printf(\"Value is: %d\\n\", array[index]);\nvalue = -1;\n}\nreturn value;\n}\nExample: 4\nC\n(good code)\u00a0\n...\n// check that the array index is within the correct\n// range of values for the array\nif (index >= 0 && index < len) {\n...\nExample: 5\nC\n(bad code)\u00a0\n/* capture the sizes of all messages */\nint getsizes(int sock, int count, int *sizes) {\n...\nchar buf[BUFFER_SIZE];\nint ok;\nint num, size;\n// read values from socket and added to sizes array\nwhile ((ok = gen_recv(sock, buf, sizeof(buf))) == 0)\n{\n// continue read from socket until buf only contains '.'\nif (DOTLINE(buf))break;\n                                 else if (sscanf(buf, \"%d %d\", &num, &size) == 2)sizes[num - 1] = size;\n}...\n}\nExample: 6\nC\n(good code)\u00a0\n/* capture the sizes of all messages */\nint getsizes(int sock, int count, int *sizes) {\n...\nchar buf[BUFFER_SIZE];\nint ok;\nint num, size;\n// read values from socket and added to sizes array\nwhile ((ok = gen_recv(sock, buf, sizeof(buf))) == 0)\n{\n// continue read from socket until buf only contains '.'\nif (DOTLINE(buf))break;\nelse if (sscanf(buf, \"%d %d\", &num, &size) == 2) {\nif (num > 0 && num <= (unsigned)count)sizes[num - 1] = size;\nelse\n/* warn about possible attempt to induce buffer overflow */\nreport(stderr, \"Warning: ignoring bogus data for message sizes returned by server.\\n\");\n}\n}...\n}", "start_char_idx": 0, "end_char_idx": 2276, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "79460a0c-7442-488e-8677-f8281c40faf0": {"__data__": {"id_": "79460a0c-7442-488e-8677-f8281c40faf0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bb4c2d88-85ce-4483-8a93-49e1cd70f087", "node_type": "4", "metadata": {}, "hash": "9009f151d963c71badf57c3328e886cd37ea2e2f8d575bb3aba5cec035f18a7a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-193: Off-by-one Error\nDescription :\nA product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value. \nExample: 1\nC\n(bad code)\u00a0\nint i;\nunsigned int numWidgets;\nWidget **WidgetList;\nnumWidgets = GetUntrustedSizeValue();\nif ((numWidgets == 0) || (numWidgets > MAX_NUM_WIDGETS)) {ExitError(\"Incorrect number of widgets requested!\");\n}\nWidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));\nprintf(\"WidgetList ptr=%p\\n\", WidgetList);\nfor(i=0; i<numWidgets; i++) {WidgetList[i] = InitializeWidget();\n}\nWidgetList[numWidgets] = NULL;\nshowWidgets(WidgetList);\nExample: 2\nC\n(bad code)\u00a0\nchar firstname[20];\nchar lastname[20];\nchar fullname[40];\nfullname[0] = '\\0';\nstrncat(fullname, firstname, 20);\nstrncat(fullname, lastname, 20);\nExample: 3\nC\n(good code)\u00a0\nchar firstname[20];\nchar lastname[20];\nchar fullname[40];\nfullname[0] = '\\0';\nstrncat(fullname, firstname, sizeof(fullname)-strlen(fullname)-1);\nstrncat(fullname, lastname, sizeof(fullname)-strlen(fullname)-1);\nExample: 4\nC\n(bad code)\u00a0\n#define PATH_SIZE 60\nchar filename[PATH_SIZE];\nfor(i=0; i<=PATH_SIZE; i++) {\nchar c = getc();\nif (c == 'EOF') {filename[i] = '\\0';\n}\nfilename[i] = getc();\n}", "start_char_idx": 0, "end_char_idx": 1205, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7693a93f-d7c8-4dbd-b817-edd77a3c37b8": {"__data__": {"id_": "7693a93f-d7c8-4dbd-b817-edd77a3c37b8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a0d3bda4-df0b-4927-aeab-5513dbd6db1d", "node_type": "4", "metadata": {}, "hash": "c428defe484abdbc2e6ebc54a33036566d18c078655a47407e674452fb03648e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-807: Reliance on Untrusted Inputs in a Security Decision\nDescription :\nThe product uses a protection mechanism that relies on the existence or values of an input, but the input can be modified by an untrusted actor in a way that bypasses the protection mechanism. \nExample: 1\nJava\n(bad code)\u00a0\nCookie[] cookies = request.getCookies();\nfor (int i =0; i< cookies.length; i++) {Cookie c = cookies[i];\nif (c.getName().equals(\"role\")) {userRole = c.getValue();\n}\n}\nExample: 2\nPHP\n(bad code)\u00a0\n$auth = $_COOKIES['authenticated'];\nif (! $auth) {if (AuthenticateUser($_POST['user'], $_POST['password']) == \"success\") {// save the cookie to send out in future responses\nsetcookie(\"authenticated\", \"1\", time()+60*60*2);\n}\nelse {ShowLoginScreen();\ndie(\"\\n\");\n}\n}\nDisplayMedicalHistory($_POST['patient_ID']);\nExample: 3\nJava\n(bad code)\u00a0\nCookie[] cookies = request.getCookies();\nfor (int i =0; i< cookies.length; i++) {Cookie c = cookies[i];\nif (c.getName().equals(\"authenticated\") && Boolean.TRUE.equals(c.getValue())) {authenticated = true;\n}\n}\nExample: 4\nC\n(bad code)\u00a0\nstruct hostent *hp;struct in_addr myaddr;\nchar* tHost = \"trustme.example.com\";\nmyaddr.s_addr=inet_addr(ip_addr_string);\nhp = gethostbyaddr((char *) &myaddr, sizeof(struct in_addr), AF_INET);\nif (hp && !strncmp(hp->h_name, tHost, sizeof(tHost))) {trusted = true;\n} else {trusted = false;\n}", "start_char_idx": 0, "end_char_idx": 1349, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5da9da63-70ab-4849-96bc-31dc14773c87": {"__data__": {"id_": "5da9da63-70ab-4849-96bc-31dc14773c87", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9fb90808-1164-4490-acfe-c4bdcda136c1", "node_type": "4", "metadata": {}, "hash": "150c2723d41f682f3972da6070c6bb299e08b337965eb82448dd810ac0df1c53", "class_name": "RelatedNodeInfo"}}, "text": "CWE-759: Use of a One-Way Hash without a Salt\nDescription :\nThe product uses a one-way cryptographic hash against an input that should not be reversible, such as a password, but the product does not also use a salt as part of the input. \nExtended Description :\nThis makes it easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables. It should be noted that, despite common perceptions, the use of a good salt with a hash does not sufficiently increase the effort for an attacker who is targeting an individual password, or who has a large amount of computing resources available, such as with cloud-based services or specialized, inexpensive hardware. Offline password cracking can still be effective if the hash function is not expensive to compute; many cryptographic functions are designed to be efficient and can be vulnerable to attacks using massive computing resources, even if the hash is cryptographically strong. The use of a salt only slightly increases the computing requirements for an attacker compared to other strategies such as adaptive hash functions. See CWE-916 for more details. \nExample: 1\nC\n(bad code)\u00a0\nunsigned char *check_passwd(char *plaintext) {ctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n//Login if hash matches stored hash\nif (equal(ctext, secret_password())) {login_user();\n}\n}", "start_char_idx": 0, "end_char_idx": 1380, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91c48766-2baa-45dc-b270-50328f2e669b": {"__data__": {"id_": "91c48766-2baa-45dc-b270-50328f2e669b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5ffaafef-8eea-4b5c-acd1-eb84107fdc58", "node_type": "4", "metadata": {}, "hash": "d3d3f866a39ef8ec0d3286749563f2b34c33049f1fa509eeb2517b60f71b7b07", "class_name": "RelatedNodeInfo"}}, "text": "CWE-123: Write-what-where Condition\nDescription :\nAny condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow. \nExample: 1\nC\n(bad code)\u00a0\n#define BUFSIZE 256\nint main(int argc, char **argv) {char *buf1 = (char *) malloc(BUFSIZE);\nchar *buf2 = (char *) malloc(BUFSIZE);\nstrcpy(buf1, argv[1]);\nfree(buf2);\n}", "start_char_idx": 0, "end_char_idx": 388, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f8618cb1-2e93-48ea-8fd8-d061c27568ba": {"__data__": {"id_": "f8618cb1-2e93-48ea-8fd8-d061c27568ba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2ac76c9f-4d9f-412a-bb5a-6c842f8d5713", "node_type": "4", "metadata": {}, "hash": "1ff97486673deb6f8d9170f45e67428070f5e04d7e26c2666da974db8b0d9072", "class_name": "RelatedNodeInfo"}}, "text": "CWE-785: Use of Path Manipulation Function without Maximum-sized Buffer\nDescription :\nThe product invokes a function for normalizing paths or file names, but it provides an output buffer that is smaller than the maximum possible size, such as PATH_MAX. \nExtended Description :\nPassing an inadequately-sized output buffer to a path manipulation function can result in a buffer overflow. Such functions include realpath(), readlink(), PathAppend(), and others. \nExample: 1\nC\n(bad code)\u00a0\nchar *createOutputDirectory(char *name) {\nchar outputDirectoryName[128];\nif (getCurrentDirectory(128, outputDirectoryName) == 0) {return null;\n}\nif (!PathAppend(outputDirectoryName, \"output\")) {return null;\n}\nif (!PathAppend(outputDirectoryName, name)) {\nreturn null;\n}\nif (SHCreateDirectoryEx(NULL, outputDirectoryName, NULL) != ERROR_SUCCESS) {\nreturn null;\n}\nreturn StrDup(outputDirectoryName);\n}", "start_char_idx": 0, "end_char_idx": 884, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b608be89-6074-4cd6-af3f-026cbc87de60": {"__data__": {"id_": "b608be89-6074-4cd6-af3f-026cbc87de60", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c63f80c2-c570-421b-8ce0-1940ca05c37d", "node_type": "4", "metadata": {}, "hash": "3f31e5dba235477bbed3f2f2efb1e58db1bcde9f4104ecc1665cc9f8972e7ec5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-563: Assignment to Variable without Use\nDescription :\nThe variable's value is assigned but never used, making it a dead store. \nExtended Description :\nAfter the assignment, the variable is either assigned another value or goes out of scope. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug. \nExample: 1\nC\n(bad code)\u00a0\nr = getName();\nr = getNewBuffer(buf);", "start_char_idx": 0, "end_char_idx": 427, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "02a8fe9e-5e91-486d-81fd-6e18dd479d4e": {"__data__": {"id_": "02a8fe9e-5e91-486d-81fd-6e18dd479d4e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ffa9de92-783c-42c6-868c-a1d17e65e029", "node_type": "4", "metadata": {}, "hash": "4199410f3d6febc9afc6eabe7d56e285a69be9570ee5e1a63577359333669ef3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-674: Uncontrolled Recursion\nDescription :\nThe product does not properly control the amount of recursion that takes place, consuming excessive resources, such as allocated memory or the program stack. \nExample: 1\nC\n(bad code)\u00a0\nvoid do_something_recursive (int flg)\n\t    {\n\t      ... // Do some real work here, but the value of flg is unmodified\n\t      if (flg) { do_something_recursive (flg); }    // flg is never modified so it is always TRUE - this call will continue until the stack explodes\n\t    }\n\t    int flag = 1; // Set to TRUE\n\t    do_something_recursive (flag);", "start_char_idx": 0, "end_char_idx": 574, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d19d22cc-5e34-45b9-b9b8-6919dac159da": {"__data__": {"id_": "d19d22cc-5e34-45b9-b9b8-6919dac159da", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6281d30c-9094-49ce-94cd-ee7e86a1a3b4", "node_type": "4", "metadata": {}, "hash": "4f4a7e4be3b9963013a3e0708cb5a7fe5b62939cb75ec779a734e9eba7fe76d9", "class_name": "RelatedNodeInfo"}}, "text": "CWE-805: Buffer Access with Incorrect Length Value\nDescription :\nThe product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer. \nExtended Description :\nWhen the length value exceeds the size of the destination, a buffer overflow could occur. \nExample: 1\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}\nExample: 2\nC\n(bad code)\u00a0\nint returnChunkSize(void *) {\n/* if chunk info is valid, return the size of usable memory,\n* else, return -1 to indicate an error\n*/\n...\n}\nint main() {...\nmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n...\n}\nExample: 3\nC\n(bad code)\u00a0\n...\nchar source[21] = \"the character string\";\nchar dest[12];\nstrncpy(dest, source, sizeof(source)-1);\n...\nExample: 4\nC\n(good code)\u00a0\n...\nchar source[21] = \"the character string\";\nchar dest[12];\nstrncpy(dest, source, sizeof(dest)-1);\n...", "start_char_idx": 0, "end_char_idx": 1278, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60c297a3-ff13-49f0-be49-3cd2e584d92c": {"__data__": {"id_": "60c297a3-ff13-49f0-be49-3cd2e584d92c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7af1b126-3076-4e4b-8519-a4b04f0028b4", "node_type": "4", "metadata": {}, "hash": "175b82d324d9eecfcf73e670642dd50cd37ef77aae8a8b83468dd7b8aa1ec03f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-605: Multiple Binds to the Same Port\nDescription :\nWhen multiple sockets are allowed to bind to the same port, other services on that port may be stolen or spoofed. \nExtended Description :\nOn most systems, a combination of setting the SO_REUSEADDR socket option, and a call to bind() allows any process to bind to a port to which a previous process has bound with INADDR_ANY. This allows a user to bind to the specific address of a server bound to INADDR_ANY on an unprivileged port, and steal its UDP packets/TCP connection. \nExample: 1\nC\n(bad code)\u00a0\nvoid bind_socket(void) {\nint server_sockfd;\nint server_len;\nstruct sockaddr_in server_address;\n/*unlink the socket if already bound to avoid an error when bind() is called*/\nunlink(\"server_socket\");\nserver_sockfd = socket(AF_INET, SOCK_STREAM, 0);\nserver_address.sin_family = AF_INET;\nserver_address.sin_port = 21;\nserver_address.sin_addr.s_addr = htonl(INADDR_ANY);\nserver_len = sizeof(struct sockaddr_in);\nbind(server_sockfd, (struct sockaddr *) &s1, server_len);\n}", "start_char_idx": 0, "end_char_idx": 1023, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27401368-1156-49e6-b7b3-77f210675c2a": {"__data__": {"id_": "27401368-1156-49e6-b7b3-77f210675c2a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3dc02176-5233-442e-aad0-2160b336d7af", "node_type": "4", "metadata": {}, "hash": "edeaab46d2f1bd59a20f44fa7fef7794670c7d1d21390967b0cb16af092298cc", "class_name": "RelatedNodeInfo"}}, "text": "CWE-825: Expired Pointer Dereference\nDescription :\nThe product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid. \nExtended Description :\nWhen a product releases memory, but it maintains a pointer to that memory, then the memory might be re-allocated at a later time. If the original pointer is accessed to read or write data, then this could cause the product to read or modify data that is in use by a different function or process. Depending on how the newly-allocated memory is used, this could lead to a denial of service, information exposure, or code execution. \nExample: 1\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\nif (err) {abrt = 1;\nfree(ptr);\n}\n...\nif (abrt) {logError(\"operation aborted before commit\", ptr);\n}\nExample: 2\nC\n(bad code)\u00a0\nchar* ptr = (char*)malloc (SIZE);\n...\nif (abrt) {free(ptr);\n}\n...\nfree(ptr);", "start_char_idx": 0, "end_char_idx": 889, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "858c4dd4-03c6-4538-a1e2-c19b558ed74f": {"__data__": {"id_": "858c4dd4-03c6-4538-a1e2-c19b558ed74f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "705d7b9c-e513-4bf2-a12c-e575d6351af5", "node_type": "4", "metadata": {}, "hash": "9cb7e77e1f76cc7fd22bd8527ddea9ccd99a88440c95493d46b6e623a554bc19", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\nDescription :\nThe processor does not properly clear microarchitectural state after incorrect microcode assists or speculative execution, resulting in transient execution. \nExtended Description :\nIn many processor architectures an exception, mis-speculation, or microcode assist results in a flush operation to clear results that are no longer required. This action prevents these results from influencing architectural state that is intended to be visible from software. However, traces of this transient execution may remain in microarchitectural buffers, resulting in a change in microarchitectural state that can expose sensitive information to an attacker using side-channel analysis. For example, Load Value Injection (LVI) [REF-1202] can exploit direct injection of erroneous values into intermediate load and store buffers. Several conditions may need to be fulfilled for a successful attack: incorrect transient execution that results in remanence of sensitive information; attacker has the ability to provoke microarchitectural exceptions; operations and structures in victim code that can be exploited must be identified. \nExample: 1\nC\n(bad code)\u00a0\nvoid call_victim(size_t untrusted_arg) {\n\t\t\t\t\t      *arg_copy = untrusted_arg;\n\t\t\t\t\t      array[**trusted_ptr * 4096];\n\t\t\t\t\t    }", "start_char_idx": 0, "end_char_idx": 1377, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a456ca6f-a673-44d3-8bf4-bbd53dd36e23": {"__data__": {"id_": "a456ca6f-a673-44d3-8bf4-bbd53dd36e23", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4c7f42a7-82b2-4c60-b171-ca377e8e1789", "node_type": "4", "metadata": {}, "hash": "49a40fca8d03bfde8c3e28e435374b5369e2d1d3a996fe168e3e1a70ce70bd6b", "class_name": "RelatedNodeInfo"}}, "text": "CWE-761: Free of Pointer not at Start of Buffer\nDescription :\nThe product calls free() on a pointer to a memory resource that was allocated on the heap, but the pointer is not at the start of the buffer. \nExtended Description :\nThis can cause the product to crash, or in some cases, modify critical program variables or execute code. This weakness often occurs when the memory is allocated explicitly on the heap with one of the malloc() family functions and free() is called, but pointer arithmetic has caused the pointer to be in the interior or end of the buffer. \nExample: 1\nC\n(bad code)\u00a0\n#define SUCCESS (1)\n#define FAILURE (0)\nint contains_char(char c){\nchar *str;\nstr = (char*)malloc(20*sizeof(char));\nstrcpy(str, \"Search Me!\");\nwhile( *str != NULL){\nif( *str == c ){\n/* matched char, free string and return success */\nfree(str);\nreturn SUCCESS;\n}\n/* didn't match yet, increment pointer and try next char */\nstr = str + 1;\n}\n/* we did not match the char in the string, free mem and return failure */\nfree(str);\nreturn FAILURE;\n}\nExample: 2\nC\n(good code)\u00a0\n#define SUCCESS (1)\n#define FAILURE (0)\nint cointains_char(char c){\nchar *str;\nint i = 0;\nstr = (char*)malloc(20*sizeof(char));\nstrcpy(str, \"Search Me!\");\nwhile( i < strlen(str) ){\nif( str[i] == c ){\n/* matched char, free string and return success */\nfree(str);\nreturn SUCCESS;\n}\n/* didn't match yet, increment pointer and try next char */\ni = i + 1;\n}\n/* we did not match the char in the string, free mem and return failure */\nfree(str);\nreturn FAILURE;\n}\nExample: 3\nC\n(bad code)\u00a0\nchar **ap, *argv[10], *inputstring;\nfor (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\nif (**ap != '\\0')if (++ap >= &argv[10])break;\n/.../\nfree(ap[4]);", "start_char_idx": 0, "end_char_idx": 1706, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "30861bb0-b1b3-4338-9c52-e3be456be249": {"__data__": {"id_": "30861bb0-b1b3-4338-9c52-e3be456be249", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ca77c1c6-cd8f-4681-8d94-231176cbf803", "node_type": "4", "metadata": {}, "hash": "8eabdc19c4078ac05e33b3d76760d4b9d068bb41c8092d8329441f624275677e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-755: Improper Handling of Exceptional Conditions\nDescription :\nThe product does not handle or incorrectly handles an exceptional condition. \nExample: 1\nJava\n(bad code)\u00a0\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {String ip = req.getRemoteAddr();\nInetAddress addr = InetAddress.getByName(ip);\n...\nout.println(\"hello \" + addr.getHostName());\n}\nExample: 2\nC\n(bad code)\u00a0\nfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\nif (foo==NULL) {//We do nothing so we just ignore the error.\n}\nExample: 3\nC\n(good code)\u00a0\nfoo=malloc(sizeof(char)); //the next line checks to see if malloc failed\nif (foo==NULL) {printf(\"Malloc failed to allocate memory resources\");\nreturn -1;\n}", "start_char_idx": 0, "end_char_idx": 736, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "646cc39a-72cf-4bd8-96ab-4df754b2633b": {"__data__": {"id_": "646cc39a-72cf-4bd8-96ab-4df754b2633b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b9a0fdae-09d2-46de-91f3-54cbe21e28b7", "node_type": "4", "metadata": {}, "hash": "5621d744d6b3b1a6d04349374b167681b38aea9b7cb076397f9534e98818a797", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\nDescription :\nA processor event or prediction may allow incorrect or stale data to be forwarded to transient operations, potentially exposing data over a covert channel. \nExample: 1\nC\n(bad code)\u00a0\nvoid call_victim(size_t untrusted_arg) {\n\t\t\t\t\t*arg_copy = untrusted_arg;\n\t\t\t\t\tarray[**trusted_ptr * 4096];\n\t\t\t\t  }\nExample: 2\nC\n(bad code)\u00a0\nvoid fn(int idx) {\n\t\t\t\t\tunsigned char v;\n\t\t\t\t\tidx_array[0] = 4096;\n\t\t\t\t\tv = array[idx_array[idx] * (idx)];\n\t\t\t\t  }", "start_char_idx": 0, "end_char_idx": 557, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cb04f768-cb76-4137-ad2b-2d2f5743c81e": {"__data__": {"id_": "cb04f768-cb76-4137-ad2b-2d2f5743c81e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed338f32-1603-4903-bff9-c727a7cbfee2", "node_type": "4", "metadata": {}, "hash": "323f9df8d25224e55713391027c8fe8a0537fa5bd82f1e77103e9752bca99dd9", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1325: Improperly Controlled Sequential Memory Allocation\nDescription :\nThe product manages a group of objects or resources and performs a separate memory allocation for each object, but it does not properly limit the total amount of memory that is consumed by all of the combined objects. \nExtended Description :\nWhile the product might limit the amount of memory that is allocated in a single operation for a single object (such as a malloc of an array), if an attacker can cause multiple objects to be allocated in separate operations, then this might cause higher total memory consumption than the developer intended, leading to a denial of service. \nExample: 1\nC\n(bad code)\u00a0\n// Gets the size from the number of objects in a database, which over time can conceivably get very large\n\t\t\t\t\t  int end_limit = get_nmbr_obj_from_db();\n\t\t\t\t\t  int i;\n\t\t\t\t\t  int *base = NULL;\n\t\t\t\t\t  int *p =base;\n\t\t\t\t\t  for (i = 0; i < end_limit; i++)\n\t\t\t\t\t  {\n\t\t\t\t\t      *p = alloca(sizeof(int *)); // Allocate memory on the stack\n\t\t\t\t\t      p = *p; // // Point to the next location to be saved\n\t\t\t\t\t    }", "start_char_idx": 0, "end_char_idx": 1089, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "22543c26-59aa-417e-8d98-6b5147520a17": {"__data__": {"id_": "22543c26-59aa-417e-8d98-6b5147520a17", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c185283a-8098-4731-b558-0b2c1acfa9c6", "node_type": "4", "metadata": {}, "hash": "91250bb7cce18a747af4b163d93610dfba0881a4c112871313343340d7d8c4ef", "class_name": "RelatedNodeInfo"}}, "text": "CWE-413: Improper Resource Locking\nDescription :\nThe product does not lock or does not correctly lock a resource when the product must have exclusive access to the resource. \nExtended Description :\nWhen a resource is not properly locked, an attacker could modify the resource while it is being operated on by the product. This might violate the product's assumption that the resource will not change, potentially leading to unexpected behaviors. \nExample: 1\nC\n(bad code)\u00a0\nvoid f(pthread_mutex_t *mutex) {\npthread_mutex_lock(mutex);\n/* access shared resource */\npthread_mutex_unlock(mutex);\n}\nExample: 2\nC\n(good code)\u00a0\nint f(pthread_mutex_t *mutex) {\nint result;\nresult = pthread_mutex_lock(mutex);\nif (0 != result)return result;\n/* access shared resource */\nreturn pthread_mutex_unlock(mutex);\n}", "start_char_idx": 0, "end_char_idx": 795, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "278de718-a0ea-40c1-98b3-80ef20fbc00d": {"__data__": {"id_": "278de718-a0ea-40c1-98b3-80ef20fbc00d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3b64f8c9-69bb-47ac-b057-bc8d4ec39b1e", "node_type": "4", "metadata": {}, "hash": "c4b796bfb46bdfe97a19368906c8055470f5d78f9a7e124ba89fb5e1f2f3f2d7", "class_name": "RelatedNodeInfo"}}, "text": "CWE-374: Passing Mutable Objects to an Untrusted Method\nDescription :\nThe product sends non-cloned mutable data as an argument to a method or function. \nExtended Description :\nThe function or method that has been called can alter or delete the mutable data. This could violate assumptions that the calling function has made about its state. In situations where unknown code is called with references to mutable data, this external code could make changes to the data sent. If this data was not previously cloned, the modified data might not be valid in the context of execution. \nExample: 1\nC\n(bad code)\u00a0\nprivate:int foo;\ncomplexType bar;\nString baz;\notherClass externalClass;\npublic:void doStuff() {externalClass.doOtherStuff(foo, bar, baz)\n}", "start_char_idx": 0, "end_char_idx": 743, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91bb3afe-7d8d-4ad3-982f-c90a186b9343": {"__data__": {"id_": "91bb3afe-7d8d-4ad3-982f-c90a186b9343", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "127171e6-3173-460a-b645-06f98d71922b", "node_type": "4", "metadata": {}, "hash": "f8773ada784d33d4110a86c784e35a6515c8d10c40af2532aebdb1073e8103ce", "class_name": "RelatedNodeInfo"}}, "text": "CWE-296: Improper Following of a Certificate's Chain of Trust\nDescription :\nThe product does not follow, or incorrectly follows, the chain of trust for a certificate back to a trusted root certificate, resulting in incorrect trust of any resource that is associated with that certificate. \nExample: 1\nC\n(bad code)\u00a0\nif ((cert = SSL_get_peer_certificate(ssl)) && host)foo=SSL_get_verify_result(ssl);\nif ((X509_V_OK==foo) || X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN==foo))\n// certificate looks good, host can be trusted", "start_char_idx": 0, "end_char_idx": 512, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "071da336-fc3b-46a8-a333-53e1cd5a0262": {"__data__": {"id_": "071da336-fc3b-46a8-a333-53e1cd5a0262", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b5be03dd-4331-40fe-b545-554a012f897e", "node_type": "4", "metadata": {}, "hash": "faa524dad36023107303c338eb206ef3eed41c86e53175a3065856b2d39f1c58", "class_name": "RelatedNodeInfo"}}, "text": "CWE-754: Improper Check for Unusual or Exceptional Conditions\nDescription :\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product. \nExtended Description :\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability. Note that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions. \nExample: 1\nC\n(bad code)\u00a0\nchar buf[10], cp_buf[10];\nfgets(buf, 10, stdin);\nstrcpy(cp_buf, buf);\nExample: 2\nC\n(bad code)\u00a0\nbuf = (char*) malloc(req_size);\nstrncpy(buf, xfer, req_size);\nExample: 3\nC#\n(bad code)\u00a0\nchar[] byteArray = new char[1024];\nfor (IEnumerator i=users.GetEnumerator(); i.MoveNext() ;i.Current()) {String userName = (String) i.Current();\nString pFileName = PFILE_ROOT + \"/\" + userName;\nStreamReader sr = new StreamReader(pFileName);\nsr.Read(byteArray,0,1024);//the file is always 1k bytes\nsr.Close();\nprocessPFile(userName, byteArray);\n}\nExample: 4\nJava\n(bad code)\u00a0\nFileInputStream fis;\nbyte[] byteArray = new byte[1024];\nfor (Iterator i=users.iterator(); i.hasNext();) {\nString userName = (String) i.next();\nString pFileName = PFILE_ROOT + \"/\" + userName;\nFileInputStream fis = new FileInputStream(pFileName);\nfis.read(byteArray); // the file is always 1k bytes\nfis.close();\nprocessPFile(userName, byteArray);\nExample: 5\nJava\n(bad code)\u00a0\nString itemName = request.getParameter(ITEM_NAME);\nif (itemName.compareTo(IMPORTANT_ITEM) == 0) {...\n}\n...\nExample: 6\nJava\n(bad code)\u00a0\nString itemName = request.Item(ITEM_NAME);\nif (itemName.Equals(IMPORTANT_ITEM)) {...\n}\n...\nExample: 7\nJava\n(bad code)\u00a0\nSystem.clearProperty(\"os.name\");\n...\nString os = System.getProperty(\"os.name\");\nif (os.equalsIgnoreCase(\"Windows 95\")) System.out.println(\"Not supported\");\nExample: 8\nC#\n(bad code)\u00a0\nDim MyFile As New FileStream(\"myfile.txt\", FileMode.Open, FileAccess.Read, FileShare.Read)\nDim MyArray(50) As Byte\nMyFile.Read(MyArray, 0, 50)\nDoDangerousOperation(MyArray(20))\nExample: 9\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}", "start_char_idx": 0, "end_char_idx": 2865, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "641128b1-c5c1-4480-a98f-3624f0166e87": {"__data__": {"id_": "641128b1-c5c1-4480-a98f-3624f0166e87", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "59382a07-93e3-494f-9dfe-e3d16d2c09e5", "node_type": "4", "metadata": {}, "hash": "eb6c07136b1ed022a675c1886bf29b3fd05afb49185df2d5488761211d88320a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1335: Incorrect Bitwise Shift of Integer\nDescription :\nAn integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result. \nExtended Description :\nSpecifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue. Specifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result. \nExample: 1\nC\n(bad code)\u00a0\nunsigned int r = 1 << -5;", "start_char_idx": 0, "end_char_idx": 868, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e13143ec-3327-4262-9b33-2efb9cfc1640": {"__data__": {"id_": "e13143ec-3327-4262-9b33-2efb9cfc1640", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "dcbf39fc-c954-4fa8-951f-84032aebc305", "node_type": "4", "metadata": {}, "hash": "ed85f6d51413b0d13fbf0db2e525ac0b1ee8a8fae8c0bff6e5707ccdf2d136be", "class_name": "RelatedNodeInfo"}}, "text": "CWE-377: Insecure Temporary File\nDescription :\nCreating and using insecure temporary files can leave application and system data vulnerable to attack. \nExample: 1\nC\n(bad code)\u00a0\nif (tmpnam_r(filename)) {\nFILE* tmp = fopen(filename,\"wb+\");\nwhile((recv(sock,recvbuf,DATA_SIZE, 0) > 0)&(amt!=0)) amt = fwrite(recvbuf,1,DATA_SIZE,tmp);\n}\n...", "start_char_idx": 0, "end_char_idx": 336, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf5ff60f-5424-4405-887e-c5fede17ef3b": {"__data__": {"id_": "cf5ff60f-5424-4405-887e-c5fede17ef3b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "93f1baf8-fb11-4b82-928a-17aefb808c38", "node_type": "4", "metadata": {}, "hash": "215ca74f2cd18036ce6885f7801e2daff1ee4781f53fbf32b50cf18050a3a9f9", "class_name": "RelatedNodeInfo"}}, "text": "CWE-468: Incorrect Pointer Scaling\nDescription :\nIn C and C++, one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled. \nExample: 1\nC\n(bad code)\u00a0\nint *p = x;\nchar * second_char = (char *)(p + 1);", "start_char_idx": 0, "end_char_idx": 259, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "74224cb7-7488-4aae-88be-ecb1cb673804": {"__data__": {"id_": "74224cb7-7488-4aae-88be-ecb1cb673804", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f40f4bd7-fb4c-4649-870e-cc95f36db59e", "node_type": "4", "metadata": {}, "hash": "d90c99fb104e7fb4ec0938994fed0d96e0c82b51852759c338ce2dd40b62bc99", "class_name": "RelatedNodeInfo"}}, "text": "CWE-400: Uncontrolled Resource Consumption\nDescription :\nThe product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources. \nExtended Description :\nLimited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the product, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system. There are at least three distinct scenarios which can commonly lead to resource exhaustion: Lack of throttling for the number of allocated resources Losing all references to a resource before reaching the shutdown stage Not closing/returning a resource after processing Resource exhaustion problems are often result due to an incorrect implementation of the following situations: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for releasing the resource. \nExample: 1\nJava\n(bad code)\u00a0\nclass Worker implements Executor {\n...\npublic void execute(Runnable r) {\ntry {...\n}\ncatch (InterruptedException ie) {\n// postpone response\nThread.currentThread().interrupt();\n}\n}\npublic Worker(Channel ch, int nworkers) {...\n}\nprotected void activate() {\nRunnable loop = new Runnable() {\npublic void run() {\ntry {for (;;) {Runnable r = ...;\nr.run();\n}\n}\ncatch (InterruptedException ie) {...\n}\n}\n};\nnew Thread(loop).start();\n}\n}\nExample: 2\nC\n(bad code)\u00a0\nsock=socket(AF_INET, SOCK_STREAM, 0);\nwhile (1) {newsock=accept(sock, ...);\nprintf(\"A connection has been accepted\\n\");\npid = fork();\n}\nExample: 3\nC\n(bad code)\u00a0\nint writeDataFromSocketToFile(char *host, int port)\n{\nchar filename[FILENAME_SIZE];\nchar buffer[BUFFER_SIZE];\nint socket = openSocketConnection(host, port);\nif (socket < 0) {printf(\"Unable to open socket connection\");\nreturn(FAIL);\n}\nif (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\nif (openFileToWrite(filename) > 0) {\nwhile (getNextMessage(socket, buffer, BUFFER_SIZE) > 0){if (!(writeToFile(buffer) > 0))break;\n}\n}\ncloseFile();\n}\ncloseSocket(socket);\n}\nExample: 4\nC\n(bad code)\u00a0\n/* process message accepts a two-dimensional character array of the form [length][body] containing the message to be processed */\nint processMessage(char **message)\n{\nchar *body;\nint length = getMessageLength(message[0]);\nif (length > 0) {body = &message[1][0];\nprocessMessageBody(body);\nreturn(SUCCESS);\n}\nelse {printf(\"Unable to process message; invalid message length\");\nreturn(FAIL);\n}\n}\nExample: 5\nC\n(good code)\u00a0\nunsigned int length = getMessageLength(message[0]);\nif ((length > 0) && (length < MAX_LENGTH)) {...}\nExample: 6\nJava\n(bad code)\u00a0\npublic void acceptConnections() {\ntry {ServerSocket serverSocket = new ServerSocket(SERVER_PORT);\nint counter = 0;\nboolean hasConnections = true;\nwhile (hasConnections) {Socket client = serverSocket.accept();\nThread t = new Thread(new ClientSocketThread(client));\nt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\nt.start();\n}\nserverSocket.close();\n} catch (IOException ex) {...}\n}", "start_char_idx": 0, "end_char_idx": 3484, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5170ac24-8e90-49af-b994-ee621ce9b141": {"__data__": {"id_": "5170ac24-8e90-49af-b994-ee621ce9b141", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cb6baa2a-0651-4249-b97d-e74734426474", "node_type": "4", "metadata": {}, "hash": "a7cf5c1520d6b894f107da2b6debcf2289e32fcdf97dc1b44bf7caa53e78aabe", "class_name": "RelatedNodeInfo"}}, "text": "CWE-671: Lack of Administrator Control over Security\nDescription :\nThe product uses security features in a way that prevents the product's administrator from tailoring security settings to reflect the environment in which the product is being used. This introduces resultant weaknesses or prevents it from operating at a level of security that is desired by the administrator. \nExtended Description :\nIf the product's administrator does not have the ability to manage security-related decisions at all times, then protecting the product from outside threats - including the product's developer - can become impossible. For example, a hard-coded account name and password cannot be changed by the administrator, thus exposing that product to attacks that the administrator can not prevent. \nExample: 1\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {\nif (strcmp(password, \"Mew!\")) {\n               printf(\"Incorrect Password!\\n\");\nreturn(0)\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}", "start_char_idx": 0, "end_char_idx": 994, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8fca81b1-2082-4c6f-9a38-1ddea6a798d6": {"__data__": {"id_": "8fca81b1-2082-4c6f-9a38-1ddea6a798d6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b3633c6d-c4d2-4691-a480-5f20f81fbb68", "node_type": "4", "metadata": {}, "hash": "04d60543f164979f47bfd48839b4b556ea074d9558bfa454c0b49e22e5d66372", "class_name": "RelatedNodeInfo"}}, "text": "CWE-428: Unquoted Search Path or Element\nDescription :\nThe product uses a search path that contains an unquoted element, in which the element contains whitespace or other separators. This can cause the product to access resources in a parent path. \nExample: 1\nC\n(bad code)\u00a0\nUINT errCode = WinExec( \"C:\\\\Program Files\\\\Foo\\\\Bar\", SW_SHOW );", "start_char_idx": 0, "end_char_idx": 339, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c06449a8-6975-4212-9043-b4762d7404a4": {"__data__": {"id_": "c06449a8-6975-4212-9043-b4762d7404a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "da5c5662-25d0-4073-928b-a64f9e191f50", "node_type": "4", "metadata": {}, "hash": "788d3859a1a3bc22fb10470351742ce9407ffc19bf1a7eefac016e62f8889149", "class_name": "RelatedNodeInfo"}}, "text": "CWE-763: Release of Invalid Pointer or Reference\nDescription :\nThe product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly. \nExtended Description :\nThis weakness can take several forms, such as: The memory was allocated, explicitly or implicitly, via one memory management method and deallocated using a different, non-compatible function (CWE-762). The function calls or memory management routines chosen are appropriate, however they are used incorrectly, such as in CWE-761. \nExample: 1\nC\n(bad code)\u00a0\nchar **ap, *argv[10], *inputstring;\nfor (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\nif (**ap != '\\0')if (++ap >= &argv[10])break;\n/.../\nfree(ap[4]);\nExample: 2\nC++\n(bad code)\u00a0\nvoid foo(){\nBarObj *ptr = new BarObj()\n/* do some work with ptr here */\n...\nfree(ptr);\n}\nExample: 3\nC++\n(good code)\u00a0\nvoid foo(){\nBarObj *ptr = new BarObj()\n/* do some work with ptr here */\n...\ndelete ptr;\n}\nExample: 4\nC\n(bad code)\u00a0\n#define SUCCESS (1)\n#define FAILURE (0)\nint contains_char(char c){\nchar *str;\nstr = (char*)malloc(20*sizeof(char));\nstrcpy(str, \"Search Me!\");\nwhile( *str != NULL){\nif( *str == c ){\n/* matched char, free string and return success */\nfree(str);\nreturn SUCCESS;\n}\n/* didn't match yet, increment pointer and try next char */\nstr = str + 1;\n}\n/* we did not match the char in the string, free mem and return failure */\nfree(str);\nreturn FAILURE;\n}", "start_char_idx": 0, "end_char_idx": 1466, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62116df0-b6c0-49e1-b512-052e6a4e05dd": {"__data__": {"id_": "62116df0-b6c0-49e1-b512-052e6a4e05dd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6b1d719e-d81e-4c0d-b070-773bc7f81e2a", "node_type": "4", "metadata": {}, "hash": "5b7a3630bc65e30512469640a0423c6ecbd9fbd8eed33170fe7e173b63c1c7d3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-469: Use of Pointer Subtraction to Determine Size\nDescription :\nThe product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk. \nExample: 1\nC\n(bad code)\u00a0\nstruct node {int data;\nstruct node* next;\n};\n// Returns the number of nodes in a linked list from\n// the given pointer to the head of the list.\nint size(struct node* head) {struct node* current = head;\nstruct node* tail;\nwhile (current != NULL) {tail = current;\ncurrent = current->next;\n}\nreturn tail - head;\n}\n// other methods for manipulating the list\n...", "start_char_idx": 0, "end_char_idx": 619, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ac37f395-6b57-4a48-8649-ebf93692343f": {"__data__": {"id_": "ac37f395-6b57-4a48-8649-ebf93692343f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cd40d92e-a162-4430-a535-64c25ec046d6", "node_type": "4", "metadata": {}, "hash": "6dcb0bc7fb6531595542e6527c6f5815e1f4f48731ae9e7a4ff1066dc6eafc89", "class_name": "RelatedNodeInfo"}}, "text": "CWE-366: Race Condition within a Thread\nDescription :\nIf two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined. \nExample: 1\nC\n(bad code)\u00a0\nint foo = 0;\nint storenum(int num) {static int counter = 0;\ncounter++;\nif (num > foo) foo = num;\nreturn foo;\n}", "start_char_idx": 0, "end_char_idx": 369, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9e66116e-851b-49ab-83ee-4d2311bd151e": {"__data__": {"id_": "9e66116e-851b-49ab-83ee-4d2311bd151e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cbd9c3f5-b11d-46f2-a392-ab6feea423ac", "node_type": "4", "metadata": {}, "hash": "77b06bb5f2efbedcf7759901ae9399fdf0fb5901934e44ea6a4fc4633a1b3968", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1023: Incomplete Comparison with Missing Factors\nDescription :\nThe product performs a comparison between entities that must consider multiple factors or characteristics of each entity, but the comparison does not include one or more of these factors. \nExample: 1\nJava\n(bad code)\u00a0\npublic class Truck {\nprivate String make;\nprivate String model;\nprivate int year;\npublic boolean equals(Object o) {\nif (o == null) return false;\nif (o == this) return true;\nif (!(o instanceof Truck)) return false;\nTruck t = (Truck) o;\nreturn (this.make.equals(t.getMake()) && this.model.equals(t.getModel()));\n}\n}\nExample: 2\nC\n(bad code)\u00a0\n/* Ignore CWE-259 (hard-coded password) and CWE-309 (use of password system for authentication) for this example. */ \nchar *username = \"admin\";\nchar *pass = \"password\";\nint AuthenticateUser(char *inUser, char *inPass) {if (strncmp(username, inUser, strlen(inUser))) {logEvent(\"Auth failure of username using strlen of inUser\");\nreturn(AUTH_FAIL);\n}\nif (! strncmp(pass, inPass, strlen(inPass))) {logEvent(\"Auth success of password using strlen of inUser\");\nreturn(AUTH_SUCCESS);\n}\nelse {logEvent(\"Auth fail of password using sizeof\");\nreturn(AUTH_FAIL);\n}\n}\nint main (int argc, char **argv) {\n\t\t\t\t\t int authResult;\nif (argc < 3) {ExitError(\"Usage: Provide a username and password\");\n}\nauthResult = AuthenticateUser(argv[1], argv[2]);\nif (authResult == AUTH_SUCCESS) {DoAuthenticatedTask(argv[1]);\n}\nelse {ExitError(\"Authentication failed\");\n}\n}", "start_char_idx": 0, "end_char_idx": 1466, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "86793ee8-4749-4676-a36c-2edfec61288f": {"__data__": {"id_": "86793ee8-4749-4676-a36c-2edfec61288f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4c73b2cd-9102-472c-9c1f-862ed23ee710", "node_type": "4", "metadata": {}, "hash": "d0c196608720a06c8d73c7cdcad0a56e480539ccd6271ff6bca878c54d778642", "class_name": "RelatedNodeInfo"}}, "text": "CWE-786: Access of Memory Location Before Start of Buffer\nDescription :\nThe product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer. \nExample: 1\nC\n(bad code)\u00a0\nchar* trimTrailingWhitespace(char *strMessage, int length) {\nchar *retMessage;\nchar *message = malloc(sizeof(char)*(length+1));\n// copy input string to a temporary string\nchar message[length+1];\nint index;\nfor (index = 0; index < length; index++) {message[index] = strMessage[index];\n}\nmessage[index] = '\\0';\n// trim trailing whitespace\nint len = index-1;\nwhile (isspace(message[len])) {message[len] = '\\0';\nlen--;\n}\n// return string without trailing whitespace\nretMessage = message;\nreturn retMessage;\n}\nExample: 2\nC\n(bad code)\u00a0\nint main (int argc, char **argv) {char *items[] = {\"boat\", \"car\", \"truck\", \"train\"};\nint index = GetUntrustedOffset();\nprintf(\"You selected %s\\n\", items[index-1]);\n}\nExample: 3\nC\n(bad code)\u00a0\nint main() {\n                     ...\n                     char *result = strstr(destBuf, \"Replace Me\");\n                     int idx = result - destBuf;\n                     strcpy(&destBuf[idx], srcBuf);\n                     ...\n}", "start_char_idx": 0, "end_char_idx": 1189, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8764fd38-fa2e-457e-8ea1-caddd9a93f40": {"__data__": {"id_": "8764fd38-fa2e-457e-8ea1-caddd9a93f40", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f46d0e6f-3ac7-412d-9875-5d0f14146b24", "node_type": "4", "metadata": {}, "hash": "6ab94f50ac4ede691d72b82802c896df3aa6afab95ca6a8964a59fc539cd7fb3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-379: Creation of Temporary File in Directory with Insecure Permissions\nDescription :\nThe product creates a temporary file in a directory whose permissions allow unintended actors to determine the file's existence or otherwise access that file. \nExtended Description :\nOn some operating systems, the fact that the temporary file exists may be apparent to any user with sufficient privileges to access that directory. Since the file is visible, the application that is using the temporary file could be known. If one has access to list the processes on the system, the attacker has gained information about what the user is doing at that time. By correlating this with the applications the user is running, an attacker could potentially discover what a user's actions are. From this, higher levels of security could be breached. \nExample: 1\nC\n(bad code)\u00a0\nFILE *stream;\nif( (stream = tmpfile()) == NULL ) {\nperror(\"Could not open new temporary file\\n\");\nreturn (-1);\n}\n// write data to tmp file\n...\n// remove tmp file\nrmtmp();", "start_char_idx": 0, "end_char_idx": 1027, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97c33909-fc15-4e5e-9718-5dc8ce7bf2ba": {"__data__": {"id_": "97c33909-fc15-4e5e-9718-5dc8ce7bf2ba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4eb6bd79-7401-4bbc-baab-39ae9633e06e", "node_type": "4", "metadata": {}, "hash": "45041116445c82b991ce5fa26ba90829c4817fc9653d57c2d3b9c913dd14189d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-191: Integer Underflow (Wrap or Wraparound)\nDescription :\nThe product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result. \nExtended Description :\nThis can happen in signed and unsigned cases. \nExample: 1\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <stdbool.h>\nmain (void)\n{int i;\ni = -2147483648;\ni = i - 1;\nreturn 0;\n}\nExample: 2\nC\n(bad code)\u00a0\nint a = 5, b = 6;\n\t\t    size_t len = a - b;\n\t\t    char buf[len];    // Just blows up the stack\n\t\t  }", "start_char_idx": 0, "end_char_idx": 564, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "996af53f-0ea7-497e-a180-05d69e568a36": {"__data__": {"id_": "996af53f-0ea7-497e-a180-05d69e568a36", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "83f5f799-51d3-47ce-bc89-20f5e8a8d3c2", "node_type": "4", "metadata": {}, "hash": "748a09ac6c4abb2ce59ed6af0c633311fe390cb27e5d0becc7882fbfa4de9001", "class_name": "RelatedNodeInfo"}}, "text": "CWE-311: Missing Encryption of Sensitive Data\nDescription :\nThe product does not encrypt sensitive or critical information before storage or transmission. \nExtended Description :\nThe lack of proper data encryption passes up the guarantees of confidentiality, integrity, and accountability that properly implemented encryption conveys. \nExample: 1\nPHP\n(bad code)\u00a0\nfunction persistLogin($username, $password){$data = array(\"username\" => $username, \"password\"=> $password);\nsetcookie (\"userdata\", $data);\n}\nExample: 2\nC\n(bad code)\u00a0\nserver.sin_family = AF_INET; hp = gethostbyname(argv[1]);\nif (hp==NULL) error(\"Unknown host\");\nmemcpy( (char *)&server.sin_addr,(char *)hp->h_addr,hp->h_length);\nif (argc < 3) port = 80;\nelse port = (unsigned short)atoi(argv[3]);\nserver.sin_port = htons(port);\nif (connect(sock, (struct sockaddr *)&server, sizeof server) < 0) error(\"Connecting\");\n...\nwhile ((n=read(sock,buffer,BUFSIZE-1))!=-1) {\nwrite(dfd,password_buffer,n);\n...\nExample: 3\nJava\n(bad code)\u00a0\ntry {URL u = new URL(\"http://www.secret.example.org/\");\nHttpURLConnection hu = (HttpURLConnection) u.openConnection();\nhu.setRequestMethod(\"PUT\");\nhu.connect();\nOutputStream os = hu.getOutputStream();\nhu.disconnect();\n}\ncatch (IOException e) {\n//...\n}", "start_char_idx": 0, "end_char_idx": 1240, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "58823e25-5dde-4f25-806b-4a61a2cfb4f6": {"__data__": {"id_": "58823e25-5dde-4f25-806b-4a61a2cfb4f6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0dd7b6e0-3bff-492e-9bcd-6d9726569b26", "node_type": "4", "metadata": {}, "hash": "a2717c62b2722eaec3dcd4ab83abe946db3b7d324cfa6ad1a1be634577c996f8", "class_name": "RelatedNodeInfo"}}, "text": "CWE-681: Incorrect Conversion between Numeric Types\nDescription :\nWhen converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur. \nExample: 1\nJava\n(bad code)\u00a0\nint i = (int) 33457.8f;\nExample: 2\nPHP\n(bad code)\u00a0\n$floatVal = 1.8345;\n$intVal = 3;\n$result = (int)$floatVal + $intVal;\nExample: 3\nC\n(bad code)\u00a0\nunsigned int readdata () {int amount = 0;\n...\nif (result == ERROR)\namount = -1;\n...\nreturn amount;\n}\nExample: 4\nC\n(bad code)\u00a0\nunsigned int readdata () {int amount = 0;\n...\namount = accessmainframe();\n...\nreturn amount;\n}", "start_char_idx": 0, "end_char_idx": 701, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ca2e1001-268b-4b6a-a728-b3adcfd23c29": {"__data__": {"id_": "ca2e1001-268b-4b6a-a728-b3adcfd23c29", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "19c6ff98-622a-42ea-9bf3-2dad2f7ef57e", "node_type": "4", "metadata": {}, "hash": "d24aa371e5bed28cb79df828f8034faf7106e908f4c0ae735baf81464615de06", "class_name": "RelatedNodeInfo"}}, "text": "CWE-820: Missing Synchronization\nDescription :\nThe product utilizes a shared resource in a concurrent manner but does not attempt to synchronize access to the resource. \nExtended Description :\nIf access to a shared resource is not synchronized, then the resource may not be in a state that is expected by the product. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource. \nExample: 1\nC\n(bad code)\u00a0\nstatic void print (char * string) {\nchar * word;\nint counter;\nfor (word = string; counter = *word++; ) {\nputc(counter, stdout);\nfflush(stdout);\n/* Make timing window a little larger... */\nsleep(1);\n}\n}\nint main(void) {\npid_t pid;\npid = fork();\nif (pid == -1) {exit(-2);\n}\nelse if (pid == 0) {print(\"child\\n\");\n}\nelse {print(\"PARENT\\n\");\n}\nexit(0);\n}", "start_char_idx": 0, "end_char_idx": 807, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "52e7fb52-5411-49c9-9ba6-a25ae44e5ea8": {"__data__": {"id_": "52e7fb52-5411-49c9-9ba6-a25ae44e5ea8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3c0ee000-3ca0-4edc-a8af-85115afa2540", "node_type": "4", "metadata": {}, "hash": "578a80d64bf24787dd38fba5103cdf1d1fc39ae3cfa67cc3a7fc097aeeee0d5b", "class_name": "RelatedNodeInfo"}}, "text": "CWE-839: Numeric Range Comparison Without Minimum Check\nDescription :\nThe product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum. \nExtended Description :\nSome products use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption. The use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account. \nExample: 1\nC\n(bad code)\u00a0\nDataPacket *packet;\nint numHeaders;\nPacketHeader *headers;\nsock=AcceptSocketConnection();\nReadPacket(packet, sock);\nnumHeaders =packet->headers;\nif (numHeaders > 100) {ExitError(\"too many headers!\");\n}\nheaders = malloc(numHeaders * sizeof(PacketHeader);\nParsePacketHeaders(packet, headers);\nExample: 2\nC\n(bad code)\u00a0\nint GetUntrustedInt () {return(0x0000FFFF);\n}\nvoid main (int argc, char **argv) {\nchar path[256];\nchar *input;\nint i;\nshort s;\nunsigned int sz;\ni = GetUntrustedInt();\ns = i;\n/* s is -1 so it passes the safety check - CWE-697 */ \nif (s > 256) {DiePainfully(\"go away!\\n\");\n}\n/* s is sign-extended and saved in sz */\nsz = s;\n/* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */\nprintf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\ninput = GetUserInput(\"Enter pathname:\");\n/* strncpy interprets s as unsigned int, so it's treated as MAX_INT\n(CWE-195), enabling buffer overflow (CWE-119) */ \nstrncpy(path, input, s);\npath[255] = '\\0'; /* don't want CWE-170 */ \nprintf(\"Path is: %s\\n\", path);\n}\nExample: 3\nC\n(bad code)\u00a0\nint getValueFromArray(int *array, int len, int index) {\nint value;\n// check that the array index is less than the maximum\n// length of the array\nif (index < len) {\n// get the value at the specified index of the array\nvalue = array[index];\n}\n// if array index is invalid then output error message\n// and return value indicating error\nelse {printf(\"Value is: %d\\n\", array[index]);\nvalue = -1;\n}\nreturn value;\n}", "start_char_idx": 0, "end_char_idx": 2588, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b1836881-d30c-4070-b5fb-06881e0f0b18": {"__data__": {"id_": "b1836881-d30c-4070-b5fb-06881e0f0b18", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "90d37a5a-fe77-4920-8a91-84b732181f90", "node_type": "4", "metadata": {}, "hash": "84f89ba4832f90a9be8647d3246e6cac422ec22a708535163224b4f21bbb30b4", "class_name": "RelatedNodeInfo"}}, "text": "CWE-290: Authentication Bypass by Spoofing\nDescription :\nThis attack-focused weakness is caused by incorrectly implemented authentication schemes that are subject to spoofing attacks. \nExample: 1\nJava\n(bad code)\u00a0\nString sourceIP = request.getRemoteAddr();\nif (sourceIP != null && sourceIP.equals(APPROVED_IP)) {authenticated = true;\n}\nExample: 2\nC\n(bad code)\u00a0\nsd = socket(AF_INET, SOCK_DGRAM, 0);\nserv.sin_family = AF_INET;\nserv.sin_addr.s_addr = htonl(INADDR_ANY);\nservr.sin_port = htons(1008);\nbind(sd, (struct sockaddr *) & serv, sizeof(serv));\nwhile (1) {memset(msg, 0x0, MAX_MSG);\nclilen = sizeof(cli);\nif (inet_ntoa(cli.sin_addr)==getTrustedAddress()) {n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);\n}\n}\nExample: 3\nJava\n(bad code)\u00a0\nwhile(true) {\nDatagramPacket rp=new DatagramPacket(rData,rData.length);\noutSock.receive(rp);\nString in = new String(p.getData(),0, rp.getLength());\nInetAddress clientIPAddress = rp.getAddress();\nint port = rp.getPort();\nif (isTrustedAddress(clientIPAddress) & secretKey.equals(in)) {out = secret.getBytes();\nDatagramPacket sp =new DatagramPacket(out,out.length, IPAddress, port); outSock.send(sp);\n}\n}", "start_char_idx": 0, "end_char_idx": 1163, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04c665a0-1caa-4fc1-9bdd-64dd8ab1a7e0": {"__data__": {"id_": "04c665a0-1caa-4fc1-9bdd-64dd8ab1a7e0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9e62ee3d-a66e-494d-af12-8a3dd42d23da", "node_type": "4", "metadata": {}, "hash": "162a03e621beda90fbd9b7f1fd7ff9f713852709aec804543ae94700c05337d1", "class_name": "RelatedNodeInfo"}}, "text": "CWE-476: NULL Pointer Dereference\nDescription :\nA NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit. \nExtended Description :\nNULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions. \nExample: bonus\nC\n(bad code)\u00a0\n#include <stdlib.h>\n#include <stdio.h>\nvoid func1(){\n  void* data = malloc(20000);\n  if (data == NULL){\n    exit(42);\n  }\n  free(data);\n}\nvoid func2(){\n int* data = malloc(200000);\n printf(\"%i\", data[0]);\n free(data);\n}\nint main() {\n  func1();\n  func2();\n}\nExample: 1\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}\nExample: 2\nJava\n(bad code)\u00a0\nString cmd = System.getProperty(\"cmd\");\ncmd = cmd.trim();\nExample: 3\nJava\n(bad code)\u00a0\n...\nIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\nMyReceiver receiver = new MyReceiver();\nregisterReceiver(receiver, filter);\n...\npublic class UrlHandlerReceiver extends BroadcastReceiver {\n@Override\npublic void onReceive(Context context, Intent intent) {\nif(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {String URL = intent.getStringExtra(\"URLToOpen\");\nint length = URL.length();\n...\n}\n}\n}\nExample: 4\nGo\n(bad code)\u00a0\nfunc HandleRequest(client http.Client, request *http.Request) (*http.Response, error) {\n                        response, err := client.Do(request)\n                        defer response.Body.Close()\n                        if err != nil {\n                              return nil, err\n                        }\n...\n                     }", "start_char_idx": 0, "end_char_idx": 1972, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a70868ec-d47e-4989-aa2f-69383fd64762": {"__data__": {"id_": "a70868ec-d47e-4989-aa2f-69383fd64762", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "25be472e-b57f-467e-a0a3-2bff21539873", "node_type": "4", "metadata": {}, "hash": "9df1f648b1dcfa725a5d71a77a26789cd8a14348d8638ad908c309304bc01ea6", "class_name": "RelatedNodeInfo"}}, "text": "CWE-831: Signal Handler Function Associated with Multiple Signals\nDescription :\nThe product defines a function that is used as a handler for more than one signal. \nExtended Description :\nWhile sometimes intentional and safe, when the same function is used to handle multiple signals, a race condition could occur if the function uses any state outside of its local declaration, such as global variables or non-reentrant functions, or has any side effects. An attacker could send one signal that invokes the handler function; in many OSes, this will typically prevent the same signal from invoking the handler again, at least until the handler function has completed execution. However, the attacker could then send a different signal that is associated with the same handler function. This could interrupt the original handler function while it is still executing. If there is shared state, then the state could be corrupted. This can lead to a variety of potential consequences depending on context, including denial of service and code execution. Another rarely-explored possibility arises when the signal handler is only designed to be executed once (if at all). By sending multiple signals, an attacker could invoke the function more than once. This may generate extra, unintended side effects. A race condition might not even be necessary; the attacker could send one signal, wait until it is handled, then send the other signal. \nExample: 1\nC\n(bad code)\u00a0\nvoid handler (int sigNum) {...\n}\nint main (int argc, char* argv[]) {signal(SIGUSR1, handler)\nsignal(SIGUSR2, handler)\n}\nExample: 2\nC\n(bad code)\u00a0\nchar *logMessage;\nvoid handler (int sigNum) {\nsyslog(LOG_NOTICE, \"%s\\n\", logMessage);\nfree(logMessage);\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\nsleep(10);\nexit(0);\n}\nint main (int argc, char* argv[]) {\nlogMessage = strdup(argv[1]);\n/* Register signal handlers. */\nsignal(SIGHUP, handler);\nsignal(SIGTERM, handler);\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\nsleep(10);\n}", "start_char_idx": 0, "end_char_idx": 2103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb2f8f52-4785-4671-a5b6-747c67e9818a": {"__data__": {"id_": "eb2f8f52-4785-4671-a5b6-747c67e9818a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "19e6964e-bff5-4869-8ba4-d52bcdebb4ab", "node_type": "4", "metadata": {}, "hash": "61fba6da617855eec3527a1099631cecc1166ad8e9b2e6ff8ec44dc860098b47", "class_name": "RelatedNodeInfo"}}, "text": "CWE-15: External Control of System or Configuration Setting\nDescription :\nOne or more system settings or configuration elements can be externally controlled by a user. \nExtended Description :\nAllowing external control of system settings can disrupt service or cause an application to behave in unexpected, and potentially malicious ways. \nExample: 1\nC\n(bad code)\u00a0\n...\nsethostid(argv[1]);\n...\nExample: 2\nJava\n(bad code)\u00a0\n...\nconn.setCatalog(request.getParameter(\"catalog\"));\n...", "start_char_idx": 0, "end_char_idx": 477, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "599b0f5e-5cf2-49a4-a5e7-7011b1f9c18f": {"__data__": {"id_": "599b0f5e-5cf2-49a4-a5e7-7011b1f9c18f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "669342df-2b2c-4d9c-bdac-b0f912f1fe30", "node_type": "4", "metadata": {}, "hash": "2d987ac54660f95f10ff3430b814b94428b5d16628ece9f85fc975af1c6a972a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-732: Incorrect Permission Assignment for Critical Resource\nDescription :\nThe product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors. \nExtended Description :\nWhen a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution, or sensitive user data. For example, consider a misconfigured storage account for the cloud that can be read or written by a public or anonymous user. \nExample: 1\nC\n(bad code)\u00a0\n#define OUTFILE \"hello.out\"\numask(0);\nFILE *out;\n/* Ignore link following (CWE-59) for brevity */ \nout = fopen(OUTFILE, \"w\");\nif (out) {fprintf(out, \"hello world!\\n\");\nfclose(out);\n}\nExample: 2\nPHP\n(bad code)\u00a0\nfunction createUserDir($username){$path = '/home/'.$username;\nif(!mkdir($path)){return false;\n}\nif(!chown($path,$username)){rmdir($path);\nreturn false;\n}\nreturn true;\n}\nExample: 3\nPerl\n(bad code)\u00a0\n$fileName = \"secretFile.out\";\nif (-e $fileName) {chmod 0777, $fileName;\n}\nmy $outFH;\nif (! open($outFH, \">>$fileName\")) {ExitError(\"Couldn't append to $fileName: $!\");\n}\nmy $dateString = FormatCurrentTime();\nmy $status = IsHostAlive(\"cwe.mitre.org\");\nprint $outFH \"$dateString cwe status: $status!\\n\";\nclose($outFH);\nExample: 4\nGo\n(bad code)\u00a0\nconst adminFile = \"/etc/admin-users\"\n                  func createAdminFileIfNotExists() error {\n                        file, err := os.Create(adminFile)\n                        if err != nil {\n                           return err\n                        }\n                        return nil\n                  }\n                  func changeModeOfAdminFile() error {\n                        fileMode := os.FileMode(0440)\n                        if err := os.Chmod(adminFile, fileMode); err != nil {\n                           return err\n                        }\n                        return nil\n                  }", "start_char_idx": 0, "end_char_idx": 2114, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "469d5b59-9675-4594-ae11-e1381cd77c41": {"__data__": {"id_": "469d5b59-9675-4594-ae11-e1381cd77c41", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fd7e7a1-cb63-48c4-9a28-39c82ff0ca8a", "node_type": "4", "metadata": {}, "hash": "1016290490441f0a68d3b6d0a474fd955bbc88a4169c3ab0a9895e9ba193adf4", "class_name": "RelatedNodeInfo"}}, "text": "CWE-272: Least Privilege Violation\nDescription :\nThe elevated privilege level required to perform operations such as chroot() should be dropped immediately after the operation is performed. \nExample: 1\nC\n(bad code)\u00a0\nsetuid(0);\n// Do some important stuff\nsetuid(old_uid);\n// Do some non privileged stuff.\nExample: 2\nJava\n(bad code)\u00a0\nAccessController.doPrivileged(new PrivilegedAction() {\npublic Object run() {\n// privileged code goes here, for example:\nSystem.loadLibrary(\"awt\");\nreturn null;\n// nothing to return\n}\nExample: 3\nC\n(bad code)\u00a0\nchroot(APP_HOME);\nchdir(\"/\");\nFILE* data = fopen(argv[1], \"r+\");\n...", "start_char_idx": 0, "end_char_idx": 608, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "128cf749-6187-459c-b09b-3df303f25c8f": {"__data__": {"id_": "128cf749-6187-459c-b09b-3df303f25c8f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cddb3235-1001-41fa-bc72-c1ad06299205", "node_type": "4", "metadata": {}, "hash": "31f6ed8bc62624b5530003fc734de10ce78fc7318eeb8b1e88054cb5811c489a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\nDescription :\nThe product defines a signal handler that contains code sequences that are not asynchronous-safe, i.e., the functionality is not reentrant, or it can be interrupted. \nExtended Description :\nThis can lead to an unexpected system state with a variety of potential consequences depending on context, including denial of service and code execution. Signal handlers are typically intended to interrupt normal functionality of a program, or even other signals, in order to notify the process of an event. When a signal handler uses global or static variables, or invokes functions that ultimately depend on such state or its associated metadata, then it could corrupt system state that is being used by normal functionality. This could subject the program to race conditions or other weaknesses that allow an attacker to cause the program state to be corrupted. While denial of service is frequently the consequence, in some cases this weakness could be leveraged for code execution. There are several different scenarios that introduce this issue: Invocation of non-reentrant functions from within the handler. One example is malloc(), which modifies internal global variables as it manages memory. Very few functions are actually reentrant. Code sequences (not necessarily function calls) contain non-atomic use of global variables, or associated metadata or structures, that can be accessed by other functionality of the program, including other signal handlers. Frequently, the same function is registered to handle multiple signals. The signal handler function is intended to run at most one time, but instead it can be invoked multiple times. This could happen by repeated delivery of the same signal, or by delivery of different signals that have the same handler function (CWE-831). Note that in some environments or contexts, it might be possible for the signal handler to be interrupted itself. If both a signal handler and the normal behavior of the product have to operate on the same set of state variables, and a signal is received in the middle of the normal execution's modifications of those variables, the variables may be in an incorrect or corrupt state during signal handler execution, and possibly still incorrect or corrupt upon return. \nExample: 1\nC\n(bad code)\u00a0\nchar *logMessage;\nvoid handler (int sigNum) {\nsyslog(LOG_NOTICE, \"%s\\n\", logMessage);\nfree(logMessage);\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\nsleep(10);\nexit(0);\n}\nint main (int argc, char* argv[]) {\nlogMessage = strdup(argv[1]);\n/* Register signal handlers. */\nsignal(SIGHUP, handler);\nsignal(SIGTERM, handler);\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\nsleep(10);\n}\nExample: 2\nC\n(bad code)\u00a0\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\nvoid *global1, *global2;\nchar *what;\nvoid sh (int dummy) {\nsyslog(LOG_NOTICE,\"%s\\n\",what);\nfree(global2);\nfree(global1);\n/* Sleep statements added to expand timing window for race condition */\nsleep(10);\nexit(0);\n}\nint main (int argc,char* argv[]) {\nwhat=argv[1];\nglobal1=strdup(argv[2]);\nglobal2=malloc(340);\nsignal(SIGHUP,sh);\nsignal(SIGTERM,sh);\n/* Sleep statements added to expand timing window for race condition */\nsleep(10);\nexit(0);\n}", "start_char_idx": 0, "end_char_idx": 3412, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "84317923-e22f-4950-afa1-73e8ad3102f7": {"__data__": {"id_": "84317923-e22f-4950-afa1-73e8ad3102f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6f38b185-7980-4472-b1df-2eb3478c44b0", "node_type": "4", "metadata": {}, "hash": "7755ee828dad486a3cf754067b7e82495265347ce8ce663d70e3567303430d59", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1164: Irrelevant Code\nDescription :\nThe product contains code that is not essential for execution, i.e. makes no state changes and has no side effects that alter data or control flow, such that removal of the code would have no impact to functionality or correctness. \nExample: 1\nC++\n(bad code)\u00a0\nString s = null;\nif (b) {s = \"Yes\";\nreturn;\n}\nif (s != null) {Dead();\n}\nExample: 2\nC\n(bad code)\u00a0\nr = getName();\nr = getNewBuffer(buf);", "start_char_idx": 0, "end_char_idx": 434, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45756963-9ac8-444b-b4e3-ad5e0ce50713": {"__data__": {"id_": "45756963-9ac8-444b-b4e3-ad5e0ce50713", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "939e5208-454f-425a-91bb-d09feb69d5aa", "node_type": "4", "metadata": {}, "hash": "72a1d34a6ea9cf1358540784924fc5635be410818b6be25bf1063e791d2bf9b0", "class_name": "RelatedNodeInfo"}}, "text": "CWE-226: Sensitive Information in Resource Not Removed Before Reuse\nDescription :\nThe product releases a resource such as memory or a file so that it can be made available for reuse, but it does not clear or \"zeroize\" the information contained in the resource before the product performs a critical state transition or makes the resource available for reuse by other entities. \nExample: 1\nC\n(bad code)\u00a0\ncleartext_buffer = get_secret();...\ncleartext_buffer = realloc(cleartext_buffer, 1024);\n...\nscrub_memory(cleartext_buffer, 1024);", "start_char_idx": 0, "end_char_idx": 532, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "59c97513-2916-4a31-88cd-77e311d4a509": {"__data__": {"id_": "59c97513-2916-4a31-88cd-77e311d4a509", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e295a05a-ef97-4221-b144-c2623f6c84b7", "node_type": "4", "metadata": {}, "hash": "cabd3d310b15961eb684c212fa3e83dd87f8f733da14902f9a302711cae6c865", "class_name": "RelatedNodeInfo"}}, "text": "CWE-125: Out-of-bounds Read\nDescription :\nThe product reads data past the end, or before the beginning, of the intended buffer. \nExtended Description :\nTypically, this can allow attackers to read sensitive information from other memory locations or cause a crash. A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string. The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow. The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent read operation then produces undefined or unexpected results. \nExample Bonus :\nC\n(bad code)\u00a0\nint main()\n{\n int a[10];\n a[10] = 0;\n return 0;\n}\nExample Bonus :\nC\n(bad code)\u00a0\nint main()\n{\n    int x;\n    int y=10;\n    int a[10];\n    x=a[y];\n    return 0;\n}\nExample Bonus :\nC\n(bad code)\u00a0\nint main()\n{\n    int x;\n    int y=10;\n    int a[10];\n    if (y)\n    {\n        x=a[y+2];\n    }\n    return 0;\n}\nExample Bonus :\nC\n(bad code)\u00a0\nint main()\n{\n    int y=10;\n    int a[10];\n    while (y>=0) \n    {   \n        a[y]=y;\n        y=y-1;\n    }\n    return 0;\n}\nExample: 1\nC\n(bad code)\u00a0\nint getValueFromArray(int *array, int len, int index) {\nint value;\n// check that the array index is less than the maximum\n// length of the array\nif (index < len) {\n// get the value at the specified index of the array\nvalue = array[index];\n}\n// if array index is invalid then output error message\n// and return value indicating error\nelse {printf(\"Value is: %d\\n\", array[index]);\nvalue = -1;\n}\nreturn value;\n}", "start_char_idx": 0, "end_char_idx": 1716, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ee10ff0-2793-45dd-a2ec-7b84ace9ac86": {"__data__": {"id_": "2ee10ff0-2793-45dd-a2ec-7b84ace9ac86", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e5c904aa-949f-44e8-811a-cd3774c005b4", "node_type": "4", "metadata": {}, "hash": "b7fb3e581c89b306e4fbe0575b62b0fb9942a33cee4ffedc4711531580f82d29", "class_name": "RelatedNodeInfo"}}, "text": "CWE-768: Incorrect Short Circuit Evaluation\nDescription :\nThe product contains a conditional statement with multiple logical expressions in which one of the non-leading expressions may produce side effects. This may lead to an unexpected state in the program after the execution of the conditional, because short-circuiting logic may prevent the side effects from occurring. \nExample: 1\nC\n(bad code)\u00a0\n#define PRIV_ADMIN 0\n#define PRIV_REGULAR 1\ntypedef struct{int privileges;\nint id;\n} user_t;\nuser_t *Add_Regular_Users(int num_users){user_t* users = (user_t*)calloc(num_users, sizeof(user_t));\nint i = num_users;\nwhile( --i && (users[i].privileges = PRIV_REGULAR) ){users[i].id = i;\n}\nreturn users;\n}\nint main(){user_t* test;\nint i;\ntest = Add_Regular_Users(25);\nfor(i = 0; i < 25; i++) printf(\"user %d has privilege level %d\\n\", test[i].id, test[i].privileges);\n}", "start_char_idx": 0, "end_char_idx": 865, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "646efacf-af6c-4a6d-9f42-aceea70f4ad2": {"__data__": {"id_": "646efacf-af6c-4a6d-9f42-aceea70f4ad2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "48258350-76fa-4167-b6cd-bae13c800e09", "node_type": "4", "metadata": {}, "hash": "ee3fe7b3b8335abb1547fd12e7671e54d7546685178f58c5f23fb86cb7453dff", "class_name": "RelatedNodeInfo"}}, "text": "CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nDescription :\nThe product performs reverse DNS resolution on an IP address to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname. \nExtended Description :\nSince DNS names can be easily spoofed or misreported, and it may be difficult for the product to detect if a trusted DNS server has been compromised, DNS names do not constitute a valid authentication mechanism. When the product performs a reverse DNS resolution for an IP address, if an attacker controls the DNS server for that IP address, then the attacker can cause the server to return an arbitrary hostname. As a result, the attacker may be able to bypass authentication, cause the wrong hostname to be recorded in log files to hide activities, or perform other attacks. Attackers can spoof DNS names by either (1) compromising a DNS server and modifying its records (sometimes called DNS cache poisoning), or (2) having legitimate control over a DNS server associated with their IP address. \nExample: 1\nC\n(bad code)\u00a0\nstruct hostent *hp;struct in_addr myaddr;\nchar* tHost = \"trustme.example.com\";\nmyaddr.s_addr=inet_addr(ip_addr_string);\nhp = gethostbyaddr((char *) &myaddr, sizeof(struct in_addr), AF_INET);\nif (hp && !strncmp(hp->h_name, tHost, sizeof(tHost))) {trusted = true;\n} else {trusted = false;\n}", "start_char_idx": 0, "end_char_idx": 1430, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34b2146f-5ea4-4c5e-8ae0-edf6deeadfc4": {"__data__": {"id_": "34b2146f-5ea4-4c5e-8ae0-edf6deeadfc4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "33da2ebd-e32d-40ba-ac2a-d174cc1e3ebe", "node_type": "4", "metadata": {}, "hash": "2978e5693e3789d455f630d456b268be700b18af6c7784677d692f64a011e7f6", "class_name": "RelatedNodeInfo"}}, "text": "CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nDescription :\nThe product uses an API function, data structure, or other entity in a way that relies on properties that are not always guaranteed to hold for that entity. \nExample: 1\nC\n(bad code)\u00a0\nint (*pt2Function) (float, char, char)=0x08040000;\nint result2 = (*pt2Function) (12, 'a', 'b');\n// Here we can inject code to execute.\nExample: 2\nC\n(bad code)\u00a0\nchar* getName() {char name[STR_MAX];\nfillInName(name);\nreturn name;\n}", "start_char_idx": 0, "end_char_idx": 506, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f30d40fb-eda5-4559-9745-444821221cf6": {"__data__": {"id_": "f30d40fb-eda5-4559-9745-444821221cf6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "73228003-e787-4615-a44d-033503047e99", "node_type": "4", "metadata": {}, "hash": "c256d7bd9a626d903e286c5d0ab51c5e8be471c9aae97bc1021d288d830f68d4", "class_name": "RelatedNodeInfo"}}, "text": "CWE-478: Missing Default Case in Multiple Condition Expression\nDescription :\nThe code does not have a default case in an expression with multiple conditions, such as a switch statement. \nExtended Description :\nIf a multiple-condition expression (such as a switch in C) omits the default case but does not consider or handle all possible values that could occur, then this might lead to complex logical errors and resultant weaknesses. Because of this, further decisions are made based on poor information, and cascading failure results. This cascading failure may result in any number of security issues, and constitutes a significant failure in the system. \nExemple bonus\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <stdlib.h>\n#define FAILED 0\n#define PASSED 1\nint main(int argc, char *argv[argc])\n{\nsrand(42);\nint result = rand() % 2;\nswitch (result) {\ncase FAILED:\n        printf(\"Security check failed!\\n\");\n        exit(-1);\n        //Break never reached because of exit()\n        break;\ncase PASSED:\n        printf(\"Security check passed.\\n\");\n        break;\n        //CWE-478: Missing Default Case in Multiple Condition Expression\n}\n        return 0;\n}\nExample: 1\nC\n(bad code)\u00a0\n#define FAILED 0\n#define PASSED 1\nint result;\n...\nresult = security_check(data);\nswitch (result) {\ncase FAILED:printf(\"Security check failed!\\n\");\nexit(-1);\n//Break never reached because of exit()\nbreak;\ncase PASSED:printf(\"Security check passed.\\n\");\nbreak;\n}\n// program execution continues...\n...\nExample: 2\nC\n(good code)\u00a0\n#define FAILED 0\n#define PASSED 1\nint result;\n...\nresult = security_check(data);\nswitch (result) {\ncase FAILED:printf(\"Security check failed!\\n\");\nexit(-1);\n//Break never reached because of exit()\nbreak;\ncase PASSED:printf(\"Security check passed.\\n\");\nbreak;\ndefault:printf(\"Unknown error (%d), exiting...\\n\",result);\nexit(-1);\n}\nExample: 3\nJava\n(bad code)\u00a0\npublic static final String INTEREST_RATE_AT_ZERO_POINTS = \"5.00\";\npublic static final String INTEREST_RATE_AT_ONE_POINTS = \"4.75\";\npublic static final String INTEREST_RATE_AT_TWO_POINTS = \"4.50\";\n...\npublic BigDecimal getInterestRate(int points) {\nBigDecimal result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\nswitch (points) {\ncase 0:result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\nbreak;\ncase 1:result = new BigDecimal(INTEREST_RATE_AT_ONE_POINTS);\nbreak;\ncase 2:result = new BigDecimal(INTEREST_RATE_AT_TWO_POINTS);\nbreak;\n        //CWE-478: Missing Default Case in Multiple Condition Expression\n}\nreturn result;\n}\nExample: 4\nJava\n(good code)\u00a0\npublic static final String INTEREST_RATE_AT_ZERO_POINTS = \"5.00\";\npublic static final String INTEREST_RATE_AT_ONE_POINTS = \"4.75\";\npublic static final String INTEREST_RATE_AT_TWO_POINTS = \"4.50\";\n...\npublic BigDecimal getInterestRate(int points) {\nBigDecimal result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\nswitch (points) {\ncase 0:result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\nbreak;\ncase 1:result = new BigDecimal(INTEREST_RATE_AT_ONE_POINTS);\nbreak;\ncase 2:result = new BigDecimal(INTEREST_RATE_AT_TWO_POINTS);\nbreak;\ndefault:System.err.println(\"Invalid value for points, must be 0, 1 or 2\"); //OK\nSystem.err.println(\"Returning null value for interest rate\");\nresult = null; \n}\nreturn result;\n}\nExample: 5\nPython\n(bad code)\u00a0\nresult = process_data(data)\nmatch result:\n                  case 0:\n                     print(\"Properly handle zero case.\")\ncase 1:\n                     print(\"Properly handle one case.\")\n/CWE-478: Missing Default Case in Multiple Condition Expression\n# program execution continues...", "start_char_idx": 0, "end_char_idx": 3553, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "69a4265d-3b93-45d3-8af6-69859f9e568b": {"__data__": {"id_": "69a4265d-3b93-45d3-8af6-69859f9e568b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4434854c-9367-4f0e-b2be-f7c2221adc4b", "node_type": "4", "metadata": {}, "hash": "aa2d9418ec8872d299ba882b8dcdea8d99c08ecf67661f45256d300e9738e904", "class_name": "RelatedNodeInfo"}}, "text": "CWE-562: Return of Stack Variable Address\nDescription :\nA function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash. \nExtended Description :\nBecause local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced. \nExample: 1\nC\n(bad code)\u00a0\nchar* getName() {char name[STR_MAX];\nfillInName(name);\nreturn name;\n}", "start_char_idx": 0, "end_char_idx": 837, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f672f72-a271-4818-91fc-75d665313048": {"__data__": {"id_": "2f672f72-a271-4818-91fc-75d665313048", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "72d10b89-eb31-4cb8-9c01-b03f54b44249", "node_type": "4", "metadata": {}, "hash": "aa36d8d28d53b5d0f6276da6326b71b8c4bdb2707f6171c5f86c16be92e2bfc9", "class_name": "RelatedNodeInfo"}}, "text": "CWE-663: Use of a Non-reentrant Function in a Concurrent Context\nDescription :\nThe product calls a non-reentrant function in a concurrent context in which a competing code sequence (e.g. thread or signal handler) may have an opportunity to call the same function or otherwise influence its state. \nExample: 1\nC\n(bad code)\u00a0\npwd = getpwnam(getlogin());\nif (isTrustedGroup(pwd->pw_gid)) {allow();\n} else {deny();\n}", "start_char_idx": 0, "end_char_idx": 411, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c5dddb36-bd7f-44c5-b793-174ddd23c71e": {"__data__": {"id_": "c5dddb36-bd7f-44c5-b793-174ddd23c71e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17758270-c0e7-47dc-988c-4002cbf424be", "node_type": "4", "metadata": {}, "hash": "37d70966ec75c923f0fde9638c7e7d0d8fb9ca98601516cf418034bdffd411c7", "class_name": "RelatedNodeInfo"}}, "text": "CWE-703: Improper Check or Handling of Exceptional Conditions\nDescription :\nThe product does not properly anticipate or handle exceptional conditions that rarely occur during normal operation of the product. \nExample: 1\nC\n(bad code)\u00a0\nchar buf[10], cp_buf[10];\nfgets(buf, 10, stdin);\nstrcpy(cp_buf, buf);\nExample: 2\nJava\n(good code)\u00a0\npublic void doExchange() throws IOException, InvocationTargetException, SQLException {...\n}", "start_char_idx": 0, "end_char_idx": 424, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d42b69b5-696f-4b08-846d-bf9a21345083": {"__data__": {"id_": "d42b69b5-696f-4b08-846d-bf9a21345083", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6acf0f39-2664-4b48-a183-7ebdc425a1bb", "node_type": "4", "metadata": {}, "hash": "ee42609eaf48ddc09747273bbacc1fbdc8085ba2a5a34483db76f6859ff22fd1", "class_name": "RelatedNodeInfo"}}, "text": "CWE-467: Use of sizeof() on a Pointer Type\nDescription :\nThe code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated. \nExtended Description :\nThe use of sizeof() on a pointer can sometimes generate useful information. An obvious case is to find out the wordsize on a platform. More often than not, the appearance of sizeof(pointer) indicates a bug. \nExample: 1\nC\n(bad code)\u00a0\ndouble *foo;\n...\nfoo = (double *)malloc(sizeof(foo));\nExample: 2\nC\n(good code)\u00a0\ndouble *foo;\n...\nfoo = (double *)malloc(sizeof(*foo));\nExemple bonus \nC\n(good code)\u00a0\nint main() {\n    char *a;\n    a = (char *)malloc(sizeof(a) * 100); // Mauvais: sizeof(a) retourne la taille du pointeur, pas le type point\u00e9\n    strcpy(a, \"exemple de texte\");\n    printf(\"%s\\n\", a);\n    free(a);\n    int *b;\n    b = (int *)malloc(sizeof(b) * 25); // Mauvais: sizeof(b) retourne la taille du pointeur, pas le type point\u00e9\n    for (int i = 0; i < 25; i++) {\n        b[i] = i;\n    }\n    for (int i = 0; i < 25; i++) {\n        printf(\"%d \", b[i]);\n    }\n    free(b);\n    return 0;\n}\nExemple bonus \nC\n(good code)\u00a0\n#include <stdio.h>\n#include <stdlib.h>\ntypedef struct {\n    int id;\n    char name[100];\n} Item;\nint main() {\n    Item *ptr;\n    // Allocation incorrecte : sizeof(ptr) au lieu de sizeof(*ptr) ou sizeof(Item)\n    ptr = (Item *)malloc(sizeof(ptr)); // Mauvais: Alloue la taille du pointeur, pas de la structure\n    // Tentative d'utilisation de la m\u00e9moire allou\u00e9e\n    ptr->id = 1;\n    snprintf(ptr->name, sizeof(ptr->name), \"Nom de l'item\");\n    printf(\"ID: %d, Name: %s\\n\", ptr->id, ptr->name);\n    // Lib\u00e9ration de la m\u00e9moire\n    free(ptr);\n    return 0;\n}", "start_char_idx": 0, "end_char_idx": 1760, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "523f5a89-5d59-4470-b448-224a1e0cfdb7": {"__data__": {"id_": "523f5a89-5d59-4470-b448-224a1e0cfdb7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0d14f415-4b38-4518-8dae-455008022f25", "node_type": "4", "metadata": {}, "hash": "eb508b498e20cb7b7dd2b11d123e7dbc8da07a7efdb436077d9eaa0905135dfc", "class_name": "RelatedNodeInfo"}}, "text": "CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nDescription :\nThe product uses a broken or risky cryptographic algorithm or protocol. \nExtended Description :\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts. It is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected. Since the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought. For a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time. \nExample: 1\nC\n(bad code)\u00a0\nEVP_des_ecb();\nExample: 2\nJava\n(bad code)\u00a0\nCipher des=Cipher.getInstance(\"DES...\");\ndes.initEncrypt(key2);\nExample: 3\nPHP\n(bad code)\u00a0\nfunction encryptPassword($password){$iv_size = mcrypt_get_iv_size(MCRYPT_DES, MCRYPT_MODE_ECB);\n$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);\n$key = \"This is a password encryption key\";\n$encryptedPassword = mcrypt_encrypt(MCRYPT_DES, $key, $password, MCRYPT_MODE_ECB, $iv);\nreturn $encryptedPassword;\n}", "start_char_idx": 0, "end_char_idx": 2290, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ffa4832-66a9-4dbf-b27a-3722873587c0": {"__data__": {"id_": "4ffa4832-66a9-4dbf-b27a-3722873587c0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c711c7f-ff23-40c5-bd38-eb70598b4a1e", "node_type": "4", "metadata": {}, "hash": "009f928fcbbef2304eec165d1ea7c2161319bd120d97ade9bb5a96dafa9e2562", "class_name": "RelatedNodeInfo"}}, "text": "CWE-187: Partial String Comparison\nDescription :\nThe product performs a comparison that only examines a portion of a factor before determining whether there is a match, such as a substring, leading to resultant weaknesses. \nExtended Description :\nFor example, an attacker might succeed in authentication by providing a small password that matches the associated portion of the larger, correct password. \nExample: 1\nC\n(bad code)\u00a0\n/* Ignore CWE-259 (hard-coded password) and CWE-309 (use of password system for authentication) for this example. */ \nchar *username = \"admin\";\nchar *pass = \"password\";\nint AuthenticateUser(char *inUser, char *inPass) {if (strncmp(username, inUser, strlen(inUser))) {logEvent(\"Auth failure of username using strlen of inUser\");\nreturn(AUTH_FAIL);\n}\nif (! strncmp(pass, inPass, strlen(inPass))) {logEvent(\"Auth success of password using strlen of inUser\");\nreturn(AUTH_SUCCESS);\n}\nelse {logEvent(\"Auth fail of password using sizeof\");\nreturn(AUTH_FAIL);\n}\n}\nint main (int argc, char **argv) {\nint authResult;\nif (argc < 3) {ExitError(\"Usage: Provide a username and password\");\n}\nauthResult = AuthenticateUser(argv[1], argv[2]);\nif (authResult == AUTH_SUCCESS) {DoAuthenticatedTask(argv[1]);\n}\nelse {ExitError(\"Authentication failed\");\n}\n}", "start_char_idx": 0, "end_char_idx": 1266, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ebbcc25-4af3-47f4-a58d-002e33921b0d": {"__data__": {"id_": "4ebbcc25-4af3-47f4-a58d-002e33921b0d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f21175c6-424b-4b64-958a-8f21186e4afa", "node_type": "4", "metadata": {}, "hash": "385ea794058573d87ca49fd900e608c6cf47e2096d7eb897820bac376ce2663d", "class_name": "RelatedNodeInfo"}}, "text": "CWE-1078: Inappropriate Source Code Style or Formatting\nDescription :\nThe source code does not follow desired style or formatting for indentation, white space, comments, etc. \nExample: 1\nC\n(bad code)\u00a0\nchar buffer[1024];\n...\nfgets(buffer, 1024, stdin);", "start_char_idx": 0, "end_char_idx": 251, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a60c5149-5566-44e2-939c-6306e2bed813": {"__data__": {"id_": "a60c5149-5566-44e2-939c-6306e2bed813", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6a59186f-e4e9-45db-b3bc-f85efd26cc7e", "node_type": "4", "metadata": {}, "hash": "235d67be93839c380307c3035a25274e144efad37bfd97349cce3a507d6544d5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-344: Use of Invariant Value in Dynamically Changing Context\nDescription :\nThe product uses a constant value, name, or reference, but this value can (or should) vary across different environments. \nExample: 1\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {\nif (strcmp(password, \"Mew!\")) {\n                                 printf(\"Incorrect Password!\\n\");\nreturn(0)\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}\nExample: 2\nJava\n(bad code)\u00a0\nint VerifyAdmin(String password) {if (!password.equals(\"Mew!\")) {return(0)\n}\n//Diagnostic Mode\nreturn(1);\n}", "start_char_idx": 0, "end_char_idx": 559, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12cafe24-5da5-4457-84bb-6a19b54c959f": {"__data__": {"id_": "12cafe24-5da5-4457-84bb-6a19b54c959f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2531f001-a201-4dd6-af9c-3e29d31ca7dc", "node_type": "4", "metadata": {}, "hash": "8a99e574cd6acd456836d453cfa2235789283f0db5b6d5dbdd25d928ec260f9f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-252: Unchecked Return Value\nDescription :\nThe product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions. \nExtended Description :\nTwo common programmer assumptions are \"this function call can never fail\" and \"it doesn't matter if this function call fails\". If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the product is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges. \nExample: 1\nC\n(bad code)\u00a0\nchar buf[10], cp_buf[10];\nfgets(buf, 10, stdin);\nstrcpy(cp_buf, buf);\nExample: 2\nC\n(bad code)\u00a0\nint returnChunkSize(void *) {\n/* if chunk info is valid, return the size of usable memory,\n* else, return -1 to indicate an error\n*/\n...\n}\nint main() {...\nmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n...\n}\nExample: 3\nC\n(bad code)\u00a0\nbuf = (char*) malloc(req_size);\nstrncpy(buf, xfer, req_size);\nExample: 4\nC#\n(bad code)\u00a0\nchar[] byteArray = new char[1024];\nfor (IEnumerator i=users.GetEnumerator(); i.MoveNext() ;i.Current()) {String userName = (String) i.Current();\nString pFileName = PFILE_ROOT + \"/\" + userName;\nStreamReader sr = new StreamReader(pFileName);\nsr.Read(byteArray,0,1024);//the file is always 1k bytes\nsr.Close();\nprocessPFile(userName, byteArray);\n}\nExample: 5\nJava\n(bad code)\u00a0\nFileInputStream fis;\nbyte[] byteArray = new byte[1024];\nfor (Iterator i=users.iterator(); i.hasNext();) {\nString userName = (String) i.next();\nString pFileName = PFILE_ROOT + \"/\" + userName;\nFileInputStream fis = new FileInputStream(pFileName);\nfis.read(byteArray); // the file is always 1k bytes\nfis.close();\nprocessPFile(userName, byteArray);\nExample: 6\nJava\n(bad code)\u00a0\nString itemName = request.getParameter(ITEM_NAME);\nif (itemName.compareTo(IMPORTANT_ITEM) == 0) {...\n}\n...\nExample: 7\nJava\n(bad code)\u00a0\nString itemName = request.Item(ITEM_NAME);\nif (itemName.Equals(IMPORTANT_ITEM)) {...\n}\n...\nExample: 8\nJava\n(bad code)\u00a0\nSystem.clearProperty(\"os.name\");\n...\nString os = System.getProperty(\"os.name\");\nif (os.equalsIgnoreCase(\"Windows 95\")) System.out.println(\"Not supported\");\nExample: 9\nC#\n(bad code)\u00a0\nDim MyFile As New FileStream(\"myfile.txt\", FileMode.Open, FileAccess.Read, FileShare.Read)\nDim MyArray(50) As Byte\nMyFile.Read(MyArray, 0, 50)\nDoDangerousOperation(MyArray(20))\nExample: 10\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}", "start_char_idx": 0, "end_char_idx": 3012, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27c12973-f4e5-490d-8021-e263eb8d537a": {"__data__": {"id_": "27c12973-f4e5-490d-8021-e263eb8d537a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e9d15365-a661-4a07-bdc1-013e8a80f126", "node_type": "4", "metadata": {}, "hash": "17079147211d519e491320868353aa33bcd3a6b256f2e562d5904cf59590fcf3", "class_name": "RelatedNodeInfo"}}, "text": "CWE-695: Use of Low-Level Functionality\nDescription :\nThe product uses low-level functionality that is explicitly prohibited by the framework or specification under which the product is supposed to operate. \nExample: 1\nJava\n(bad code)\u00a0\nclass Echo {\npublic native void runEcho();\nstatic {\nSystem.loadLibrary(\"echo\");\n}\npublic static void main(String[] args) {\nnew Echo().runEcho();\n}\n}\nExample: 2\nC\n(bad code)\u00a0\n#include <jni.h>\n#include \"Echo.h\"//the java class above compiled with javah\n#include <stdio.h>\nJNIEXPORT void JNICALL\nJava_Echo_runEcho(JNIEnv *env, jobject obj)\n{char buf[64];\ngets(buf);\nprintf(buf);\n}", "start_char_idx": 0, "end_char_idx": 613, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e458261a-a397-43af-a5e8-4e6ae2eb564b": {"__data__": {"id_": "e458261a-a397-43af-a5e8-4e6ae2eb564b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b621d243-0fc9-494a-8fda-4a32e6f52a23", "node_type": "4", "metadata": {}, "hash": "0163276c1f3815b0bf0911719c5ae8400c2452213f256e0ea4c3eabd0a6c9fbe", "class_name": "RelatedNodeInfo"}}, "text": "CWE-259: Use of Hard-coded Password\nDescription :\nThe product contains a hard-coded password, which it uses for its own inbound authentication or for outbound communication to external components. \nExtended Description :\nA hard-coded password typically leads to a significant authentication failure that can be difficult for the system administrator to detect. Once detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the product contains an authentication mechanism that checks for a hard-coded password. Outbound: the product connects to another system or component, and it contains hard-coded password for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple. \nExample: 1\nJava\n(bad code)\u00a0\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\nExample: 2\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {\nif (strcmp(password, \"Mew!\")) {\n                                 printf(\"Incorrect Password!\\n\");\nreturn(0)\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}\nExample: 3\nJava\n(bad code)\u00a0\nint VerifyAdmin(String password) {if (!password.equals(\"Mew!\")) {return(0)\n}\n//Diagnostic Mode\nreturn(1);\n}", "start_char_idx": 0, "end_char_idx": 2363, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cee367f0-e76c-408d-b541-05e1c5eb2358": {"__data__": {"id_": "cee367f0-e76c-408d-b541-05e1c5eb2358", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e3417fe4-bc5f-4c5a-9f49-7b002c7cb787", "node_type": "4", "metadata": {}, "hash": "879a5a72db17d4a1b91d0c6587f53ee35cce367585e426103f55604d1d327b2f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-257: Storing Passwords in a Recoverable Format\nDescription :\nThe storage of passwords in a recoverable format makes them subject to password reuse attacks by malicious users. In fact, it should be noted that recoverable encrypted passwords provide no significant benefit over plaintext passwords since they are subject not only to reuse by malicious attackers but also by malicious insiders. If a system administrator can recover a password directly, or use a brute force search on the available information, the administrator can use the password on other accounts. \nExample: 1\nC\n(bad code)\u00a0\nint VerifyAdmin(char *password) {if (strcmp(compress(password), compressed_password)) {printf(\"Incorrect Password!\\n\");\nreturn(0);\n}\nprintf(\"Entering Diagnostic Mode...\\n\");\nreturn(1);\n}", "start_char_idx": 0, "end_char_idx": 783, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "58e64269-15a9-4777-aa73-26465e12b76c": {"__data__": {"id_": "58e64269-15a9-4777-aa73-26465e12b76c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "402fe40b-9634-47e3-a037-049bc76075e1", "node_type": "4", "metadata": {}, "hash": "9c2cc3d901f0567bf9a642c35ca66456e84c41eb68c1c8ae4717141fb1f9497f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-121: Stack-based Buffer Overflow\nDescription :\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function). \nExample: 1\nC\n(bad code)\u00a0\n#define BUFSIZE 256\nint main(int argc, char **argv) {char buf[BUFSIZE];\nstrcpy(buf, argv[1]);\n}\nExample: 2\nC\n(bad code)\u00a0\nvoid host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n/*routine that ensures user_supplied_addr is in the right format for conversion */\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}", "start_char_idx": 0, "end_char_idx": 770, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97afab4b-43f6-44ef-8ae9-4e43c97259cc": {"__data__": {"id_": "97afab4b-43f6-44ef-8ae9-4e43c97259cc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a355d13d-c35f-4495-a9c1-d5c467ca07bc", "node_type": "4", "metadata": {}, "hash": "d86d5f3a116eb954087b4a1a1728515e17dc087ad6a5657fbf67814141b4ac06", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b6484a01-873f-44b7-b1e9-0208c41590f1", "node_type": "1", "metadata": {}, "hash": "89f64b1dc3e222623b68ebf42fbae7c8e94ad5510ee884ee28f96d303e57c72f", "class_name": "RelatedNodeInfo"}}, "text": "CWE-20: Improper Input Validation\nDescription :\nThe product receives input or data, but it does not validate or incorrectly validates that the input has the properties that are required to process the data safely and correctly. \nExtended Description :\nInput validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution. Input validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.) Input validation can be applied to: raw data - strings, numbers, parameters, file contents, etc. metadata - information about the raw data, such as headers or size Data can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data. Many properties of raw data or metadata may need to be validated upon entry into the code, such as: specified quantities such as size, length, frequency, price, rate, number of operations, time, etc. implied or derived quantities, such as the actual size of a file instead of a specified size indexes, offsets, or positions into more complex data structures symbolic keys or other elements into hash tables, associative arrays, etc. well-formedness, i.e. syntactic correctness - compliance with expected syntax lexical token correctness - compliance with rules for what is treated as a token specified or derived type - the actual type of the input (or what the input appears to be) consistency - between individual data elements, between raw data and metadata, between references, etc. conformance to domain-specific rules, e.g. business logic equivalence - ensuring that equivalent inputs are treated the same authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data Implied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. Note that \"input validation\" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation. Finally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. \nExample: 2\nC\n(bad code)\u00a0\n...\n#define MAX_DIM 100\n...\n/* board dimensions */\nint m,n, error;\nboard_square_t *board;\nprintf(\"Please specify the board height: \\n\");\nerror = scanf(\"%d\", &m);\nif ( EOF == error ){die(\"No integer passed: Die evil hacker!\\n\");\n}\nprintf(\"Please specify the board width: \\n\");\nerror = scanf(\"%d\", &n);\nif ( EOF == error ){die(\"No integer passed: Die evil hacker!\\n\");\n}\nif ( m > MAX_DIM || n > MAX_DIM ) {die(\"Value too large: Die evil hacker!\\n\");\n}\nboard = (board_square_t*) malloc( m * n * sizeof(board_square_t));\n...\nExemple bonus \nC\n(bad code)\n#include <stdio.h>\n/*This function attempts to extract a pair of numbers from a user-supplied string.", "start_char_idx": 0, "end_char_idx": 4782, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6484a01-873f-44b7-b1e9-0208c41590f1": {"__data__": {"id_": "b6484a01-873f-44b7-b1e9-0208c41590f1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a355d13d-c35f-4495-a9c1-d5c467ca07bc", "node_type": "4", "metadata": {}, "hash": "d86d5f3a116eb954087b4a1a1728515e17dc087ad6a5657fbf67814141b4ac06", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "97afab4b-43f6-44ef-8ae9-4e43c97259cc", "node_type": "1", "metadata": {}, "hash": "872481f56d9bbdc567b45cc0da0d585515030d8d2dd1ddf9ece5b5cbc5d63f43", "class_name": "RelatedNodeInfo"}}, "text": "Example: 2\nC\n(bad code)\u00a0\n...\n#define MAX_DIM 100\n...\n/* board dimensions */\nint m,n, error;\nboard_square_t *board;\nprintf(\"Please specify the board height: \\n\");\nerror = scanf(\"%d\", &m);\nif ( EOF == error ){die(\"No integer passed: Die evil hacker!\\n\");\n}\nprintf(\"Please specify the board width: \\n\");\nerror = scanf(\"%d\", &n);\nif ( EOF == error ){die(\"No integer passed: Die evil hacker!\\n\");\n}\nif ( m > MAX_DIM || n > MAX_DIM ) {die(\"Value too large: Die evil hacker!\\n\");\n}\nboard = (board_square_t*) malloc( m * n * sizeof(board_square_t));\n...\nExemple bonus \nC\n(bad code)\n#include <stdio.h>\n/*This function attempts to extract a pair of numbers from a user-supplied string.*/\nvoid parse_data(char *untrusted_input){\n    int m,n,error;\n    error=sscanf(untrusted_input,\"%d:%d\",&m,&n);\n    if (EOF == error){\n        printf(\"Did not specify integer value. Die evil hacker!\\n\");\n    }\n    printf(\"m is %d and n is %d\",m,n);\n}\nint main(){\n    parse_data(\"123:\");\n    return 0;\n}\nExample: 1\nJava\n(bad code)\u00a0\n...\npublic static final double price = 20.00;\nint quantity = currentUser.getAttribute(\"quantity\");\ndouble total = price * quantity;\nchargeUser(total);\n...\nExample: 3\nPHP\n(bad code)\u00a0\n$birthday = $_GET['birthday'];\n$homepage = $_GET['homepage'];\necho \"Birthday: $birthday<br>Homepage: <a href=$homepage>click here</a>\"\nExample: 4\nJava\n(bad code)\u00a0\nprivate void buildList ( int untrustedListSize ){if ( 0 > untrustedListSize ){die(\"Negative value supplied for list size, die evil hacker!\");\n}\nWidget[] list = new Widget [ untrustedListSize ];\nlist[0] = new Widget();\n}", "start_char_idx": 4107, "end_char_idx": 5676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e2f712ad-6951-4f00-adf8-32babc2f3230": {"__data__": {"id_": "e2f712ad-6951-4f00-adf8-32babc2f3230", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0d76b273-6e97-4b3d-aab6-4c6a4342ecb1", "node_type": "4", "metadata": {}, "hash": "9d04f7239fe876631dc720182e3c114366ffb21a2591690fc1a5a38c685c78ea", "class_name": "RelatedNodeInfo"}}, "text": "CWE-464: Addition of Data Structure Sentinel\nDescription :\nThe accidental addition of a data-structure sentinel can cause serious programming logic problems. \nExtended Description :\nData-structure sentinels are often used to mark the structure of data. A common example of this is the null character at the end of strings or a special sentinel to mark the end of a linked list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the addition or modification of sentinels. \nExample: 1\nC\n(bad code)\u00a0\nchar *foo;\nfoo=malloc(sizeof(char)*5);\nfoo[0]='a';\nfoo[1]='a';\nfoo[2]=atoi(getc(stdin));\nfoo[3]='c';\nfoo[4]='\\0'\nprintf(\"%c %c %c %c %c \\n\",foo[0],foo[1],foo[2],foo[3],foo[4]);\nprintf(\"%s\\n\",foo);", "start_char_idx": 0, "end_char_idx": 762, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "14beb169-576e-44ed-9393-8b7cd1da657c": {"__data__": {"id_": "14beb169-576e-44ed-9393-8b7cd1da657c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6c407c51-3177-4082-bb99-bcf26f067b6f", "node_type": "4", "metadata": {}, "hash": "7c0cb497c589404956a2c94a343ef43ca0cd1f22ea228a19b2c3026f2c75726a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-244: Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nDescription :\nUsing realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory. \nExtended Description :\nWhen sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a \"heap inspection\" attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed. \nExample: 1\nC\n(bad code)\u00a0\ncleartext_buffer = get_secret();...\ncleartext_buffer = realloc(cleartext_buffer, 1024);\n...\nscrub_memory(cleartext_buffer, 1024);", "start_char_idx": 0, "end_char_idx": 1125, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7e64662b-9397-4871-900d-e40ed842e5ba": {"__data__": {"id_": "7e64662b-9397-4871-900d-e40ed842e5ba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "dfd585fd-2aeb-42fe-83d6-b647a023dcca", "node_type": "4", "metadata": {}, "hash": "cf36f7c9d9cbc176eae400f3eb7d9efd2111cf6755b074e5b9e1eab77a553a5e", "class_name": "RelatedNodeInfo"}}, "text": "CWE-131: Incorrect Calculation of Buffer Size\nDescription :\nThe product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow. \nExample: 1\nC\n(bad code)\u00a0\nint i;\nunsigned int numWidgets;\nWidget **WidgetList;\nnumWidgets = GetUntrustedSizeValue();\nif ((numWidgets == 0) || (numWidgets > MAX_NUM_WIDGETS)) {ExitError(\"Incorrect number of widgets requested!\");\n}\nWidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));\nprintf(\"WidgetList ptr=%p\\n\", WidgetList);\nfor(i=0; i<numWidgets; i++) {WidgetList[i] = InitializeWidget();\n}\nWidgetList[numWidgets] = NULL;\nshowWidgets(WidgetList);\nExample: 2\nC\n(bad code)\u00a0\nimg_t table_ptr; /*struct containing img data, 10kB each*/\nint num_imgs;\n...\nnum_imgs = get_num_imgs();\ntable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n...\nExample: 3\nC\n(bad code)\u00a0\nchar * copy_input(char *user_supplied_string){\nint i, dst_index;\nchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\nif ( MAX_SIZE <= strlen(user_supplied_string) ){die(\"user string too long, die evil hacker!\");\n}\ndst_index = 0;\nfor ( i = 0; i < strlen(user_supplied_string); i++ ){\nif( '&' == user_supplied_string[i] ){dst_buf[dst_index++] = '&';\ndst_buf[dst_index++] = 'a';\ndst_buf[dst_index++] = 'm';\ndst_buf[dst_index++] = 'p';\ndst_buf[dst_index++] = ';';\n}\nelse if ('<' == user_supplied_string[i] ){\n/* encode to &lt; */\n}\nelse dst_buf[dst_index++] = user_supplied_string[i];\n}\nreturn dst_buf;\n}\nExample: 4\nC\n(bad code)\u00a0\nDataPacket *packet;\nint numHeaders;\nPacketHeader *headers;\nsock=AcceptSocketConnection();\nReadPacket(packet, sock);\nnumHeaders =packet->headers;\nif (numHeaders > 100) {ExitError(\"too many headers!\");\n}\nheaders = malloc(numHeaders * sizeof(PacketHeader);\nParsePacketHeaders(packet, headers);\nExample: 5\nC\n(bad code)\u00a0\nint *id_sequence;\n/* Allocate space for an array of three ids. */\nid_sequence = (int*) malloc(3);\nif (id_sequence == NULL) exit(1);\n/* Populate the id array. */\nid_sequence[0] = 13579;\nid_sequence[1] = 24680;\nid_sequence[2] = 97531;", "start_char_idx": 0, "end_char_idx": 2035, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ebe0791b-8306-4fbc-a1d3-14ce70c92eee": {"__data__": {"id_": "ebe0791b-8306-4fbc-a1d3-14ce70c92eee", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c967c1c-a8b9-4078-b929-e41ea71ac58c", "node_type": "4", "metadata": {}, "hash": "8bbc51bc3947be3931262379bb23975ea8c9085e598e82aebc94cac3fff7614a", "class_name": "RelatedNodeInfo"}}, "text": "CWE-126: Buffer Over-read\nDescription :\nThe product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer. \nExtended Description :\nThis typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash. \nExample: 1\nC\n(bad code)\u00a0\nint processMessageFromSocket(int socket) {\nint success;\nchar buffer[BUFFER_SIZE];\nchar message[MESSAGE_SIZE];\n// get message from socket and store into buffer\n//Ignoring possibliity that buffer > BUFFER_SIZE\nif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n// place contents of the buffer into message structure\nExMessage *msg = recastBuffer(buffer);\n// copy message body into string for processing\nint index;\nfor (index = 0; index < msg->msgLength; index++) {message[index] = msg->msgBody[index];\n}\nmessage[index] = '\\0';\n// process message\nsuccess = processMessage(message);\n}\nreturn success;\n}\nExample: 2\nC\n(bad code)\u00a0\nint main(int argc, char **argv)\n{\nchar Filename[256];\nchar Pattern[32];\n/* Validate number of parameters and ensure valid content */\n...\n/* copy filename parameter to variable, may cause off-by-one overflow */\nstrncpy(Filename, argv[1], sizeof(Filename));\n/* copy pattern parameter to variable, may cause off-by-one overflow */\nstrncpy(Pattern, argv[2], sizeof(Pattern));\nprintf(\"Searching file: %s for the pattern: %s\\n\", Filename, Pattern);\nScan_File(Filename, Pattern);\n}", "start_char_idx": 0, "end_char_idx": 1626, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "80b2ce00-1fb2-46f9-98b6-e66bbd50d2ca": {"__data__": {"id_": "80b2ce00-1fb2-46f9-98b6-e66bbd50d2ca", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a76799eb-c710-40b2-b21d-a601ca7a2d6c", "node_type": "4", "metadata": {}, "hash": "ba09b967cd80e28f45a0b3ecfb2d3ec9267c67f26e0a33d0aeda82bf36de0144", "class_name": "RelatedNodeInfo"}}, "text": "CWE-307: Improper Restriction of Excessive Authentication Attempts\nDescription :\nThe product does not implement sufficient measures to prevent multiple failed authentication attempts within a short time frame, making it more susceptible to brute force attacks. \nExample: 3\nC\n(bad code)\u00a0\nint validateUser(char *host, int port)\n{\nint socket = openSocketConnection(host, port);\nif (socket < 0) {printf(\"Unable to open socket connection\");\nreturn(FAIL);\n}\nint isValidUser = 0;\nchar username[USERNAME_SIZE];\nchar password[PASSWORD_SIZE];\nwhile (isValidUser == 0) {\nif (getNextMessage(socket, username, USERNAME_SIZE) > 0) {if (getNextMessage(socket, password, PASSWORD_SIZE) > 0) {isValidUser = AuthenticateUser(username, password);\n}\n}\n}\nreturn(SUCCESS);\n}", "start_char_idx": 0, "end_char_idx": 752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a00bd1cd-1b65-4582-9884-dfebbc5691a0": {"__data__": {"id_": "a00bd1cd-1b65-4582-9884-dfebbc5691a0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ae24197c-ac35-457e-986a-db3417e71d36", "node_type": "4", "metadata": {}, "hash": "875516016558388173dac168493531a16d6a3f232cf3975590a0c913936c61dc", "class_name": "RelatedNodeInfo"}}, "text": "CWE-323: Reusing a Nonce, Key Pair in Encryption\nDescription :\nNonces should be used for the present occasion and only once. \nExample: 1\nC\n(bad code)\u00a0\nvoid encryptAndSendPassword(char *password){char *nonce = \"bad\";\n...\nchar *data = (unsigned char*)malloc(20);\nint para_size = strlen(nonce) + strlen(password);\nchar *paragraph = (char*)malloc(para_size);\nSHA1((const unsigned char*)paragraph,parsize,(unsigned char*)data);\nsendEncryptedData(data)\n}\nExample: 2\nC++\n(bad code)\u00a0\nString command = new String(\"some command to execute\");\nMessageDigest nonce = MessageDigest.getInstance(\"SHA\");\nnonce.update(String.valueOf(\"bad nonce\"));\nbyte[] nonce = nonce.digest();\nMessageDigest password = MessageDigest.getInstance(\"SHA\");\npassword.update(nonce + \"secretPassword\");\nbyte[] digest = password.digest();\nsendCommand(digest, command)", "start_char_idx": 0, "end_char_idx": 827, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "db8ad31e-dd89-4e7b-ac26-db5e41dcd890": {"__data__": {"id_": "db8ad31e-dd89-4e7b-ac26-db5e41dcd890", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5be4c870-821d-4623-928b-9bbfc104d08f", "node_type": "4", "metadata": {}, "hash": "89c1250a4b3c713dee5ced2f683dc071bfac294dfaa1485c73a03ca728798cde", "class_name": "RelatedNodeInfo"}}, "text": "CWE-558: Use of getlogin() in Multithreaded Application\nDescription :\nThe product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values. \nExtended Description :\nThe getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted. \nExample: 1\nC\n(bad code)\u00a0\npwd = getpwnam(getlogin());\nif (isTrustedGroup(pwd->pw_gid)) {allow();\n} else {deny();\n}", "start_char_idx": 0, "end_char_idx": 769, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6af41ec4-1565-4b51-b0df-eb3b84d54150": {"__data__": {"id_": "6af41ec4-1565-4b51-b0df-eb3b84d54150", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "da5d409b-7c47-47fd-9955-4bb79c6df24c", "node_type": "4", "metadata": {}, "hash": "7555861697fbb9300f46b9af5a067ff2f55000adb6e359faf697cd172d3b6e20", "class_name": "RelatedNodeInfo"}}, "text": "CWE-665: Improper Initialization\nDescription :\nThe product does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used. \nExtended Description :\nThis can have security implications when the associated resource is expected to have certain properties or values, such as a variable that determines whether a user has been authenticated or not. \nExample: 1\nC\n(bad code)\u00a0\nchar str[20];\nstrcat(str, \"hello world\");\nprintf(\"%s\", str);", "start_char_idx": 0, "end_char_idx": 507, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c97c0258-8bd8-4197-bb65-9aa913f0fc25": {"__data__": {"id_": "c97c0258-8bd8-4197-bb65-9aa913f0fc25", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cb9ea2e3-17e9-4a63-b60d-b18b25eaf6ec", "node_type": "4", "metadata": {}, "hash": "00e1198ca8379a765c1cbe35ef61c2765fe0847002c17d86610a656f97f83ed5", "class_name": "RelatedNodeInfo"}}, "text": "CWE-309: Use of Password System for Primary Authentication\nDescription :\nThe use of password systems as the primary means of authentication may be subject to several flaws or shortcomings, each reducing the effectiveness of the mechanism. \nExample: 1\nC\n(bad code)\u00a0\nunsigned char *check_passwd(char *plaintext) {ctext = simple_digest(\"sha1\",plaintext,strlen(plaintext), ... );\n//Login if hash matches stored hash\nif (equal(ctext, secret_password())) {login_user();\n}\n}", "start_char_idx": 0, "end_char_idx": 467, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bc876dc0-eed3-4ab6-a914-b3e9e8f70aeb": {"__data__": {"id_": "bc876dc0-eed3-4ab6-a914-b3e9e8f70aeb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0c7a9cac-5c95-4186-842b-c8bc49e72b5c", "node_type": "4", "metadata": {}, "hash": "58d5c64c56ce7b265a4c574b4ecb806126d9401995f7aa8e7ce805c59ae27950", "class_name": "RelatedNodeInfo"}}, "text": "CWE-378: Creation of Temporary File With Insecure Permissions\nDescription :\nOpening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack. \nExample: 1\nC\n(bad code)\u00a0\nFILE *stream;\nif( (stream = tmpfile()) == NULL ) {\nperror(\"Could not open new temporary file\\n\");\nreturn (-1);\n}\n// write data to tmp file\n...\n// remove tmp file\nrmtmp();", "start_char_idx": 0, "end_char_idx": 425, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36a84414-001e-436b-bd7b-983b46d678bd": {"__data__": {"id_": "36a84414-001e-436b-bd7b-983b46d678bd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bc55620b-1b33-4da4-8eb3-bc237bd7fb1c", "node_type": "4", "metadata": {}, "hash": "743c492c75cfc3a56e85a5b50b5e1308e5f69a4aa83a24d84f6f8b9426810e55", "class_name": "RelatedNodeInfo"}}, "text": "CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\nDescription :\nThe product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component. \nExtended Description :\nCommand injection vulnerabilities typically occur when: 1. Data enters the application from an untrusted source. 2. The data is part of a string that is executed as a command by the application. 3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. Many protocols and products have their own custom command language. While OS or shell command strings are frequently discovered and targeted, developers may not realize that these other command languages might also be vulnerable to attacks. Command injection is a common problem with wrapper programs. \nExample: 1\nC\n(bad code)\u00a0\nint main(int argc, char** argv) {char cmd[CMD_MAX] = \"/usr/bin/cat \";\nstrcat(cmd, argv[1]);\nsystem(cmd);\n}\nExample: 2\nJava\n(bad code)\u00a0\n...\nString btype = request.getParameter(\"backuptype\");\nString cmd = new String(\"cmd.exe /K \\\"c:\\\\util\\\\rmanDB.bat \"\n+btype+\n\"&&c:\\\\utl\\\\cleanup.bat\\\"\")\nSystem.Runtime.getRuntime().exec(cmd);\n...\nExample: 3\nJava\n(bad code)\u00a0\n...\nString home = System.getProperty(\"APPHOME\");\nString cmd = home + INITCMD;\njava.lang.Runtime.getRuntime().exec(cmd);\n...\nExample: 4\nC\n(bad code)\u00a0\n#include <stdio.h>\n#include <unistd.h>\nint main(int argc, char **argv) {\nchar cat[] = \"cat \";\nchar *command;\nsize_t commandLength;\ncommandLength = strlen(cat) + strlen(argv[1]) + 1;\ncommand = (char *) malloc(commandLength);\nstrncpy(command, cat, commandLength);\nstrncat(command, argv[1], (commandLength - strlen(cat)) );\nsystem(command);\nreturn (0);\n}", "start_char_idx": 0, "end_char_idx": 1907, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c0fd5afc-cd48-4332-bd7e-eb58b398460b": {"__data__": {"id_": "c0fd5afc-cd48-4332-bd7e-eb58b398460b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "81eb9ea2-429e-4fd8-b027-442f79c1f171", "node_type": "4", "metadata": {}, "hash": "0dcc52cb1d7c5107f24df357e4bc10105f745af675120ab34e586679a37fee21", "class_name": "RelatedNodeInfo"}}, "text": "CWE-704: Incorrect Type Conversion or Cast\nDescription :\nThe product does not correctly convert an object, resource, or structure from one type to a different type. \nExample: 1\nC\n(bad code)\u00a0\nunsigned int readdata () {int amount = 0;\n...\namount = accessmainframe();\n...\nreturn amount;\n}\nExample: 2\nC\n(bad code)\u00a0\n#define NAME_TYPE 1\n#define ID_TYPE 2\nstruct MessageBuffer\n{int msgType;\nunion {char *name;\nint nameID;\n};\n};\nint main (int argc, char **argv) {\nstruct MessageBuffer buf;\nchar *defaultMessage = \"Hello World\";\nbuf.msgType = NAME_TYPE;\nbuf.name = defaultMessage;\nprintf(\"Pointer of buf.name is %p\\n\", buf.name);\n/* This particular value for nameID is used to make the code architecture-independent. If coming from untrusted input, it could be any value. */\nbuf.nameID = (int)(defaultMessage + 1);\nprintf(\"Pointer of buf.name is now %p\\n\", buf.name);\nif (buf.msgType == NAME_TYPE) {printf(\"Message: %s\\n\", buf.name);\n}\nelse {printf(\"Message: Use ID %d\\n\", buf.nameID);\n}\n}", "start_char_idx": 0, "end_char_idx": 980, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/metadata": {"dead65d2-4a16-4114-a700-20e926cbfb02": {"doc_hash": "19c64fc3b9260a566f7b3b91548b9b86eb0f0c0f867e45c6f9c5699ebb4def3b", "ref_doc_id": "b4e94d5d-2aef-4b77-8b7c-ff7872c77e70"}, "b4e94d5d-2aef-4b77-8b7c-ff7872c77e70": {"doc_hash": "78b7364febde99aaed85558436f30cbd657e9852b64428d8c8c8b8816fc0bba5"}, "9feabfdf-ad6f-48b1-b4aa-c061f50d3d39": {"doc_hash": "483f844acbe13111ed3acc774022e7fcc4b20a5e6e857a144521f8094bafabcb", "ref_doc_id": "f6ced86c-4f72-429c-9fbb-e50a4a053870"}, "f6ced86c-4f72-429c-9fbb-e50a4a053870": {"doc_hash": "fa83ca0fcf62d5c7e72ed01924e327ea308faf72f1d2fe1b15eefb7d3fe89b10"}, "71f33c2f-9a04-4dcb-b01d-c6404314d105": {"doc_hash": "052e0a0566a92f120c9a4425e77c2038449e1767abbb4ed153388d1edbf22571", "ref_doc_id": "c1d81e2e-c2b9-463b-8e6a-d535887f6abc"}, "c1d81e2e-c2b9-463b-8e6a-d535887f6abc": {"doc_hash": "7e868b859c9b963a9b5ecf30841a0e4f2ffaf39343a7f0439b1ebf4e146d1687"}, "61e6289e-f8ae-4d7e-af6b-c7bba3a213e1": {"doc_hash": "3e5eeac0661bad481d4974f4178db4f701e28987980aa137f1524fe45b4c06e6", "ref_doc_id": "5f198ad2-03ab-4461-adc6-adcfd4d6a7ff"}, "5f198ad2-03ab-4461-adc6-adcfd4d6a7ff": {"doc_hash": "11254cd568fe4ffb584dcdbbc174688d4fa4083d2060d82a2b70f432dc8372b2"}, "3fd9424c-6ad1-46f6-a087-0a055bf18433": {"doc_hash": "5269fab3c75d8a33f4968bbadc87c64db9ece6d4ba03990be4e1de7260969d8c", "ref_doc_id": "0610fd12-2d82-4a57-bbab-a94e2a5fa49e"}, "4b11c241-e09c-4545-bd09-085fb192008d": {"doc_hash": "8cce7d2d3452781f2a6b742c969274beae6a09cc4fa977fb52281dfb938aa9ca", "ref_doc_id": "0610fd12-2d82-4a57-bbab-a94e2a5fa49e"}, "0610fd12-2d82-4a57-bbab-a94e2a5fa49e": {"doc_hash": "1b7fde4945588187ee673cf8178f23fed8df1a9ff526fdcd7fc4c4c998c086ca"}, "df1a9e13-4474-4a3e-b62d-433c290be0e5": {"doc_hash": "bf27c76d8854e2a6ad7288c72511203f0e24107b85b27d687a6bc349c0f21242", "ref_doc_id": "67052d51-008b-4f89-8154-e1d1daab828a"}, "67052d51-008b-4f89-8154-e1d1daab828a": {"doc_hash": "59039d50e7d6cd34cc8c1b6f7821dfe3d09e57e275e03a36f2531d44b10fc678"}, "f279a4ce-c12c-4938-8ac2-00203e41effa": {"doc_hash": "57b9ec7affb48fb4792bb6b2f2274984871def3530e52ef5205768494d1fc783", "ref_doc_id": "4407efa6-95f2-4009-9f2a-85c074e6ec65"}, "4407efa6-95f2-4009-9f2a-85c074e6ec65": {"doc_hash": "5f8400618ca6f93fdcd0b57c940fff745e3e7cf397e2fbd421585b3ebb717e8d"}, "d9542073-3613-48ea-bfd9-3ff82b2f3f27": {"doc_hash": "7bd326b2026030e2be210c92bffce57dcd552a35bbddebc8a9a5c3d9cbd09eff", "ref_doc_id": "e48ebc70-934e-45d1-a376-129e4cd12b42"}, "e48ebc70-934e-45d1-a376-129e4cd12b42": {"doc_hash": "cddfdfd318496982ccddd80082b8986ca6920dea2927f646eb6f8f5702bfb9f1"}, "00ec58f7-84ea-471e-91d9-4342529b94ee": {"doc_hash": "31e922ba4138e354aebb413c57522aeafb69a92fb32d7d5d7d2ab586897c22bc", "ref_doc_id": "fb052d08-d0da-4f5e-afb7-8f00241632c3"}, "fb052d08-d0da-4f5e-afb7-8f00241632c3": {"doc_hash": "b53c9c3bff412fd32b4ddc0bcbd107d12d5ea288663aed9cc984488b74b4987e"}, "24883fe8-b867-4916-821e-7c0f663ac866": {"doc_hash": "f08f9938590de683b7a06389ae608ef6b01b1d7f38156d18f4c9561a2ca901ff", "ref_doc_id": "7bfd973f-4325-4343-8375-e51d9c8847d3"}, "7bfd973f-4325-4343-8375-e51d9c8847d3": {"doc_hash": "945de2a2a057d869750260d3203a5f67cd980a8f3cd66e19badd805b04e73d27"}, "563a45bc-8b7c-4951-bc17-aeb6e669b213": {"doc_hash": "c97c8aaa959eacb6624912f7ece54ebb7148d406940357213cf39c7a0bfde7c2", "ref_doc_id": "1a222615-2d2e-4ba6-bebb-ac0acced7636"}, "1a222615-2d2e-4ba6-bebb-ac0acced7636": {"doc_hash": "8592790b555fa7ac5ab0ac3093a1d26fd5f5e784b004bcb6ed8ff20158448d7c"}, "5514f072-f52d-4890-9b95-c2c1958df6a5": {"doc_hash": "57cb3268332aa4df698da5f8778bcf4973a2a95ee1fd86fecd6c0335ac41c2de", "ref_doc_id": "a26fa20e-964e-4c0f-a467-fbe19148db1c"}, "a26fa20e-964e-4c0f-a467-fbe19148db1c": {"doc_hash": "7c18cfd0b6d3190a2f9aeffd2ccf051d7fefa137d0a043374af53c6a43ed931c"}, "d1a47896-4381-4bd6-a0d0-d7b40af3244e": {"doc_hash": "d930dd350b90e10f1d214dbbf23f371bd8df3785e206ea13ab9eb1524b8c5843", "ref_doc_id": "58e46aeb-0142-4d77-a6b5-b7de3ca14a69"}, "58e46aeb-0142-4d77-a6b5-b7de3ca14a69": {"doc_hash": "1ac5ff17454c3c104b4b0f564dbca20cfbbb309c5a0e10b0fcae24dcf1f864be"}, "cb61c533-0550-48a6-809c-98a2e4237b62": {"doc_hash": "33ef2ba17b0ccca6532c1eb7843ff1c6e021b00a417ec069b574be643236175b", "ref_doc_id": "1c8b96aa-e750-4045-a4e1-591cd67e2304"}, "1c8b96aa-e750-4045-a4e1-591cd67e2304": {"doc_hash": "39693a10ed6ae60c98b3bc25ba839fd28c0a0555f05bd1cf0674bf4172b719f3"}, "708368ad-12f0-4722-ad14-60dda632db19": {"doc_hash": "3b2889873adfef76df08724e0264651809e79b0653992f874c82cb636a7267de", "ref_doc_id": "809b1ad0-7a76-41c0-873c-32be1e1400a3"}, "809b1ad0-7a76-41c0-873c-32be1e1400a3": {"doc_hash": "14cd53115f8794c37bf338d112bdb583b215f7d976156255a3d07ec49cc18d9d"}, "1c21ba90-2ded-4553-ad9a-65207ed80a19": {"doc_hash": "6370a28163cd4bf3b365331ebc9ec621617f383b87ef382a9e434e55efe9f5a5", "ref_doc_id": "f0fe8be9-53a4-4d90-ab6d-aba6bcd91bac"}, "f0fe8be9-53a4-4d90-ab6d-aba6bcd91bac": {"doc_hash": "5934fd421e7d893dc85fe5d0f79b3467e0cfd9ec2f85ef17d0964508c88c5fb7"}, "0d0a2e1c-adcd-4ca5-81bf-aaa9beac444b": {"doc_hash": "6696d9c6a921420c86f5e671d112cb844d0bcb83d378a337f7f1703900558f46", "ref_doc_id": "3974bc6e-a2b0-4812-a41d-b34caad2d2b5"}, "3974bc6e-a2b0-4812-a41d-b34caad2d2b5": {"doc_hash": "b44bcc8a125faf5036ea4b5f61137b55e795c508323efd1be0a04639e46bf4bd"}, "f186f07e-e395-4c8c-8059-334950f62c51": {"doc_hash": "3d1b53d8a36ca4e008e024b404213c439831387472ad9beabffcfb4d50853699", "ref_doc_id": "ea8a8540-7a11-4cd9-8d6a-6b31c15c9049"}, "ea8a8540-7a11-4cd9-8d6a-6b31c15c9049": {"doc_hash": "8de5e8a2d9f282961c180a287e99d01f7f757869d7e774e5b02b3361ca15af9d"}, "34058055-31a5-41ed-87c9-6580b865413e": {"doc_hash": "5e0ac49c2a7773da37fac9ecc28801f27862981a83c43056bfbd6ec0d2353b22", "ref_doc_id": "e650852b-5670-4ca2-b458-1cd08cd0ea20"}, "e650852b-5670-4ca2-b458-1cd08cd0ea20": {"doc_hash": "d5e68d9adeac3a2a9a6301a7747708b036a30adb5bce6a8c4370c8e5f5a32e84"}, "b9ba94b7-1da2-4c21-9625-4c556af5e5a4": {"doc_hash": "5f0ee0e8b7ce855548c6c65ae16ce8ceff8946887a478bf0a166725d953be2a7", "ref_doc_id": "c605b6a2-9cff-440b-a81c-46f5fbf63b85"}, "c605b6a2-9cff-440b-a81c-46f5fbf63b85": {"doc_hash": "8f946da3e60a3813665a13fb41468dd6a7265f3e20de8ad63aedf62700b5cf45"}, "0b147dfa-a033-4b83-a31f-451dc1646986": {"doc_hash": "61ff530a64a168ce63e9fc006c7c28db26bcdc630ed3fb4c2fc5ddc6e4b7e5a0", "ref_doc_id": "58c80c45-b624-4a73-aaff-dd37a8a9d73e"}, "58c80c45-b624-4a73-aaff-dd37a8a9d73e": {"doc_hash": "eacc42f2254b9b5083fc3ddf0fd980ca31afd171aca2124d03e6e090fb5daf3c"}, "57b764fc-d315-4f0d-b90b-47e3929d1fe1": {"doc_hash": "b5b60684e05ca07d544bd1efc61b871147dbdd6381eb84911c7f03c29dc790a2", "ref_doc_id": "2be702ef-686f-4c6b-ab06-85c00b9ddc23"}, "2be702ef-686f-4c6b-ab06-85c00b9ddc23": {"doc_hash": "35313d4c25e81cbbe0ca8e564f9f8245c482b2850974e40927f48d4670c308ac"}, "32aaaa74-8688-40bd-99c0-f56e9840ddc5": {"doc_hash": "dcd3c64ba928b2883cc0fa7bef8279830b8f98be8c49264710548cecd6de1bd0", "ref_doc_id": "83d25222-b11e-4ec0-a0a8-e5558ed5cd8b"}, "83d25222-b11e-4ec0-a0a8-e5558ed5cd8b": {"doc_hash": "cdfb39ea229fb0b3c09297cae57833ef5d38c086fedeb91fcfd9044e91afa069"}, "5c6e6275-45bb-40db-b2b4-d2c235776fb9": {"doc_hash": "e98c9bf10ce8f432fb7b7009d30ceff56b89d2d25ed75b2d7a7895a211665795", "ref_doc_id": "61fe7159-cd8c-4466-98ca-61af78aad400"}, "61fe7159-cd8c-4466-98ca-61af78aad400": {"doc_hash": "14932b34a813f6cb50f780bff09cf8367394367338f7572c68d93bac907a96fa"}, "cff34956-de04-4eed-b14f-d6f70b0bdf19": {"doc_hash": "39a8404c29d6480785b25fb431a1cc7b681b799561a06dea2d69d89991bdd56e", "ref_doc_id": "99ad159a-f1e2-4836-a6a4-433d3603ac29"}, "99ad159a-f1e2-4836-a6a4-433d3603ac29": {"doc_hash": "217ee5a472bb6f47ebc196976bc1c14641597a96683c5cf861cd2d266eca557d"}, "92b5e2ab-7452-49ad-bdf8-1a91b1299d9c": {"doc_hash": "cd9e468e7abf5392f6eeb3d4ecc6a327ddc188590f1727bf6400d16a5f7b6da0", "ref_doc_id": "38dace05-21ee-4c13-89f2-6236f79d170e"}, "38dace05-21ee-4c13-89f2-6236f79d170e": {"doc_hash": "bdcfe5bb6015a450410356b4d788965159dc479d4aa2bd206f459550786c43fd"}, "7aa83ea5-6c1d-4f4a-9042-c28dbd2af802": {"doc_hash": "2d409cd403fd61513f560c25675ee722700cd6614629819b27d2e172053b437c", "ref_doc_id": "b5deb37c-93be-40e4-a39d-0b67d3c481d7"}, "b5deb37c-93be-40e4-a39d-0b67d3c481d7": {"doc_hash": "1131a1d282a2e8586f466a5583e995e4675cb79157789c7db9633832f895e7a1"}, "e4c5b343-fd3e-42e6-bcc1-41d087fc455c": {"doc_hash": "3e7da69080d87e396927b98236e7e276e2f4f999565bb3b23126326357656afa", "ref_doc_id": "9562521f-463f-403e-8619-715d9ae99b41"}, "9562521f-463f-403e-8619-715d9ae99b41": {"doc_hash": "59bf30586e000ac5e09d45af5f6e2e54e183ef5a6233b77ea0c3430b0c73dbeb"}, "afc030f5-3ce0-471b-b6d1-7f11d42018c1": {"doc_hash": "cc361fa5442a257cc58b209bdceb3c6f9183f8518d5d2409b30b1b3ce8ef44d6", "ref_doc_id": "a2da8790-b411-43af-ab7e-9e7591621ee6"}, "a2da8790-b411-43af-ab7e-9e7591621ee6": {"doc_hash": "8cbe11f8fa77ec4401d7e5138a5023e58e889b58aa383c4962e9c50dcbf97089"}, "1c05ee29-e94a-4a6e-b6fe-e15b01ab43b0": {"doc_hash": "e1ef82bd9277add9d51d8da7bdf834fec7d5194b2a44719b50813a609a25be5e", "ref_doc_id": "c00a8094-b323-4998-9eca-942c63c6cfb1"}, "c00a8094-b323-4998-9eca-942c63c6cfb1": {"doc_hash": "ba40f1005b7ab8a0ec16e5543b45822bbb82bdea766a17ef47cf48f6b036e4d1"}, "6e9f1cd1-5ec6-456b-ae9b-3ba095960c24": {"doc_hash": "0c6442b41f0da8dc47c7483fe7163b7859fe06f67b932748bf8ab78e90453ef6", "ref_doc_id": "53a501b8-8ab8-4aea-9c40-4d7ecbb16f09"}, "53a501b8-8ab8-4aea-9c40-4d7ecbb16f09": {"doc_hash": "b2e9ca73f4bc1d6fd8fe20059d922b8a942989f9a2678045e73cc89ba6db35a6"}, "608420b8-992d-4e2c-a8c2-9e6e239cdd1d": {"doc_hash": "5d2335cffee2ef715761a75a4e7ef798653db76a349ab75b61ad79002b6c5e4d", "ref_doc_id": "c2778437-5427-4022-8ecd-fe6935941285"}, "c2778437-5427-4022-8ecd-fe6935941285": {"doc_hash": "9207b09b0000508d55c6eee8c4455fc781c1a594cf6d99a508f04209f5bbc750"}, "45461118-4020-4448-9c5a-0f8936552ad4": {"doc_hash": "f345cb3ba70e5c82f84c4742773f71339b58fdde22e9eae59fc07895b42ca739", "ref_doc_id": "058d49b5-6266-4528-816c-fd42c4016797"}, "058d49b5-6266-4528-816c-fd42c4016797": {"doc_hash": "6db144260504ecee4c9b03653192820c555d13f27f9afdb7080e36325e8cac1e"}, "aaeba83e-e4a6-4f44-8a28-5974fd74ab5b": {"doc_hash": "652d5d7b7a3c18ad6f962ead14182447f7a0a13710af11b16a0368c63190a300", "ref_doc_id": "f2746f9b-0a23-4d91-b658-3a37569a2275"}, "f2746f9b-0a23-4d91-b658-3a37569a2275": {"doc_hash": "01bc90cb766b8793ecdfb92e4a4ba9134b45336f96ca1144dff1545dca3d4ba5"}, "898d4564-10e1-4a60-86ee-90d68fc226a4": {"doc_hash": "f027c4b5b2c9edf40a7438a2e7654b6eff20110272b9c4365e31bae5f6b6d5bd", "ref_doc_id": "7318402d-2773-4f3d-b1c5-121256b95d5d"}, "7318402d-2773-4f3d-b1c5-121256b95d5d": {"doc_hash": "a850767a7082c8dcf0cb4668630329b32969a7c3deb6171a7e43699da7b07734"}, "1d0de13c-b3a0-49db-95a6-020a46cfe66e": {"doc_hash": "c347e8d1ec5f71aa4f296bf7bb79f2e2bd10b77a189fbeec51d98f13dc96dab1", "ref_doc_id": "77e5aa73-4800-4c76-9603-42afe8f66907"}, "77e5aa73-4800-4c76-9603-42afe8f66907": {"doc_hash": "3196b967f584e020e2d1b07b816d3a443b5d410849ae05406993dc18a25d7f08"}, "16156a5c-3863-4134-87b8-0dba8ca24772": {"doc_hash": "7f012f4b25b0f38ea66d4fc1c3b42726e6e276ff8e71effb04d873ad4e274916", "ref_doc_id": "a520791c-9866-4cf3-a82f-9f303c1ce8b9"}, "a520791c-9866-4cf3-a82f-9f303c1ce8b9": {"doc_hash": "822b5e87dd6943539814d69d40edf6c8302003e57f47fbdc0681411a31f06c70"}, "a2cc456a-2bd8-4af2-a9df-acb511448c85": {"doc_hash": "06d2b3a0bc7419ae7f6c88d9e05f133a6dd303d531f3e14e5badd0d1b20a3641", "ref_doc_id": "940c0067-7952-4ea8-9cbe-309bbd801ed7"}, "940c0067-7952-4ea8-9cbe-309bbd801ed7": {"doc_hash": "33c6e329ad30ddf3b227c588b1783f9a6c5e7420f3890e439e606b3239e7532a"}, "ff6fc434-a447-45ff-b5da-d16a0b925bc9": {"doc_hash": "ce72d77f53f262ba3ace61cdfacd083d21e1cc9d7a9e7da57748cbe0f5be45e5", "ref_doc_id": "417f4b3f-3b6a-419b-9d9c-beb88f34b630"}, "417f4b3f-3b6a-419b-9d9c-beb88f34b630": {"doc_hash": "26fdde6abea69f9d73dd6ebdc313325b9975b783df615f226677674f5477f8d1"}, "b0f9943b-4f48-42a7-8c82-02192273fb58": {"doc_hash": "75c7701c6e08a374133110b631194552be37b6a7a81aea49ec4e8ee946adbb6c", "ref_doc_id": "1ec34bbc-b547-4d43-84aa-ae2ff2a80a0f"}, "1ec34bbc-b547-4d43-84aa-ae2ff2a80a0f": {"doc_hash": "6926236ceca48f7b793ae15e43ec9560b8b49178987334344632695fa9c6650e"}, "3343926b-6c5e-4dd0-b83a-027f06cbf5f8": {"doc_hash": "ccb93eb225ce91aa23bceba5cee7996eb8ec368b834bc57b6b50a13b83dc5822", "ref_doc_id": "aa21149b-e1ab-4fda-9eda-c309d4cc8a23"}, "aa21149b-e1ab-4fda-9eda-c309d4cc8a23": {"doc_hash": "94b1395fa5769749fa880956f5feebf6bb2a6092b5b12552286e1ad4e6dfe04e"}, "ca104edf-c6b9-4069-8858-2b8dd8437fc1": {"doc_hash": "fd8ac93b878053c991277c32cb00af7160189be0ded161f82122237d5b91f308", "ref_doc_id": "256707a6-0549-4385-bd3f-e03e6b6f9de5"}, "256707a6-0549-4385-bd3f-e03e6b6f9de5": {"doc_hash": "d6b9b00d61d3acb1958a2bacfc83c345c53baed936235e8b4df62f1ba58ae102"}, "2dca516b-3a82-4d7d-bea4-ac2d0c4aff45": {"doc_hash": "267f3643e715417e1104b9c0df9ff5ae4b1fd9c70c41fb33d35fb40ce6ba6cb0", "ref_doc_id": "d12442a9-f9c2-465b-a04e-48fee91f3265"}, "d12442a9-f9c2-465b-a04e-48fee91f3265": {"doc_hash": "f453e04321c75bc795de609fabadf064c3915d0130e19ecd1c80cdbf8d1245c3"}, "5a76c44d-79db-40a8-b1f6-69e35ce2b3ab": {"doc_hash": "4ace4aa0d279c38acd2b819333b313debb46b9d96a6a9fab357c712cf729cd8d", "ref_doc_id": "0ffd3982-f064-48d5-a68b-797a71b399d1"}, "0ffd3982-f064-48d5-a68b-797a71b399d1": {"doc_hash": "1730b38cf75e8bfd9785e44505dfd1385fe2973bd93ad7fc9221dc781ce6ba0f"}, "de0808f0-3c90-4141-a6b6-bae9a1423e36": {"doc_hash": "27258da5c79da2c47482cf8974ebf63ff9814b81c02dde7093602a927b65af29", "ref_doc_id": "726f98ec-f991-4cdf-a0c6-1623c03380db"}, "726f98ec-f991-4cdf-a0c6-1623c03380db": {"doc_hash": "84e326f3178c2bf4fb3b785a3f7306403a8277f0c3a674216c4615be25c2c6d5"}, "f0708548-fb19-4026-8326-99cd57fb8bb1": {"doc_hash": "d9e6e9ab1523c44976c2570d82ca937d73a17522c4b64149b9f411fb6d34334d", "ref_doc_id": "4d6872a6-1959-4f57-8cbf-eb2a1e423908"}, "4d6872a6-1959-4f57-8cbf-eb2a1e423908": {"doc_hash": "d61d8d75e918ffc34f1c1b99a79a381202e972139f7fd335cac53186dc93c2a6"}, "04282650-be8e-465b-87b0-2c57c7c5d22c": {"doc_hash": "5ee2fe9bad5a68ae28904c6f0612626531c72a33340e0b74555e9bcb8411881c", "ref_doc_id": "09121923-dafd-430e-85fa-27f0d1c5c108"}, "09121923-dafd-430e-85fa-27f0d1c5c108": {"doc_hash": "28a79a15cfb61c4c074bb83262e8b487dfb18dc039079845330441ebf0a80b80"}, "fadd678c-faee-43ba-9bf0-ed792f5b70b8": {"doc_hash": "8e983da4eb1aacf40aaa49c296cfcc595ca40004759e86ab2eec73a347af6e05", "ref_doc_id": "52ffb245-526f-4653-82dd-f004fdf72f09"}, "52ffb245-526f-4653-82dd-f004fdf72f09": {"doc_hash": "089791389fd16ff1f4578af93253d2e2db771bfba4c24fa546c0776c55fb2d77"}, "97acb953-74bd-45f7-9e55-406c762eb3ec": {"doc_hash": "c2c3b311464d2c981cd0a60f8b2e3f6d3716e283e6de670fbb328cbd6c2ae792", "ref_doc_id": "365adf3d-99f8-4c13-b44b-3b1fe312ba22"}, "365adf3d-99f8-4c13-b44b-3b1fe312ba22": {"doc_hash": "2a74893574d2ae6ba7d7e69fe8a3e53a649d2e3b27fe1fe998501da968db5f63"}, "f5b83331-b18a-4d0d-9bb5-8e40854b9edd": {"doc_hash": "989e5f8020d8a473d646245522b237593399387ac6545087918f7a85e4da3d62", "ref_doc_id": "dd7ef8a7-8687-4e4e-a28d-44a3de999039"}, "dd7ef8a7-8687-4e4e-a28d-44a3de999039": {"doc_hash": "954d98b2778c9112a008be13ac58904675cb634ab86d687d0a8ea2bd0b1aefb4"}, "3fc6684c-cb83-47af-b4dd-9c6c031852f1": {"doc_hash": "bdc4cf44eaa685be8083ea6f10c23d78724d38bf6b2a4670c582c6ea9c4902ab", "ref_doc_id": "1ac01e08-3616-4d38-84fa-64cce6dec27d"}, "1ac01e08-3616-4d38-84fa-64cce6dec27d": {"doc_hash": "dcc8d94e90f0b911833f4e386597955103e1eb8bfb0570128a2dd8586622c0f2"}, "9160f2a0-a411-4c1b-9908-38e38c9f4478": {"doc_hash": "2d06b351e974db83711ffe19b64ac19bd44e12a9ed18a6aa14131c1a9d72863c", "ref_doc_id": "89eda4d2-0ecf-421f-bd59-bddbb1396dfc"}, "89eda4d2-0ecf-421f-bd59-bddbb1396dfc": {"doc_hash": "290cb6fd6acf8c342b8f10f0fef08c97ee7b270a64de3cf901f97055c6b502c5"}, "91e1da35-e0f0-45d7-8299-42ef5768fcc5": {"doc_hash": "40ebb773b021d1a7e38220f0add6c4ca7e2f1ee892a5c0adcb11c47242598fa0", "ref_doc_id": "43b50e3f-a302-4fb8-ac40-11f06fc61919"}, "43b50e3f-a302-4fb8-ac40-11f06fc61919": {"doc_hash": "a818cd766570fcd700e0170f34488c3f35d157a290a21a41cfb417abb30a4145"}, "ddd5236b-0ff1-4b0e-aa15-7b55b1a4180c": {"doc_hash": "4fb79aa7659e33aebabcc0a73652ab84a5c46dcc44a62f079008dcc41e27d1d5", "ref_doc_id": "6776b70a-5c1b-4edc-8dff-e6feea74f170"}, "6776b70a-5c1b-4edc-8dff-e6feea74f170": {"doc_hash": "43a79770c79d6d243c2846862ec26a6ff5de39b68afb8967fcbb44f5e8e026c4"}, "71043004-cf5f-4e7b-8f2e-e057d118fedf": {"doc_hash": "b4eab0bfa2d694f26d4d70b513293f2305ad98815d12d8c9a0e690daba215629", "ref_doc_id": "2d9178b5-acea-41c4-9857-b20031c9f6b9"}, "2d9178b5-acea-41c4-9857-b20031c9f6b9": {"doc_hash": "d80f9f747d9536e9c5ecd6db08838323e19af3b13915b2374818de8e13cf80a0"}, "3517aee2-144d-46e7-b9b5-4a3c97007fdf": {"doc_hash": "1d6124bb0df8379458f253cb245d0518f2508a3fadc60bf1114e5eb01f34fb0c", "ref_doc_id": "c4a87ce8-0d6d-42ff-8a52-580d353756da"}, "c4a87ce8-0d6d-42ff-8a52-580d353756da": {"doc_hash": "f82d3ba35a0374070260dc96d1074429914b365baf1603da1ae64272f9de0378"}, "4519ac59-dfd5-47c3-848a-94486cff1217": {"doc_hash": "b4c46b690153180ef6278bf69cd79a12bc5806e8483d435b4e54172ecec80963", "ref_doc_id": "a7e15a6b-4dde-49da-bcd3-2ce3e14c8098"}, "a7e15a6b-4dde-49da-bcd3-2ce3e14c8098": {"doc_hash": "57ac2c75d5ff864e6a3312400aae4a9777f82919dd0e83ecf881b4c616acd752"}, "53003f8f-bb03-4728-9f31-81415858c275": {"doc_hash": "1c556222770f1d69bb500487933016cf9b8dfa537f96431473be93cf053390be", "ref_doc_id": "8f2d85bc-2dda-4ba2-b52e-e4f0f00a9a9e"}, "8f2d85bc-2dda-4ba2-b52e-e4f0f00a9a9e": {"doc_hash": "a77fe20f5160b8129313952d887fe15bad21d8d1c7633184efd1893173dfb97a"}, "b92c6267-7625-49ec-9d2c-e255b0040dd1": {"doc_hash": "d9d2d6fbc599560882c0cd4d4da1e824e40eb1dac17656729622b9085ef14f61", "ref_doc_id": "c3c798b5-c291-4b60-8bdb-e814cab0fe4e"}, "c3c798b5-c291-4b60-8bdb-e814cab0fe4e": {"doc_hash": "c82e43dc6832821bd45a19e81a0ffc1b1231cf103485f2187a7442451afe8b71"}, "be3fce81-875c-47e7-b9fb-0c9658eacdd3": {"doc_hash": "20ab6f2de161709ff20657f412d79153fbaeca2d5942f2783fcba792fe854203", "ref_doc_id": "2689b1c7-2c21-461e-b7ca-54f1e8659f69"}, "2689b1c7-2c21-461e-b7ca-54f1e8659f69": {"doc_hash": "230b4ea86a7f041c9780a1d0990d8f48a59f76a53f23c2bdc128ef8523a73e0a"}, "f0de95fb-8e3e-45ba-9393-04d96bdfdb7a": {"doc_hash": "3e43a1b9c6947df3ffcef7a6104f2ad66b45622d959f3fbb3a9f3785c44f19fe", "ref_doc_id": "9625f6bd-9e33-4642-9127-a55ae53f6a08"}, "9625f6bd-9e33-4642-9127-a55ae53f6a08": {"doc_hash": "aab9debd0ed0283a041196dc55cc7e2a1ac7d37522be980435bc8a32fea0fbd3"}, "34fd9d9c-00ee-424d-8f08-c2cf28453ca0": {"doc_hash": "797f84e97b3f04b7e2f63c0b83480d7ed9334893e998fd715932276a616d06b6", "ref_doc_id": "9fc92f02-de3e-4b70-8a5d-67aeae3d7304"}, "9fc92f02-de3e-4b70-8a5d-67aeae3d7304": {"doc_hash": "46297380a8cc455d3324a7fff3169808d37d7601aa62f40c6d3314c0852dc799"}, "08ee7821-4ac3-4dfe-aa24-74446cc35f2d": {"doc_hash": "223cc0bdc354cbc9df5a9c88cc6780f5581f43e2a800e415d637a6013a3c679d", "ref_doc_id": "65827295-3c23-4dcb-b5eb-6ead1499cc0b"}, "65827295-3c23-4dcb-b5eb-6ead1499cc0b": {"doc_hash": "9b50fca41891068263703623dd5d0902d68600ea7bd00a18375ee7a00e9e413e"}, "be1e99b9-d90d-487f-85a7-acd5bb65a9f6": {"doc_hash": "8f0aa3e4f9c4980fe73a186f2bfdacda80ead9bf4cac642adbfca8d9cd3cbe36", "ref_doc_id": "f7aa0047-39c8-4916-8675-b6fd9ac65235"}, "f7aa0047-39c8-4916-8675-b6fd9ac65235": {"doc_hash": "26b6e36530110c414633b09e39cf77f78ab6f6a6524e44b6805a13f0bf7d5c63"}, "7b340ae2-180d-4cbd-994d-5cdb170541b8": {"doc_hash": "6ded03913e759f2310dd0f746e5525462a3b8c4104ff18c152ad24ac7725c690", "ref_doc_id": "62a7717e-0078-4fd9-a9a9-eb8bf84d8a73"}, "62a7717e-0078-4fd9-a9a9-eb8bf84d8a73": {"doc_hash": "9aa97397911103d451ce6c427f9e57fbd1ccf92f0e32d7b4f9a3e7e72d2a2558"}, "d487ea4d-4a1b-4b20-9b7d-dba51e362ff3": {"doc_hash": "4be279a0c82cc575facb28293e8b6f9ac2964406ba526faf45e8e37c15648ea2", "ref_doc_id": "651879fe-13df-40ee-9ed5-164166a9c755"}, "651879fe-13df-40ee-9ed5-164166a9c755": {"doc_hash": "01e76b4a52b8454e69bc6568f0f45c7fc04e44e5ff2a5c30cd0d7a43f735ada0"}, "f84a4ac0-c222-4dab-a400-9e7149760cbf": {"doc_hash": "c1f5f26ea30531cb496bd92c4353afb3cddb9bbe6b2a916b3cecfd7863dd2046", "ref_doc_id": "7c7f2b04-5d9a-46be-9608-7ba0aaa1e12c"}, "7c7f2b04-5d9a-46be-9608-7ba0aaa1e12c": {"doc_hash": "9443513a3ee56ddc7d7ad228f3a74ec0699a4892585b6da907758573fa954c5d"}, "0b3cdaf5-d7e9-43db-88d2-e22115be275e": {"doc_hash": "897ae65294a68f6c73ca6518a0fbd5aa950e077ea8bdff830c905ef9c2149d25", "ref_doc_id": "5d33be96-697b-43fb-888a-6885fa98dd22"}, "5d33be96-697b-43fb-888a-6885fa98dd22": {"doc_hash": "b8aa8be1641c8ce50fdf278d7187c40b3b75f503a839982e571956a6b2837eac"}, "53abd67b-b1a8-4f7a-ac9b-5d17d9bdb393": {"doc_hash": "4b12928ab1ded9f8c706d7d2900798fffdc9a1a1f2d1cc6d69f2ea46ea9f0f40", "ref_doc_id": "9fc140ae-0d86-44a1-85c3-e8f57bffbc5f"}, "9fc140ae-0d86-44a1-85c3-e8f57bffbc5f": {"doc_hash": "603235e31872d8b4ede1b264158e01032ec73fb14ea3d6f394a287a5ca86c4a7"}, "2f129b99-55f0-4f14-8eea-60befaee57ce": {"doc_hash": "9177a5e4801d745edd78db30b8cd84d71b3ad25f05bd8a43b41937600b8d9edb", "ref_doc_id": "07213341-1d6b-4965-993d-19d398da6154"}, "07213341-1d6b-4965-993d-19d398da6154": {"doc_hash": "7f3f6cbfe417bb2de9275cc9c52aaffd20dac6d6a8ae4b9d2ff6f039fd73088e"}, "3b3a77f2-aaf5-409e-a207-6342b8b7340d": {"doc_hash": "5036a1609dcc70bfc0ac3834b4d90455dc93a1fed1bc04bbaf2c54cfcbf090ba", "ref_doc_id": "af051c0a-ad14-4dc3-aead-8544b3fa076d"}, "af051c0a-ad14-4dc3-aead-8544b3fa076d": {"doc_hash": "f8ba26f3446d3b77f200eda80d391e4cc2d8de9e46d84e67b6a384afdb43e916"}, "b6d43193-d89f-41ef-aece-3731dcec1e28": {"doc_hash": "2b2aab81c130eaab978c15875f7ac8b33fe1376a8bed1a8f2423aa3a53107bbb", "ref_doc_id": "d2209471-ff08-4980-8a7b-1cb17462b2de"}, "d2209471-ff08-4980-8a7b-1cb17462b2de": {"doc_hash": "ac6901dd673f40804c1ac84fdc24c066609ccd25191b82ec0fd2698f7f990272"}, "b4f2403e-350b-4e04-9a5e-76d12ee9df55": {"doc_hash": "f2e9d4f47f3fce30c1d3f3c89d427de1eaebaf2ae9d9b1df3831f51edbb19938", "ref_doc_id": "5bee927f-748e-45d2-9212-186165e967b6"}, "5bee927f-748e-45d2-9212-186165e967b6": {"doc_hash": "ab60986f675291ca139a5e045356b5d65900ce156666bf78d64fc2007b52e71b"}, "0402c027-5614-4ac7-87f3-62750199200a": {"doc_hash": "5b09ec1e4789d0c457db9081528fb0d8e97c5101e932035c06a47d366394b282", "ref_doc_id": "31d78f62-b563-4fc8-8543-928e02a1468e"}, "31d78f62-b563-4fc8-8543-928e02a1468e": {"doc_hash": "bd66e2e2afc0b7287ec862dc86018fbac9d728bb36c79d7ce9f18522f08a8929"}, "5365dc19-037d-4cc7-9d07-b0645f84e8ea": {"doc_hash": "a87bca6d4a2265986a457eb15d6369989e7dbd8f5d26758e18e6c679ae4bb71a", "ref_doc_id": "ee46d1c2-e402-4980-8f84-4c4faf4d8cde"}, "ee46d1c2-e402-4980-8f84-4c4faf4d8cde": {"doc_hash": "e0a3483dcc9ff9625637bd9690f1f21b23be530909493436390ca4cfea7538db"}, "60ab5a64-c59a-4f02-b2cf-86dd888e4e85": {"doc_hash": "32f512b6725f714f49ea311ec1d241a0a34fa928e48ab44143269f67d9590d8b", "ref_doc_id": "d7e52f96-d83d-49a1-95cc-1b70fc24d4c5"}, "d7e52f96-d83d-49a1-95cc-1b70fc24d4c5": {"doc_hash": "c14d3967134330b53335718a3def46d988560e5b9a89fa44245a135e5db14dcb"}, "4143cab1-d718-4368-9ea0-23bc7374f70f": {"doc_hash": "77bcbb6c076752e10cb80c3604190edf181c7b6c9b2fd574430395fc754c58c6", "ref_doc_id": "1389bb08-82b4-4a6f-b5d1-1fc4d7d19df9"}, "1389bb08-82b4-4a6f-b5d1-1fc4d7d19df9": {"doc_hash": "8a54f8e3c60dcd79cef8d35835eeca2cb3a983232b331a7fa15a705d2ae73d8f"}, "d0d82868-6a88-4ff8-8bf4-522a215a1945": {"doc_hash": "4a1143990a54cb6c27c493d7f9a8e2fa091982420b0cfa731918db96576bcdd8", "ref_doc_id": "2330ae9a-ea50-4685-b922-b7253a2fee4b"}, "2330ae9a-ea50-4685-b922-b7253a2fee4b": {"doc_hash": "ef80780fa5bae542cd5333393d50582ad1bb4d2e7fd973c06f92ce6359134ba0"}, "87e17769-74d4-4655-9d53-195c0a05d1ef": {"doc_hash": "5f310ac95db0ae64aabf0b4d3f4af672065b9b842f1d6d3b51785de195fde60b", "ref_doc_id": "c25a1a3d-8fe1-46a4-a7ac-c4f1be69b49e"}, "c25a1a3d-8fe1-46a4-a7ac-c4f1be69b49e": {"doc_hash": "083b02e62ec637461df61b48704724fb5e92da1c383db8b6f5d7f0e2059bb574"}, "31966f3b-428d-4781-bdc4-8c7a16d84c90": {"doc_hash": "57e6a7b9bc26d0a97b2edbc9d5290da39165d99945e6401a4e7beb37580131f6", "ref_doc_id": "9b6bf889-c931-4066-969a-7aa49b8f4b75"}, "9b6bf889-c931-4066-969a-7aa49b8f4b75": {"doc_hash": "96cbc09dd5223ea76b7bedbac99d4fcd7f5e983ec5164d7e0c4f8ce4c89c4872"}, "0f0d05cb-c799-410b-8ede-9538d4347cae": {"doc_hash": "e707166c5cf181169af7f883c3a3ba97c7295f5e31de9992276f0fd09a2e0e5e", "ref_doc_id": "560e756f-52fd-46a1-a16a-184f0cad5e93"}, "560e756f-52fd-46a1-a16a-184f0cad5e93": {"doc_hash": "32ef7550e72b0193f50ca21147c0fa29897fcadfe649207ca36e98f91956b766"}, "b660278c-71d7-4c5b-81eb-2e4dcbf35b47": {"doc_hash": "eaca11ac73a1376ccea1623fad58fbd7329925156229e37c02a8ebe87099880f", "ref_doc_id": "583cc2a1-4522-42e1-97a2-9eb43af009c7"}, "583cc2a1-4522-42e1-97a2-9eb43af009c7": {"doc_hash": "082c38a71296568ba4b8202e4b6f2e621e361d1245e47646c3540d7a94cc77d6"}, "16afdd85-7778-4377-b2ed-6c953920d182": {"doc_hash": "3286a37873d5cbcaea6d3dd0d478d81ccfc599d0c2be42350907b0bac60dba1d", "ref_doc_id": "83e4072d-69c9-45b7-aa84-df03a189dbbd"}, "83e4072d-69c9-45b7-aa84-df03a189dbbd": {"doc_hash": "7ce7a160bdbbfc524ae2554a41994befc3c0c8f6e64542d5d3b074db6209cd8d"}, "3641de24-697d-4d2d-8e90-13c5471a53f8": {"doc_hash": "9bde15aec99ff337d0fc20d9e8bf36f470fa742bef8f2f13bade04acde13f3ab", "ref_doc_id": "5fd8b6cb-fdd6-4ee9-83d8-378cc053b5cf"}, "5fd8b6cb-fdd6-4ee9-83d8-378cc053b5cf": {"doc_hash": "bbe2fd19cf4b6c6dc350400069554be38645807425d7d0195a63194262b9bf6a"}, "4e1917ad-3b00-4d14-8b35-8a27ed49a9bb": {"doc_hash": "23df6a600a680d729f03d8915b186bc2a18f2f9a188b887f5bf1d93412365501", "ref_doc_id": "2df91a24-28ac-4e38-ac89-756004ac32da"}, "2df91a24-28ac-4e38-ac89-756004ac32da": {"doc_hash": "cc536034e057b590ff1f6a731e6a0c70b26287122db4fe19bcce4c66f117efab"}, "b3367177-ca46-4712-a496-118b456da6a1": {"doc_hash": "316866c9c40d55f99fb39179b6a7de2171ff07546d6d505689f32bbafb7a24d6", "ref_doc_id": "647a6fd9-b454-4162-b4c0-43fcb7aebd81"}, "6bb18606-62f9-42f2-b9fe-988e7331ccb9": {"doc_hash": "c6c5955e729d674d941aab971df0617a8762afedb0802b8e2dffb26bb0f19a9d", "ref_doc_id": "647a6fd9-b454-4162-b4c0-43fcb7aebd81"}, "61d97130-d50f-4346-92f8-177bb4c2572f": {"doc_hash": "103700144585a5caf431ba23d58bf5329eecd1171123eb03a9fd9bb93a079613", "ref_doc_id": "647a6fd9-b454-4162-b4c0-43fcb7aebd81"}, "647a6fd9-b454-4162-b4c0-43fcb7aebd81": {"doc_hash": "2d5e4aa634ff1bb41186502961e243e01b71f9e3b73c235ac313ae64b34c19aa"}, "175ebbd4-c6ce-4d9f-b8d0-5dd6213dc8a6": {"doc_hash": "b29e29bcffa624dc6ca0b6d1668527e4e4eec200975b46ef83452088aa4dda52", "ref_doc_id": "fa68fa24-1cd9-4956-977c-0cec993497f9"}, "fa68fa24-1cd9-4956-977c-0cec993497f9": {"doc_hash": "4c65c74f47ba1635b8e203f5714f48dab001787aea10d35de6fc32ca46a87c02"}, "a9a22eaa-72df-41b2-bddf-56471da8553c": {"doc_hash": "ddc7bbd51fe354da2a258af3d7bd537bc1a2eda133192b96bc5cbf7cc9988e62", "ref_doc_id": "67fff742-5934-42eb-985c-f9c7b1f9511a"}, "67fff742-5934-42eb-985c-f9c7b1f9511a": {"doc_hash": "9af88a39098851b369482ba187b01d67500efefbfcf70e7cee13ebcfb949da08"}, "161ef1a3-de59-472a-bdcf-5ef96d7a39c7": {"doc_hash": "8773fe98952b2a4e27f6ab77fc06ea0774e156b990558da778a0fe5412faaa0b", "ref_doc_id": "8eab868c-53a7-4843-b798-37cc5094e4f7"}, "8eab868c-53a7-4843-b798-37cc5094e4f7": {"doc_hash": "5cb7572c49ad690ae23fe23fe55223e84d952679b7e58f8c74c9a57bdcaa90f5"}, "e2c37621-12bb-4230-a45f-77fddfff2c72": {"doc_hash": "9372b492a7bf61da6914d28ae5dfbb90cf25766ff3b007ddcb7ce642983a9fec", "ref_doc_id": "c8d1f8aa-5fdb-4a96-b021-1e0d7d044978"}, "c8d1f8aa-5fdb-4a96-b021-1e0d7d044978": {"doc_hash": "2205eba15ea57d88a42eb8c0e9a9dee4b21f7dd6a629f27a9f7544749201fcf3"}, "8cf9d884-630d-4233-a196-f67b43712194": {"doc_hash": "96097d70c196a4fbb7ee1f22c9dc1be4a370ee536d6f3eea3fc49f6ad3500ec7", "ref_doc_id": "604e3dff-9cfb-4748-9492-688e1f174d6c"}, "604e3dff-9cfb-4748-9492-688e1f174d6c": {"doc_hash": "128499c477a406e261ff143668930c3c3572fdabf8f978dab0e33fdf51e2f2d4"}, "e5a9bd15-f454-4241-bdcf-daf824d53d6f": {"doc_hash": "e4d8c616a7f208dc82c35a9fb38806b3f5b7e2253e2fa8682286ce4e574735fb", "ref_doc_id": "7d6c80d2-3afd-4df4-b6d7-0b340b392b36"}, "7d6c80d2-3afd-4df4-b6d7-0b340b392b36": {"doc_hash": "08f1557dea2e85f30cc854f99b10c5b857e088dde67b3caec2ab6100f3f7818d"}, "5e29a242-400b-454e-9bed-c3abfe771195": {"doc_hash": "2730b4f8c78bd1403aade242ec4d4503daf9ebce9659785ab03c166340b36f0d", "ref_doc_id": "e5a412a5-a9a3-4fa2-970f-bf4058bdcbe0"}, "e5a412a5-a9a3-4fa2-970f-bf4058bdcbe0": {"doc_hash": "17e5d03b81c1b42b20ee79d3da1b68ddb884ea6f3236dea80287d9f9bc729644"}, "d7a0dbe6-37da-44df-bf37-8243b7708f06": {"doc_hash": "b9f251554fc31590f4eb94eee65f90c68790c926191109f59eb7ca12c8159a70", "ref_doc_id": "9594be9a-4993-4601-9f4e-a3981d4a04c0"}, "9594be9a-4993-4601-9f4e-a3981d4a04c0": {"doc_hash": "2d4b1b17befbc053a9924e5c4baf5d1a9fe9be0d57f937d77fcbade48068e3e7"}, "7e27f9d0-840c-450f-a1fc-4fd3a1ea2816": {"doc_hash": "b3e9b26342e3fb65bec53b27f6904408273a30f9aaac3f1484d97598d29506e4", "ref_doc_id": "c0711243-08bf-4086-b9fc-5774a0ee2e25"}, "c0711243-08bf-4086-b9fc-5774a0ee2e25": {"doc_hash": "e9aa27e53fdbb433314e0d2a47ef74a2494e5c1980d076c4663ef800f947d875"}, "0295739d-bdeb-405f-84b4-e1f1cd7561cc": {"doc_hash": "1ce0942816674fcdde1c14eb1e963665f43a2f710e1892960ea1937cfa8f2de8", "ref_doc_id": "d588ffd3-5711-4f64-98f5-bf79c3956dc9"}, "d588ffd3-5711-4f64-98f5-bf79c3956dc9": {"doc_hash": "6e768e956218739b30694bd23d9939d9b61e9e8d1142455425d3255870324328"}, "b4af83a2-0ea1-400f-bb3c-2d6ca33ac8fd": {"doc_hash": "7516429302bc58eb23fc6a646a177823c2e975e8fd930234330b4ea50efef701", "ref_doc_id": "f1909eff-0d9c-4b18-852a-2dccf0ccf82f"}, "f1909eff-0d9c-4b18-852a-2dccf0ccf82f": {"doc_hash": "fed2a7b80cca3308721afe7ad2c0940e152217e35fd1724b4dc3657d672a6f8c"}, "db88b18b-bbd2-4e36-9be0-47b76709bee6": {"doc_hash": "1defd97edfbb1d62a5e3f2eacd847e7d48ad8b5ae9d54778193cc1d5a27c120e", "ref_doc_id": "410eb1d9-a93e-4c26-bc5d-183e320a0ea0"}, "410eb1d9-a93e-4c26-bc5d-183e320a0ea0": {"doc_hash": "133c3c12d3e9f4561bee587d2bf27fde91c68acfb5ab946381503b9179ecb9e6"}, "7a4b989d-98ea-41b5-9478-d71b6cc75ad7": {"doc_hash": "6775b95d223125d268143280d4a1d040aec35020b5eba7a1b621dd5d73921c41", "ref_doc_id": "c95f1c73-afa0-4f75-9e25-212c0928ef55"}, "c95f1c73-afa0-4f75-9e25-212c0928ef55": {"doc_hash": "a9a01addf0b761c2f790c51b92e218c1a08732668f73b96b2d7eee7b7dc22c3a"}, "2ec27e9f-e50f-4b55-8779-ebf63cc585a3": {"doc_hash": "b676641bf7dd5b238e7be85d474923609273e159f815d2aab2098bc86c26cf50", "ref_doc_id": "bc973d61-03ab-4256-b701-9ff350baab69"}, "bc973d61-03ab-4256-b701-9ff350baab69": {"doc_hash": "a3b5f5105af92b55a886ad2f545cf2608f7eea49feeec041b48f9ce7cfa69b1a"}, "7cc043c9-087d-4e14-bb4e-a85fb836ae3d": {"doc_hash": "3dcfd90d9afdec5ab33b5c9fe39b8bed2ce7ef413c28b7dd122e146d17fb8c18", "ref_doc_id": "a052ba0a-7806-441e-b5a2-79e6ed5fc1ea"}, "a052ba0a-7806-441e-b5a2-79e6ed5fc1ea": {"doc_hash": "04a85ed08c3d8523cf5f3eb0215cae43f4ee3a9a1da21e9c9e38c42f684fa600"}, "3bc37c15-2206-4c6e-970c-05c8906c5a24": {"doc_hash": "758e4533644c256a2509b4989010a7a6332942bd98fdd656a5dfba3e32fc8614", "ref_doc_id": "04ca65dc-19ee-4f8d-871e-331e0cd07fd1"}, "04ca65dc-19ee-4f8d-871e-331e0cd07fd1": {"doc_hash": "f8fcd1126d66f6f0d5b19a3aa1087d98685a58b243c1d5ab614cd8884984bb3c"}, "ada8da20-2fd0-4b74-b020-a02839fe7c1e": {"doc_hash": "2fd02874add4244b32c76353f8dce99da55ee11f4f4a08a768da321b0cf7ee81", "ref_doc_id": "e2b71924-c4b9-495e-80b8-b14f84ba5649"}, "e2b71924-c4b9-495e-80b8-b14f84ba5649": {"doc_hash": "825330087433d572e7c6ba2f2b865a5fbc2895d241d0b4dd4738905ceb300446"}, "203ea0e8-1a38-4e33-92d5-c96e324c103a": {"doc_hash": "f820dba420c47ce2b376b242daa272888abc8c07ee21a99a05744ce31acbe3cb", "ref_doc_id": "303eb7ae-d60c-43d0-9f1e-ae450942d931"}, "303eb7ae-d60c-43d0-9f1e-ae450942d931": {"doc_hash": "6045654fbd22e60d1b8c1715c6da916b3a7db26712aa9d9280d4677fadb54b02"}, "ed8d8cc6-c397-4dcf-bb1f-ac62c76bef4c": {"doc_hash": "71428c005c2db85cdf2efc0d6dbc7c74963e91c6cec20e1504e6eab9de59a96b", "ref_doc_id": "9de7cbd6-341b-48ee-a017-ce9ef6b84743"}, "9de7cbd6-341b-48ee-a017-ce9ef6b84743": {"doc_hash": "4eecae22d87433d2e7e0ea80b9fbfa4bd6d26cdcf8e9959877b01a8c0d2039b9"}, "55d3658c-741b-4857-b31e-bdc4c945fc73": {"doc_hash": "48474a7847d9c7857df02f34c1eb24554d20f55ac34344e86ec5342eaeb021b4", "ref_doc_id": "1a1ffe1c-b31f-44e0-8952-496d3d5a8e33"}, "1a1ffe1c-b31f-44e0-8952-496d3d5a8e33": {"doc_hash": "2890e332f373df80acf49fe55b535fc81ab41561a781da7786e49118f727f0a4"}, "a3c4e9f0-8e4a-45ad-a627-9b3099f74499": {"doc_hash": "70a7eee4766bbd083d13a4b6d7b99dd74cc343383819c436c91f1a410fc3a6b1", "ref_doc_id": "8c0d146a-8fc7-4a78-bf18-469ff90acd77"}, "8c0d146a-8fc7-4a78-bf18-469ff90acd77": {"doc_hash": "773ace0c6931f0e779ccd36ace925cc94885a954f21bd8d724f55d6c0a187a44"}, "0854306d-e195-4e08-80c6-ae7f10faac70": {"doc_hash": "955fb2b808ac0e028910d77b15109266c567e0dfa77da9ac95c7498f9a439dd7", "ref_doc_id": "50978624-76ed-4428-b2d1-6c4e0c5f8069"}, "50978624-76ed-4428-b2d1-6c4e0c5f8069": {"doc_hash": "16dae3e083991ee5cdb1cc3b4d296531e27c959e6cbb4991be85e83ca09190ba"}, "badd3ef3-55c2-43d2-b4e6-278bc6738ec6": {"doc_hash": "04f574e1e574e99297f2cdab54c01fc5b0ac4a9f230bee556524121d72023bc9", "ref_doc_id": "49051029-1266-4d0a-b451-0fc451657621"}, "49051029-1266-4d0a-b451-0fc451657621": {"doc_hash": "354138f179a1804986b0d99fbe7cbc65ba774cd5fc4a141420392333c7401ac3"}, "1d7ab131-d7d7-4c1b-a68c-733294763926": {"doc_hash": "1faf600aac3b8a41b8029a3c82201d83fc1fa5b036ec366fa0955b4c103e0e99", "ref_doc_id": "1eb4658d-9cfe-4913-b61f-448361be95af"}, "1eb4658d-9cfe-4913-b61f-448361be95af": {"doc_hash": "bd919c9bf50af39ab554d5c7c3bb6685791094266b82a96efe57785b2f89a5a2"}, "cb165726-348b-4517-9b09-4c1b1c23da88": {"doc_hash": "b0ea0afb44bd5c3d46b62e10dc44085109647fc048f5e6337c17713925e62d95", "ref_doc_id": "69e90cff-2402-440d-82bb-f3a66fad6231"}, "69e90cff-2402-440d-82bb-f3a66fad6231": {"doc_hash": "41a6af106ff85dcd6cea8b0d90a8b9c3bebe5fd218c16cf60d10538f662ed7e7"}, "12e59f0e-2b21-4476-9c81-45787e604310": {"doc_hash": "a15e2ddd7b6147d6fb041c22b5a6edb76b4166c89390935412560c654ab82291", "ref_doc_id": "ef7d7d2b-1c05-4139-a198-78fb9d94ede0"}, "ef7d7d2b-1c05-4139-a198-78fb9d94ede0": {"doc_hash": "63cc27f0ed95f661bd825c3373fd447272ca084c3c97f77b3594b866de4211e6"}, "d10134a1-7f73-4ab7-9fb0-50cf094150d9": {"doc_hash": "3dc16aebb02a75c46c4de3417ea9cb05ad5b57e2a0ac8fc6f840cba722c46ebd", "ref_doc_id": "4f852e23-ea78-46c0-978b-bbe69590e74e"}, "4f852e23-ea78-46c0-978b-bbe69590e74e": {"doc_hash": "1c1ff127dfee80c4945569ae679c2ecd18fbf2581dc5e524d5f8937bdabbd62f"}, "aed10371-6873-4344-bff5-7be16c26b32c": {"doc_hash": "73b0f934239dba581a576c052c236b8ad7aaa73a39a49a63b11dc0f057b67a05", "ref_doc_id": "77656bbd-bc68-4de4-8c05-9ee50849a589"}, "77656bbd-bc68-4de4-8c05-9ee50849a589": {"doc_hash": "8c735b5debcc893a3289e3f45399225a0190643b865c5c7bfca0c70738871cf1"}, "79460a0c-7442-488e-8677-f8281c40faf0": {"doc_hash": "9f0944834a9b7eb483cc38a42725fd0d10cf5c9e4530baf856128708f8db5ce9", "ref_doc_id": "bb4c2d88-85ce-4483-8a93-49e1cd70f087"}, "bb4c2d88-85ce-4483-8a93-49e1cd70f087": {"doc_hash": "9009f151d963c71badf57c3328e886cd37ea2e2f8d575bb3aba5cec035f18a7a"}, "7693a93f-d7c8-4dbd-b817-edd77a3c37b8": {"doc_hash": "f84ca057f19f8262db187437cb86aafbfaac0025bc1343d47b6ba80af9edfdf3", "ref_doc_id": "a0d3bda4-df0b-4927-aeab-5513dbd6db1d"}, "a0d3bda4-df0b-4927-aeab-5513dbd6db1d": {"doc_hash": "c428defe484abdbc2e6ebc54a33036566d18c078655a47407e674452fb03648e"}, "5da9da63-70ab-4849-96bc-31dc14773c87": {"doc_hash": "9473c1ae01e8a150bea4681e6e8f2b33b3c3e8c263e418024aa87beecb0baffd", "ref_doc_id": "9fb90808-1164-4490-acfe-c4bdcda136c1"}, "9fb90808-1164-4490-acfe-c4bdcda136c1": {"doc_hash": "150c2723d41f682f3972da6070c6bb299e08b337965eb82448dd810ac0df1c53"}, "91c48766-2baa-45dc-b270-50328f2e669b": {"doc_hash": "d4e9ed236cffa58fe371a07a22ae7704856d9639a992b09486114266a8a82771", "ref_doc_id": "5ffaafef-8eea-4b5c-acd1-eb84107fdc58"}, "5ffaafef-8eea-4b5c-acd1-eb84107fdc58": {"doc_hash": "d3d3f866a39ef8ec0d3286749563f2b34c33049f1fa509eeb2517b60f71b7b07"}, "f8618cb1-2e93-48ea-8fd8-d061c27568ba": {"doc_hash": "ea4d3b4304c7f87a292c8cbb725f220a41bf4c1c679c611b1e95812665323703", "ref_doc_id": "2ac76c9f-4d9f-412a-bb5a-6c842f8d5713"}, "2ac76c9f-4d9f-412a-bb5a-6c842f8d5713": {"doc_hash": "1ff97486673deb6f8d9170f45e67428070f5e04d7e26c2666da974db8b0d9072"}, "b608be89-6074-4cd6-af3f-026cbc87de60": {"doc_hash": "fa15c444868011fdb8afbf9acb24c4cf154c8fd440841f54dc1445bf17c7fa5e", "ref_doc_id": "c63f80c2-c570-421b-8ce0-1940ca05c37d"}, "c63f80c2-c570-421b-8ce0-1940ca05c37d": {"doc_hash": "3f31e5dba235477bbed3f2f2efb1e58db1bcde9f4104ecc1665cc9f8972e7ec5"}, "02a8fe9e-5e91-486d-81fd-6e18dd479d4e": {"doc_hash": "1fb4d95e1509ff88a776732f6791b9787ba32664ce7bd4f7e8f10265d0f62824", "ref_doc_id": "ffa9de92-783c-42c6-868c-a1d17e65e029"}, "ffa9de92-783c-42c6-868c-a1d17e65e029": {"doc_hash": "4199410f3d6febc9afc6eabe7d56e285a69be9570ee5e1a63577359333669ef3"}, "d19d22cc-5e34-45b9-b9b8-6919dac159da": {"doc_hash": "69a275b5fdc5f820e49da8c30717600eeaba7a1680f5eaf0561aed3cb755b2e6", "ref_doc_id": "6281d30c-9094-49ce-94cd-ee7e86a1a3b4"}, "6281d30c-9094-49ce-94cd-ee7e86a1a3b4": {"doc_hash": "4f4a7e4be3b9963013a3e0708cb5a7fe5b62939cb75ec779a734e9eba7fe76d9"}, "60c297a3-ff13-49f0-be49-3cd2e584d92c": {"doc_hash": "0e141a0abb0633c9fd1de50aa14e247f2fbe006e05ba89568c1f35c1a0844be4", "ref_doc_id": "7af1b126-3076-4e4b-8519-a4b04f0028b4"}, "7af1b126-3076-4e4b-8519-a4b04f0028b4": {"doc_hash": "175b82d324d9eecfcf73e670642dd50cd37ef77aae8a8b83468dd7b8aa1ec03f"}, "27401368-1156-49e6-b7b3-77f210675c2a": {"doc_hash": "665beec1ba7ea102f8dc44ce17148975d0e902863f7d7e5f7a4f3252bbdc07bf", "ref_doc_id": "3dc02176-5233-442e-aad0-2160b336d7af"}, "3dc02176-5233-442e-aad0-2160b336d7af": {"doc_hash": "edeaab46d2f1bd59a20f44fa7fef7794670c7d1d21390967b0cb16af092298cc"}, "858c4dd4-03c6-4538-a1e2-c19b558ed74f": {"doc_hash": "523f267dba73c9d709ff7d45f047b74d7be8bc7217757891e02881d3b21a7a62", "ref_doc_id": "705d7b9c-e513-4bf2-a12c-e575d6351af5"}, "705d7b9c-e513-4bf2-a12c-e575d6351af5": {"doc_hash": "9cb7e77e1f76cc7fd22bd8527ddea9ccd99a88440c95493d46b6e623a554bc19"}, "a456ca6f-a673-44d3-8bf4-bbd53dd36e23": {"doc_hash": "a732351b6b0d4ef38b800a687a83678a1af97746f4a0f1dc12af22310823b835", "ref_doc_id": "4c7f42a7-82b2-4c60-b171-ca377e8e1789"}, "4c7f42a7-82b2-4c60-b171-ca377e8e1789": {"doc_hash": "49a40fca8d03bfde8c3e28e435374b5369e2d1d3a996fe168e3e1a70ce70bd6b"}, "30861bb0-b1b3-4338-9c52-e3be456be249": {"doc_hash": "0162687db120678199be960672ea96224660dc64f80b48f947fa7ce72dd4a2c0", "ref_doc_id": "ca77c1c6-cd8f-4681-8d94-231176cbf803"}, "ca77c1c6-cd8f-4681-8d94-231176cbf803": {"doc_hash": "8eabdc19c4078ac05e33b3d76760d4b9d068bb41c8092d8329441f624275677e"}, "646cc39a-72cf-4bd8-96ab-4df754b2633b": {"doc_hash": "759998a073c5f015b05262f641867568e19d6f57b5464c0b95e30bd41000067e", "ref_doc_id": "b9a0fdae-09d2-46de-91f3-54cbe21e28b7"}, "b9a0fdae-09d2-46de-91f3-54cbe21e28b7": {"doc_hash": "5621d744d6b3b1a6d04349374b167681b38aea9b7cb076397f9534e98818a797"}, "cb04f768-cb76-4137-ad2b-2d2f5743c81e": {"doc_hash": "f5220d83517016df76d510abfb28e46ce948cdd278c85b3f94bc663ddd67c530", "ref_doc_id": "ed338f32-1603-4903-bff9-c727a7cbfee2"}, "ed338f32-1603-4903-bff9-c727a7cbfee2": {"doc_hash": "323f9df8d25224e55713391027c8fe8a0537fa5bd82f1e77103e9752bca99dd9"}, "22543c26-59aa-417e-8d98-6b5147520a17": {"doc_hash": "d0a9b767530a2dea153cba459894d6e656c0940b8525c215611cc7db7ca76038", "ref_doc_id": "c185283a-8098-4731-b558-0b2c1acfa9c6"}, "c185283a-8098-4731-b558-0b2c1acfa9c6": {"doc_hash": "91250bb7cce18a747af4b163d93610dfba0881a4c112871313343340d7d8c4ef"}, "278de718-a0ea-40c1-98b3-80ef20fbc00d": {"doc_hash": "0f13c3658c8f9d03a70783ae05f9590c240ace6e08b5f5aa688e1792c5e112b0", "ref_doc_id": "3b64f8c9-69bb-47ac-b057-bc8d4ec39b1e"}, "3b64f8c9-69bb-47ac-b057-bc8d4ec39b1e": {"doc_hash": "c4b796bfb46bdfe97a19368906c8055470f5d78f9a7e124ba89fb5e1f2f3f2d7"}, "91bb3afe-7d8d-4ad3-982f-c90a186b9343": {"doc_hash": "fe7349ffce97c40090c559735a5fd2ccf08932a712115737f4e7435b403a99da", "ref_doc_id": "127171e6-3173-460a-b645-06f98d71922b"}, "127171e6-3173-460a-b645-06f98d71922b": {"doc_hash": "f8773ada784d33d4110a86c784e35a6515c8d10c40af2532aebdb1073e8103ce"}, "071da336-fc3b-46a8-a333-53e1cd5a0262": {"doc_hash": "aee9923b38172460e7098b5a9b8cc242565ab56e9443037c1f58b58870c00e4a", "ref_doc_id": "b5be03dd-4331-40fe-b545-554a012f897e"}, "b5be03dd-4331-40fe-b545-554a012f897e": {"doc_hash": "faa524dad36023107303c338eb206ef3eed41c86e53175a3065856b2d39f1c58"}, "641128b1-c5c1-4480-a98f-3624f0166e87": {"doc_hash": "c7a49d6464db20bedd2fb51bc3e6040149b3f032c4979313848f4fac80b1413f", "ref_doc_id": "59382a07-93e3-494f-9dfe-e3d16d2c09e5"}, "59382a07-93e3-494f-9dfe-e3d16d2c09e5": {"doc_hash": "eb6c07136b1ed022a675c1886bf29b3fd05afb49185df2d5488761211d88320a"}, "e13143ec-3327-4262-9b33-2efb9cfc1640": {"doc_hash": "1bcca0dc4bbb4bdeeed5df5322c8b274f967aa76e96776bb9b6a1fc08f9e5a2d", "ref_doc_id": "dcbf39fc-c954-4fa8-951f-84032aebc305"}, "dcbf39fc-c954-4fa8-951f-84032aebc305": {"doc_hash": "ed85f6d51413b0d13fbf0db2e525ac0b1ee8a8fae8c0bff6e5707ccdf2d136be"}, "cf5ff60f-5424-4405-887e-c5fede17ef3b": {"doc_hash": "9bf47f7c3322677e406ad988b4a0247f4e3e48887c55a37befe9dce45f5152eb", "ref_doc_id": "93f1baf8-fb11-4b82-928a-17aefb808c38"}, "93f1baf8-fb11-4b82-928a-17aefb808c38": {"doc_hash": "215ca74f2cd18036ce6885f7801e2daff1ee4781f53fbf32b50cf18050a3a9f9"}, "74224cb7-7488-4aae-88be-ecb1cb673804": {"doc_hash": "b95bec4987b3b4700e8928f6c1011ab7d744bb010c1307a2348d81f4e896095d", "ref_doc_id": "f40f4bd7-fb4c-4649-870e-cc95f36db59e"}, "f40f4bd7-fb4c-4649-870e-cc95f36db59e": {"doc_hash": "d90c99fb104e7fb4ec0938994fed0d96e0c82b51852759c338ce2dd40b62bc99"}, "5170ac24-8e90-49af-b994-ee621ce9b141": {"doc_hash": "1a183c927d07e82aef4467ba2663d2a87dad2ac22fc5492094431d963465dc52", "ref_doc_id": "cb6baa2a-0651-4249-b97d-e74734426474"}, "cb6baa2a-0651-4249-b97d-e74734426474": {"doc_hash": "a7cf5c1520d6b894f107da2b6debcf2289e32fcdf97dc1b44bf7caa53e78aabe"}, "8fca81b1-2082-4c6f-9a38-1ddea6a798d6": {"doc_hash": "004d5004aebc3ca309531260333a1050307cf40a4efeec2a452669ef29211671", "ref_doc_id": "b3633c6d-c4d2-4691-a480-5f20f81fbb68"}, "b3633c6d-c4d2-4691-a480-5f20f81fbb68": {"doc_hash": "04d60543f164979f47bfd48839b4b556ea074d9558bfa454c0b49e22e5d66372"}, "c06449a8-6975-4212-9043-b4762d7404a4": {"doc_hash": "9a77ecfbbbd59ea3efb5ab20df1d8202e63d43ad8c68ea70e2431d8ecd7703e5", "ref_doc_id": "da5c5662-25d0-4073-928b-a64f9e191f50"}, "da5c5662-25d0-4073-928b-a64f9e191f50": {"doc_hash": "788d3859a1a3bc22fb10470351742ce9407ffc19bf1a7eefac016e62f8889149"}, "62116df0-b6c0-49e1-b512-052e6a4e05dd": {"doc_hash": "a0d7a3917888b774e1367e8dbbc61ce6ce754c5e0115f6bc126aa4f8dfefa6f9", "ref_doc_id": "6b1d719e-d81e-4c0d-b070-773bc7f81e2a"}, "6b1d719e-d81e-4c0d-b070-773bc7f81e2a": {"doc_hash": "5b7a3630bc65e30512469640a0423c6ecbd9fbd8eed33170fe7e173b63c1c7d3"}, "ac37f395-6b57-4a48-8649-ebf93692343f": {"doc_hash": "279c79a8216cb902e8dc054d8f0e81c26cbf676cfc53904b5ac7af5a6cf2e392", "ref_doc_id": "cd40d92e-a162-4430-a535-64c25ec046d6"}, "cd40d92e-a162-4430-a535-64c25ec046d6": {"doc_hash": "6dcb0bc7fb6531595542e6527c6f5815e1f4f48731ae9e7a4ff1066dc6eafc89"}, "9e66116e-851b-49ab-83ee-4d2311bd151e": {"doc_hash": "d7db60d25e8162a774bbbf3cbf4cc402e150e19ec093234c1888364f9c075b38", "ref_doc_id": "cbd9c3f5-b11d-46f2-a392-ab6feea423ac"}, "cbd9c3f5-b11d-46f2-a392-ab6feea423ac": {"doc_hash": "77b06bb5f2efbedcf7759901ae9399fdf0fb5901934e44ea6a4fc4633a1b3968"}, "86793ee8-4749-4676-a36c-2edfec61288f": {"doc_hash": "5e986cac19a6dfc55718a6a5107f06c415fa89b2b90ae0def083408882718077", "ref_doc_id": "4c73b2cd-9102-472c-9c1f-862ed23ee710"}, "4c73b2cd-9102-472c-9c1f-862ed23ee710": {"doc_hash": "d0c196608720a06c8d73c7cdcad0a56e480539ccd6271ff6bca878c54d778642"}, "8764fd38-fa2e-457e-8ea1-caddd9a93f40": {"doc_hash": "ebeb890ca268737946d34efe4e3aa09bf749d5b7f5a3c2a3d70250c90ed886ae", "ref_doc_id": "f46d0e6f-3ac7-412d-9875-5d0f14146b24"}, "f46d0e6f-3ac7-412d-9875-5d0f14146b24": {"doc_hash": "6ab94f50ac4ede691d72b82802c896df3aa6afab95ca6a8964a59fc539cd7fb3"}, "97c33909-fc15-4e5e-9718-5dc8ce7bf2ba": {"doc_hash": "449080fa6c959dec509888e63967e02f98189edde8f38f506d9a61cf8a920b4a", "ref_doc_id": "4eb6bd79-7401-4bbc-baab-39ae9633e06e"}, "4eb6bd79-7401-4bbc-baab-39ae9633e06e": {"doc_hash": "45041116445c82b991ce5fa26ba90829c4817fc9653d57c2d3b9c913dd14189d"}, "996af53f-0ea7-497e-a180-05d69e568a36": {"doc_hash": "ed00aa5bfe3df1bfa6577fa97d286f552c0e9de1b1fb879455e1601b4eaca39a", "ref_doc_id": "83f5f799-51d3-47ce-bc89-20f5e8a8d3c2"}, "83f5f799-51d3-47ce-bc89-20f5e8a8d3c2": {"doc_hash": "748a09ac6c4abb2ce59ed6af0c633311fe390cb27e5d0becc7882fbfa4de9001"}, "58823e25-5dde-4f25-806b-4a61a2cfb4f6": {"doc_hash": "82ce38d3f4f7fd2ca1770cfab3bebfb75fa67529e4b6774a22923cf3398994ce", "ref_doc_id": "0dd7b6e0-3bff-492e-9bcd-6d9726569b26"}, "0dd7b6e0-3bff-492e-9bcd-6d9726569b26": {"doc_hash": "a2717c62b2722eaec3dcd4ab83abe946db3b7d324cfa6ad1a1be634577c996f8"}, "ca2e1001-268b-4b6a-a728-b3adcfd23c29": {"doc_hash": "cafb6a7ddfacff7a1dbe25b70373c4da1346d98d132c05e501e453d62d635906", "ref_doc_id": "19c6ff98-622a-42ea-9bf3-2dad2f7ef57e"}, "19c6ff98-622a-42ea-9bf3-2dad2f7ef57e": {"doc_hash": "d24aa371e5bed28cb79df828f8034faf7106e908f4c0ae735baf81464615de06"}, "52e7fb52-5411-49c9-9ba6-a25ae44e5ea8": {"doc_hash": "6ab1a5110d74031dc44592e42628a5fecd6119972d95e0eefa2ee2c6a4653f06", "ref_doc_id": "3c0ee000-3ca0-4edc-a8af-85115afa2540"}, "3c0ee000-3ca0-4edc-a8af-85115afa2540": {"doc_hash": "578a80d64bf24787dd38fba5103cdf1d1fc39ae3cfa67cc3a7fc097aeeee0d5b"}, "b1836881-d30c-4070-b5fb-06881e0f0b18": {"doc_hash": "277b0585940d283da47caffd2832761270c2b4f9fc20abd122c7376819688878", "ref_doc_id": "90d37a5a-fe77-4920-8a91-84b732181f90"}, "90d37a5a-fe77-4920-8a91-84b732181f90": {"doc_hash": "84f89ba4832f90a9be8647d3246e6cac422ec22a708535163224b4f21bbb30b4"}, "04c665a0-1caa-4fc1-9bdd-64dd8ab1a7e0": {"doc_hash": "e8d50f05f6071057f462e15c5555066b562abb1f5728f296eb1d87a6ec004401", "ref_doc_id": "9e62ee3d-a66e-494d-af12-8a3dd42d23da"}, "9e62ee3d-a66e-494d-af12-8a3dd42d23da": {"doc_hash": "162a03e621beda90fbd9b7f1fd7ff9f713852709aec804543ae94700c05337d1"}, "a70868ec-d47e-4989-aa2f-69383fd64762": {"doc_hash": "8228b6ab533568dc9d4717fed8e653a44a8a3cf66b26f3acc8fc91add84047e5", "ref_doc_id": "25be472e-b57f-467e-a0a3-2bff21539873"}, "25be472e-b57f-467e-a0a3-2bff21539873": {"doc_hash": "9df1f648b1dcfa725a5d71a77a26789cd8a14348d8638ad908c309304bc01ea6"}, "eb2f8f52-4785-4671-a5b6-747c67e9818a": {"doc_hash": "3f4be900c81c454df0eb4a04814fbe10f6ff90b8f3290d80fe5e4ea1dc77222f", "ref_doc_id": "19e6964e-bff5-4869-8ba4-d52bcdebb4ab"}, "19e6964e-bff5-4869-8ba4-d52bcdebb4ab": {"doc_hash": "61fba6da617855eec3527a1099631cecc1166ad8e9b2e6ff8ec44dc860098b47"}, "599b0f5e-5cf2-49a4-a5e7-7011b1f9c18f": {"doc_hash": "13fbb6b141b08a347215659e03eb14c1512128443eae20bb0ccd66a3aa4bb81e", "ref_doc_id": "669342df-2b2c-4d9c-bdac-b0f912f1fe30"}, "669342df-2b2c-4d9c-bdac-b0f912f1fe30": {"doc_hash": "2d987ac54660f95f10ff3430b814b94428b5d16628ece9f85fc975af1c6a972a"}, "469d5b59-9675-4594-ae11-e1381cd77c41": {"doc_hash": "b9128faa6147d66e6f9e9bf35b20ef47baffcca558790a378dde42bab4b2faf1", "ref_doc_id": "1fd7e7a1-cb63-48c4-9a28-39c82ff0ca8a"}, "1fd7e7a1-cb63-48c4-9a28-39c82ff0ca8a": {"doc_hash": "1016290490441f0a68d3b6d0a474fd955bbc88a4169c3ab0a9895e9ba193adf4"}, "128cf749-6187-459c-b09b-3df303f25c8f": {"doc_hash": "31daee97f8c2c366ab8507cc99b8a4d058f0deabcef5887a41142b8ac5ea24fa", "ref_doc_id": "cddb3235-1001-41fa-bc72-c1ad06299205"}, "cddb3235-1001-41fa-bc72-c1ad06299205": {"doc_hash": "31f6ed8bc62624b5530003fc734de10ce78fc7318eeb8b1e88054cb5811c489a"}, "84317923-e22f-4950-afa1-73e8ad3102f7": {"doc_hash": "ec40b547c569c158bc617a99ab6052800d4bac407a658f2a4422e9569f1f5251", "ref_doc_id": "6f38b185-7980-4472-b1df-2eb3478c44b0"}, "6f38b185-7980-4472-b1df-2eb3478c44b0": {"doc_hash": "7755ee828dad486a3cf754067b7e82495265347ce8ce663d70e3567303430d59"}, "45756963-9ac8-444b-b4e3-ad5e0ce50713": {"doc_hash": "13a1c087d239b53b0e8b0670c217c640c077bd9f2cbdd2b89cc61e1663be0832", "ref_doc_id": "939e5208-454f-425a-91bb-d09feb69d5aa"}, "939e5208-454f-425a-91bb-d09feb69d5aa": {"doc_hash": "72a1d34a6ea9cf1358540784924fc5635be410818b6be25bf1063e791d2bf9b0"}, "59c97513-2916-4a31-88cd-77e311d4a509": {"doc_hash": "1027838b58998a833f6ee97988420630e8ef392b9ef59b85c38b11da7d8f1a9e", "ref_doc_id": "e295a05a-ef97-4221-b144-c2623f6c84b7"}, "e295a05a-ef97-4221-b144-c2623f6c84b7": {"doc_hash": "cabd3d310b15961eb684c212fa3e83dd87f8f733da14902f9a302711cae6c865"}, "2ee10ff0-2793-45dd-a2ec-7b84ace9ac86": {"doc_hash": "6ea66618ac0168b64ca86749323f4304e62163b57bc96becc565fb47c45891d5", "ref_doc_id": "e5c904aa-949f-44e8-811a-cd3774c005b4"}, "e5c904aa-949f-44e8-811a-cd3774c005b4": {"doc_hash": "b7fb3e581c89b306e4fbe0575b62b0fb9942a33cee4ffedc4711531580f82d29"}, "646efacf-af6c-4a6d-9f42-aceea70f4ad2": {"doc_hash": "fa890ca52c42e81a2d9bc75554a144d62bf7378376769367f86b1254526d8748", "ref_doc_id": "48258350-76fa-4167-b6cd-bae13c800e09"}, "48258350-76fa-4167-b6cd-bae13c800e09": {"doc_hash": "ee3fe7b3b8335abb1547fd12e7671e54d7546685178f58c5f23fb86cb7453dff"}, "34b2146f-5ea4-4c5e-8ae0-edf6deeadfc4": {"doc_hash": "0dd4f472e215c9c08a8047d89c19e773b1cb991f7223dd13dbc9f2330a7f419c", "ref_doc_id": "33da2ebd-e32d-40ba-ac2a-d174cc1e3ebe"}, "33da2ebd-e32d-40ba-ac2a-d174cc1e3ebe": {"doc_hash": "2978e5693e3789d455f630d456b268be700b18af6c7784677d692f64a011e7f6"}, "f30d40fb-eda5-4559-9745-444821221cf6": {"doc_hash": "7e511f2747f1a34f2ecaafabdc47cffb2eca1a31cf5757dc4c8bc1b09c192a2b", "ref_doc_id": "73228003-e787-4615-a44d-033503047e99"}, "73228003-e787-4615-a44d-033503047e99": {"doc_hash": "c256d7bd9a626d903e286c5d0ab51c5e8be471c9aae97bc1021d288d830f68d4"}, "69a4265d-3b93-45d3-8af6-69859f9e568b": {"doc_hash": "9f1b862c6f0e3b76b6e0b87cd976051b1b7cb4fe9bc4c2403d221dedfae67fa0", "ref_doc_id": "4434854c-9367-4f0e-b2be-f7c2221adc4b"}, "4434854c-9367-4f0e-b2be-f7c2221adc4b": {"doc_hash": "aa2d9418ec8872d299ba882b8dcdea8d99c08ecf67661f45256d300e9738e904"}, "2f672f72-a271-4818-91fc-75d665313048": {"doc_hash": "4e32f208ba6b2ad71dd1958228712ad62def8a320073e1dcbe6ff8733eaee3ac", "ref_doc_id": "72d10b89-eb31-4cb8-9c01-b03f54b44249"}, "72d10b89-eb31-4cb8-9c01-b03f54b44249": {"doc_hash": "aa36d8d28d53b5d0f6276da6326b71b8c4bdb2707f6171c5f86c16be92e2bfc9"}, "c5dddb36-bd7f-44c5-b793-174ddd23c71e": {"doc_hash": "b9a7041e6a35b6498c603f70da7519d65dda1f9f0f3039d00bc3c79586a1fa22", "ref_doc_id": "17758270-c0e7-47dc-988c-4002cbf424be"}, "17758270-c0e7-47dc-988c-4002cbf424be": {"doc_hash": "37d70966ec75c923f0fde9638c7e7d0d8fb9ca98601516cf418034bdffd411c7"}, "d42b69b5-696f-4b08-846d-bf9a21345083": {"doc_hash": "fa15c08a53d6c94ac8bfb92f51ad3bd789aaf72c132ede2cb940546fa91e1a6e", "ref_doc_id": "6acf0f39-2664-4b48-a183-7ebdc425a1bb"}, "6acf0f39-2664-4b48-a183-7ebdc425a1bb": {"doc_hash": "ee42609eaf48ddc09747273bbacc1fbdc8085ba2a5a34483db76f6859ff22fd1"}, "523f5a89-5d59-4470-b448-224a1e0cfdb7": {"doc_hash": "7feab07c02c8261ca55a26660a206f231cb28b47fcf0ad7d72ea136861e60a0f", "ref_doc_id": "0d14f415-4b38-4518-8dae-455008022f25"}, "0d14f415-4b38-4518-8dae-455008022f25": {"doc_hash": "eb508b498e20cb7b7dd2b11d123e7dbc8da07a7efdb436077d9eaa0905135dfc"}, "4ffa4832-66a9-4dbf-b27a-3722873587c0": {"doc_hash": "ac6f84e0d24c381bc1997166246d6d817ec52cbc2f77e42799ef6311bbf7d58b", "ref_doc_id": "1c711c7f-ff23-40c5-bd38-eb70598b4a1e"}, "1c711c7f-ff23-40c5-bd38-eb70598b4a1e": {"doc_hash": "009f928fcbbef2304eec165d1ea7c2161319bd120d97ade9bb5a96dafa9e2562"}, "4ebbcc25-4af3-47f4-a58d-002e33921b0d": {"doc_hash": "ad4eb04d336d53df786796e559b5852cbab5fa1e753f5258d348e7fbfa702a7b", "ref_doc_id": "f21175c6-424b-4b64-958a-8f21186e4afa"}, "f21175c6-424b-4b64-958a-8f21186e4afa": {"doc_hash": "385ea794058573d87ca49fd900e608c6cf47e2096d7eb897820bac376ce2663d"}, "a60c5149-5566-44e2-939c-6306e2bed813": {"doc_hash": "268f8b8f53bae58366222f5de4cc67ac3b58dbc8109e664dcaff6923c5421f00", "ref_doc_id": "6a59186f-e4e9-45db-b3bc-f85efd26cc7e"}, "6a59186f-e4e9-45db-b3bc-f85efd26cc7e": {"doc_hash": "235d67be93839c380307c3035a25274e144efad37bfd97349cce3a507d6544d5"}, "12cafe24-5da5-4457-84bb-6a19b54c959f": {"doc_hash": "99b47c8d7deff636ddd9d30426c0206e702f4bd85c9d058df0c4e99e1c4481c5", "ref_doc_id": "2531f001-a201-4dd6-af9c-3e29d31ca7dc"}, "2531f001-a201-4dd6-af9c-3e29d31ca7dc": {"doc_hash": "8a99e574cd6acd456836d453cfa2235789283f0db5b6d5dbdd25d928ec260f9f"}, "27c12973-f4e5-490d-8021-e263eb8d537a": {"doc_hash": "fe0f2d2abc8b3334f55a901c3c4aba1571882da4370fac8ee6c067d793c0895d", "ref_doc_id": "e9d15365-a661-4a07-bdc1-013e8a80f126"}, "e9d15365-a661-4a07-bdc1-013e8a80f126": {"doc_hash": "17079147211d519e491320868353aa33bcd3a6b256f2e562d5904cf59590fcf3"}, "e458261a-a397-43af-a5e8-4e6ae2eb564b": {"doc_hash": "4447b7907bacc50497e9a1bb0f4e70d15eeb97768137e3e86bed951fd3923120", "ref_doc_id": "b621d243-0fc9-494a-8fda-4a32e6f52a23"}, "b621d243-0fc9-494a-8fda-4a32e6f52a23": {"doc_hash": "0163276c1f3815b0bf0911719c5ae8400c2452213f256e0ea4c3eabd0a6c9fbe"}, "cee367f0-e76c-408d-b541-05e1c5eb2358": {"doc_hash": "906f06a313281b78f8de412acaaca383690cb2824d0670586cbe2f5b3c07349d", "ref_doc_id": "e3417fe4-bc5f-4c5a-9f49-7b002c7cb787"}, "e3417fe4-bc5f-4c5a-9f49-7b002c7cb787": {"doc_hash": "879a5a72db17d4a1b91d0c6587f53ee35cce367585e426103f55604d1d327b2f"}, "58e64269-15a9-4777-aa73-26465e12b76c": {"doc_hash": "09be250d06059788b979e7a799bf9f017d882f4694e46f95c14a39d5eb23fd97", "ref_doc_id": "402fe40b-9634-47e3-a037-049bc76075e1"}, "402fe40b-9634-47e3-a037-049bc76075e1": {"doc_hash": "9c2cc3d901f0567bf9a642c35ca66456e84c41eb68c1c8ae4717141fb1f9497f"}, "97afab4b-43f6-44ef-8ae9-4e43c97259cc": {"doc_hash": "872481f56d9bbdc567b45cc0da0d585515030d8d2dd1ddf9ece5b5cbc5d63f43", "ref_doc_id": "a355d13d-c35f-4495-a9c1-d5c467ca07bc"}, "b6484a01-873f-44b7-b1e9-0208c41590f1": {"doc_hash": "89f64b1dc3e222623b68ebf42fbae7c8e94ad5510ee884ee28f96d303e57c72f", "ref_doc_id": "a355d13d-c35f-4495-a9c1-d5c467ca07bc"}, "a355d13d-c35f-4495-a9c1-d5c467ca07bc": {"doc_hash": "d86d5f3a116eb954087b4a1a1728515e17dc087ad6a5657fbf67814141b4ac06"}, "e2f712ad-6951-4f00-adf8-32babc2f3230": {"doc_hash": "052d4008e8b628535fb0f13fcc318760685742572189dcc6d6dfb7a3282fb199", "ref_doc_id": "0d76b273-6e97-4b3d-aab6-4c6a4342ecb1"}, "0d76b273-6e97-4b3d-aab6-4c6a4342ecb1": {"doc_hash": "9d04f7239fe876631dc720182e3c114366ffb21a2591690fc1a5a38c685c78ea"}, "14beb169-576e-44ed-9393-8b7cd1da657c": {"doc_hash": "ebc92c1e7e402dafe8da3d73022a8326724d70ae2e155daed7f654e8cdab0034", "ref_doc_id": "6c407c51-3177-4082-bb99-bcf26f067b6f"}, "6c407c51-3177-4082-bb99-bcf26f067b6f": {"doc_hash": "7c0cb497c589404956a2c94a343ef43ca0cd1f22ea228a19b2c3026f2c75726a"}, "7e64662b-9397-4871-900d-e40ed842e5ba": {"doc_hash": "a625fe1956eb50fc9e476301dfec251912ed740b7226e132daf14ad7d392b28e", "ref_doc_id": "dfd585fd-2aeb-42fe-83d6-b647a023dcca"}, "dfd585fd-2aeb-42fe-83d6-b647a023dcca": {"doc_hash": "cf36f7c9d9cbc176eae400f3eb7d9efd2111cf6755b074e5b9e1eab77a553a5e"}, "ebe0791b-8306-4fbc-a1d3-14ce70c92eee": {"doc_hash": "0525684cf5aef19e52bd4b8c0f6034d5e85615a43873a9af546f334715245cd6", "ref_doc_id": "1c967c1c-a8b9-4078-b929-e41ea71ac58c"}, "1c967c1c-a8b9-4078-b929-e41ea71ac58c": {"doc_hash": "8bbc51bc3947be3931262379bb23975ea8c9085e598e82aebc94cac3fff7614a"}, "80b2ce00-1fb2-46f9-98b6-e66bbd50d2ca": {"doc_hash": "1741989add07ebb0499b1358717ddd9ecffcee0fa67fda68aa678c5025746cbe", "ref_doc_id": "a76799eb-c710-40b2-b21d-a601ca7a2d6c"}, "a76799eb-c710-40b2-b21d-a601ca7a2d6c": {"doc_hash": "ba09b967cd80e28f45a0b3ecfb2d3ec9267c67f26e0a33d0aeda82bf36de0144"}, "a00bd1cd-1b65-4582-9884-dfebbc5691a0": {"doc_hash": "e14ce813e1c0b08bcd17f75bc9ff2224c1d292683f2ea4defae9f1e24b2b56b1", "ref_doc_id": "ae24197c-ac35-457e-986a-db3417e71d36"}, "ae24197c-ac35-457e-986a-db3417e71d36": {"doc_hash": "875516016558388173dac168493531a16d6a3f232cf3975590a0c913936c61dc"}, "db8ad31e-dd89-4e7b-ac26-db5e41dcd890": {"doc_hash": "483b0010bdefee0f8daa8965785a71b8682c0bf0be5240edfac3c44b30cdd7f5", "ref_doc_id": "5be4c870-821d-4623-928b-9bbfc104d08f"}, "5be4c870-821d-4623-928b-9bbfc104d08f": {"doc_hash": "89c1250a4b3c713dee5ced2f683dc071bfac294dfaa1485c73a03ca728798cde"}, "6af41ec4-1565-4b51-b0df-eb3b84d54150": {"doc_hash": "246cfad30e5ad7b514d90f6f49f17502b8629149d0f5de7fe3e666cf27b7b716", "ref_doc_id": "da5d409b-7c47-47fd-9955-4bb79c6df24c"}, "da5d409b-7c47-47fd-9955-4bb79c6df24c": {"doc_hash": "7555861697fbb9300f46b9af5a067ff2f55000adb6e359faf697cd172d3b6e20"}, "c97c0258-8bd8-4197-bb65-9aa913f0fc25": {"doc_hash": "3d4554450d3030b2766956262ac72bf0b6808778030e1c0a0aef13053c652705", "ref_doc_id": "cb9ea2e3-17e9-4a63-b60d-b18b25eaf6ec"}, "cb9ea2e3-17e9-4a63-b60d-b18b25eaf6ec": {"doc_hash": "00e1198ca8379a765c1cbe35ef61c2765fe0847002c17d86610a656f97f83ed5"}, "bc876dc0-eed3-4ab6-a914-b3e9e8f70aeb": {"doc_hash": "69ebf49f581cb0468f368b889eec8f1748b3e3ff54dc141c4d680441e7ec9ce2", "ref_doc_id": "0c7a9cac-5c95-4186-842b-c8bc49e72b5c"}, "0c7a9cac-5c95-4186-842b-c8bc49e72b5c": {"doc_hash": "58d5c64c56ce7b265a4c574b4ecb806126d9401995f7aa8e7ce805c59ae27950"}, "36a84414-001e-436b-bd7b-983b46d678bd": {"doc_hash": "76d7230a69bba8ab28a966e12b717da5b6ecf49b643fc991d5f6b882ae8b9f3f", "ref_doc_id": "bc55620b-1b33-4da4-8eb3-bc237bd7fb1c"}, "bc55620b-1b33-4da4-8eb3-bc237bd7fb1c": {"doc_hash": "743c492c75cfc3a56e85a5b50b5e1308e5f69a4aa83a24d84f6f8b9426810e55"}, "c0fd5afc-cd48-4332-bd7e-eb58b398460b": {"doc_hash": "7337e54d0f18e1295df80ec16923273ab023913c78cf6ea7d16b26fb10e1553d", "ref_doc_id": "81eb9ea2-429e-4fd8-b027-442f79c1f171"}, "81eb9ea2-429e-4fd8-b027-442f79c1f171": {"doc_hash": "0dcc52cb1d7c5107f24df357e4bc10105f745af675120ab34e586679a37fee21"}}, "docstore/ref_doc_info": {"b4e94d5d-2aef-4b77-8b7c-ff7872c77e70": {"node_ids": ["dead65d2-4a16-4114-a700-20e926cbfb02"], "metadata": {}}, "f6ced86c-4f72-429c-9fbb-e50a4a053870": {"node_ids": ["9feabfdf-ad6f-48b1-b4aa-c061f50d3d39"], "metadata": {}}, "c1d81e2e-c2b9-463b-8e6a-d535887f6abc": {"node_ids": ["71f33c2f-9a04-4dcb-b01d-c6404314d105"], "metadata": {}}, "5f198ad2-03ab-4461-adc6-adcfd4d6a7ff": {"node_ids": ["61e6289e-f8ae-4d7e-af6b-c7bba3a213e1"], "metadata": {}}, "0610fd12-2d82-4a57-bbab-a94e2a5fa49e": {"node_ids": ["3fd9424c-6ad1-46f6-a087-0a055bf18433", "4b11c241-e09c-4545-bd09-085fb192008d"], "metadata": {}}, "67052d51-008b-4f89-8154-e1d1daab828a": {"node_ids": ["df1a9e13-4474-4a3e-b62d-433c290be0e5"], "metadata": {}}, "4407efa6-95f2-4009-9f2a-85c074e6ec65": {"node_ids": ["f279a4ce-c12c-4938-8ac2-00203e41effa"], "metadata": {}}, "e48ebc70-934e-45d1-a376-129e4cd12b42": {"node_ids": ["d9542073-3613-48ea-bfd9-3ff82b2f3f27"], "metadata": {}}, "fb052d08-d0da-4f5e-afb7-8f00241632c3": {"node_ids": ["00ec58f7-84ea-471e-91d9-4342529b94ee"], "metadata": {}}, "7bfd973f-4325-4343-8375-e51d9c8847d3": {"node_ids": ["24883fe8-b867-4916-821e-7c0f663ac866"], "metadata": {}}, "1a222615-2d2e-4ba6-bebb-ac0acced7636": {"node_ids": ["563a45bc-8b7c-4951-bc17-aeb6e669b213"], "metadata": {}}, "a26fa20e-964e-4c0f-a467-fbe19148db1c": {"node_ids": ["5514f072-f52d-4890-9b95-c2c1958df6a5"], "metadata": {}}, "58e46aeb-0142-4d77-a6b5-b7de3ca14a69": {"node_ids": ["d1a47896-4381-4bd6-a0d0-d7b40af3244e"], "metadata": {}}, "1c8b96aa-e750-4045-a4e1-591cd67e2304": {"node_ids": ["cb61c533-0550-48a6-809c-98a2e4237b62"], "metadata": {}}, "809b1ad0-7a76-41c0-873c-32be1e1400a3": {"node_ids": ["708368ad-12f0-4722-ad14-60dda632db19"], "metadata": {}}, "f0fe8be9-53a4-4d90-ab6d-aba6bcd91bac": {"node_ids": ["1c21ba90-2ded-4553-ad9a-65207ed80a19"], "metadata": {}}, "3974bc6e-a2b0-4812-a41d-b34caad2d2b5": {"node_ids": ["0d0a2e1c-adcd-4ca5-81bf-aaa9beac444b"], "metadata": {}}, "ea8a8540-7a11-4cd9-8d6a-6b31c15c9049": {"node_ids": ["f186f07e-e395-4c8c-8059-334950f62c51"], "metadata": {}}, "e650852b-5670-4ca2-b458-1cd08cd0ea20": {"node_ids": ["34058055-31a5-41ed-87c9-6580b865413e"], "metadata": {}}, "c605b6a2-9cff-440b-a81c-46f5fbf63b85": {"node_ids": ["b9ba94b7-1da2-4c21-9625-4c556af5e5a4"], "metadata": {}}, "58c80c45-b624-4a73-aaff-dd37a8a9d73e": {"node_ids": ["0b147dfa-a033-4b83-a31f-451dc1646986"], "metadata": {}}, "2be702ef-686f-4c6b-ab06-85c00b9ddc23": {"node_ids": ["57b764fc-d315-4f0d-b90b-47e3929d1fe1"], "metadata": {}}, "83d25222-b11e-4ec0-a0a8-e5558ed5cd8b": {"node_ids": ["32aaaa74-8688-40bd-99c0-f56e9840ddc5"], "metadata": {}}, "61fe7159-cd8c-4466-98ca-61af78aad400": {"node_ids": ["5c6e6275-45bb-40db-b2b4-d2c235776fb9"], "metadata": {}}, "99ad159a-f1e2-4836-a6a4-433d3603ac29": {"node_ids": ["cff34956-de04-4eed-b14f-d6f70b0bdf19"], "metadata": {}}, "38dace05-21ee-4c13-89f2-6236f79d170e": {"node_ids": ["92b5e2ab-7452-49ad-bdf8-1a91b1299d9c"], "metadata": {}}, "b5deb37c-93be-40e4-a39d-0b67d3c481d7": {"node_ids": ["7aa83ea5-6c1d-4f4a-9042-c28dbd2af802"], "metadata": {}}, "9562521f-463f-403e-8619-715d9ae99b41": {"node_ids": ["e4c5b343-fd3e-42e6-bcc1-41d087fc455c"], "metadata": {}}, "a2da8790-b411-43af-ab7e-9e7591621ee6": {"node_ids": ["afc030f5-3ce0-471b-b6d1-7f11d42018c1"], "metadata": {}}, "c00a8094-b323-4998-9eca-942c63c6cfb1": {"node_ids": ["1c05ee29-e94a-4a6e-b6fe-e15b01ab43b0"], "metadata": {}}, "53a501b8-8ab8-4aea-9c40-4d7ecbb16f09": {"node_ids": ["6e9f1cd1-5ec6-456b-ae9b-3ba095960c24"], "metadata": {}}, "c2778437-5427-4022-8ecd-fe6935941285": {"node_ids": ["608420b8-992d-4e2c-a8c2-9e6e239cdd1d"], "metadata": {}}, "058d49b5-6266-4528-816c-fd42c4016797": {"node_ids": ["45461118-4020-4448-9c5a-0f8936552ad4"], "metadata": {}}, "f2746f9b-0a23-4d91-b658-3a37569a2275": {"node_ids": ["aaeba83e-e4a6-4f44-8a28-5974fd74ab5b"], "metadata": {}}, "7318402d-2773-4f3d-b1c5-121256b95d5d": {"node_ids": ["898d4564-10e1-4a60-86ee-90d68fc226a4"], "metadata": {}}, "77e5aa73-4800-4c76-9603-42afe8f66907": {"node_ids": ["1d0de13c-b3a0-49db-95a6-020a46cfe66e"], "metadata": {}}, "a520791c-9866-4cf3-a82f-9f303c1ce8b9": {"node_ids": ["16156a5c-3863-4134-87b8-0dba8ca24772"], "metadata": {}}, "940c0067-7952-4ea8-9cbe-309bbd801ed7": {"node_ids": ["a2cc456a-2bd8-4af2-a9df-acb511448c85"], "metadata": {}}, "417f4b3f-3b6a-419b-9d9c-beb88f34b630": {"node_ids": ["ff6fc434-a447-45ff-b5da-d16a0b925bc9"], "metadata": {}}, "1ec34bbc-b547-4d43-84aa-ae2ff2a80a0f": {"node_ids": ["b0f9943b-4f48-42a7-8c82-02192273fb58"], "metadata": {}}, "aa21149b-e1ab-4fda-9eda-c309d4cc8a23": {"node_ids": ["3343926b-6c5e-4dd0-b83a-027f06cbf5f8"], "metadata": {}}, "256707a6-0549-4385-bd3f-e03e6b6f9de5": {"node_ids": ["ca104edf-c6b9-4069-8858-2b8dd8437fc1"], "metadata": {}}, "d12442a9-f9c2-465b-a04e-48fee91f3265": {"node_ids": ["2dca516b-3a82-4d7d-bea4-ac2d0c4aff45"], "metadata": {}}, "0ffd3982-f064-48d5-a68b-797a71b399d1": {"node_ids": ["5a76c44d-79db-40a8-b1f6-69e35ce2b3ab"], "metadata": {}}, "726f98ec-f991-4cdf-a0c6-1623c03380db": {"node_ids": ["de0808f0-3c90-4141-a6b6-bae9a1423e36"], "metadata": {}}, "4d6872a6-1959-4f57-8cbf-eb2a1e423908": {"node_ids": ["f0708548-fb19-4026-8326-99cd57fb8bb1"], "metadata": {}}, "09121923-dafd-430e-85fa-27f0d1c5c108": {"node_ids": ["04282650-be8e-465b-87b0-2c57c7c5d22c"], "metadata": {}}, "52ffb245-526f-4653-82dd-f004fdf72f09": {"node_ids": ["fadd678c-faee-43ba-9bf0-ed792f5b70b8"], "metadata": {}}, "365adf3d-99f8-4c13-b44b-3b1fe312ba22": {"node_ids": ["97acb953-74bd-45f7-9e55-406c762eb3ec"], "metadata": {}}, "dd7ef8a7-8687-4e4e-a28d-44a3de999039": {"node_ids": ["f5b83331-b18a-4d0d-9bb5-8e40854b9edd"], "metadata": {}}, "1ac01e08-3616-4d38-84fa-64cce6dec27d": {"node_ids": ["3fc6684c-cb83-47af-b4dd-9c6c031852f1"], "metadata": {}}, "89eda4d2-0ecf-421f-bd59-bddbb1396dfc": {"node_ids": ["9160f2a0-a411-4c1b-9908-38e38c9f4478"], "metadata": {}}, "43b50e3f-a302-4fb8-ac40-11f06fc61919": {"node_ids": ["91e1da35-e0f0-45d7-8299-42ef5768fcc5"], "metadata": {}}, "6776b70a-5c1b-4edc-8dff-e6feea74f170": {"node_ids": ["ddd5236b-0ff1-4b0e-aa15-7b55b1a4180c"], "metadata": {}}, "2d9178b5-acea-41c4-9857-b20031c9f6b9": {"node_ids": ["71043004-cf5f-4e7b-8f2e-e057d118fedf"], "metadata": {}}, "c4a87ce8-0d6d-42ff-8a52-580d353756da": {"node_ids": ["3517aee2-144d-46e7-b9b5-4a3c97007fdf"], "metadata": {}}, "a7e15a6b-4dde-49da-bcd3-2ce3e14c8098": {"node_ids": ["4519ac59-dfd5-47c3-848a-94486cff1217"], "metadata": {}}, "8f2d85bc-2dda-4ba2-b52e-e4f0f00a9a9e": {"node_ids": ["53003f8f-bb03-4728-9f31-81415858c275"], "metadata": {}}, "c3c798b5-c291-4b60-8bdb-e814cab0fe4e": {"node_ids": ["b92c6267-7625-49ec-9d2c-e255b0040dd1"], "metadata": {}}, "2689b1c7-2c21-461e-b7ca-54f1e8659f69": {"node_ids": ["be3fce81-875c-47e7-b9fb-0c9658eacdd3"], "metadata": {}}, "9625f6bd-9e33-4642-9127-a55ae53f6a08": {"node_ids": ["f0de95fb-8e3e-45ba-9393-04d96bdfdb7a"], "metadata": {}}, "9fc92f02-de3e-4b70-8a5d-67aeae3d7304": {"node_ids": ["34fd9d9c-00ee-424d-8f08-c2cf28453ca0"], "metadata": {}}, "65827295-3c23-4dcb-b5eb-6ead1499cc0b": {"node_ids": ["08ee7821-4ac3-4dfe-aa24-74446cc35f2d"], "metadata": {}}, "f7aa0047-39c8-4916-8675-b6fd9ac65235": {"node_ids": ["be1e99b9-d90d-487f-85a7-acd5bb65a9f6"], "metadata": {}}, "62a7717e-0078-4fd9-a9a9-eb8bf84d8a73": {"node_ids": ["7b340ae2-180d-4cbd-994d-5cdb170541b8"], "metadata": {}}, "651879fe-13df-40ee-9ed5-164166a9c755": {"node_ids": ["d487ea4d-4a1b-4b20-9b7d-dba51e362ff3"], "metadata": {}}, "7c7f2b04-5d9a-46be-9608-7ba0aaa1e12c": {"node_ids": ["f84a4ac0-c222-4dab-a400-9e7149760cbf"], "metadata": {}}, "5d33be96-697b-43fb-888a-6885fa98dd22": {"node_ids": ["0b3cdaf5-d7e9-43db-88d2-e22115be275e"], "metadata": {}}, "9fc140ae-0d86-44a1-85c3-e8f57bffbc5f": {"node_ids": ["53abd67b-b1a8-4f7a-ac9b-5d17d9bdb393"], "metadata": {}}, "07213341-1d6b-4965-993d-19d398da6154": {"node_ids": ["2f129b99-55f0-4f14-8eea-60befaee57ce"], "metadata": {}}, "af051c0a-ad14-4dc3-aead-8544b3fa076d": {"node_ids": ["3b3a77f2-aaf5-409e-a207-6342b8b7340d"], "metadata": {}}, "d2209471-ff08-4980-8a7b-1cb17462b2de": {"node_ids": ["b6d43193-d89f-41ef-aece-3731dcec1e28"], "metadata": {}}, "5bee927f-748e-45d2-9212-186165e967b6": {"node_ids": ["b4f2403e-350b-4e04-9a5e-76d12ee9df55"], "metadata": {}}, "31d78f62-b563-4fc8-8543-928e02a1468e": {"node_ids": ["0402c027-5614-4ac7-87f3-62750199200a"], "metadata": {}}, "ee46d1c2-e402-4980-8f84-4c4faf4d8cde": {"node_ids": ["5365dc19-037d-4cc7-9d07-b0645f84e8ea"], "metadata": {}}, "d7e52f96-d83d-49a1-95cc-1b70fc24d4c5": {"node_ids": ["60ab5a64-c59a-4f02-b2cf-86dd888e4e85"], "metadata": {}}, "1389bb08-82b4-4a6f-b5d1-1fc4d7d19df9": {"node_ids": ["4143cab1-d718-4368-9ea0-23bc7374f70f"], "metadata": {}}, "2330ae9a-ea50-4685-b922-b7253a2fee4b": {"node_ids": ["d0d82868-6a88-4ff8-8bf4-522a215a1945"], "metadata": {}}, "c25a1a3d-8fe1-46a4-a7ac-c4f1be69b49e": {"node_ids": ["87e17769-74d4-4655-9d53-195c0a05d1ef"], "metadata": {}}, "9b6bf889-c931-4066-969a-7aa49b8f4b75": {"node_ids": ["31966f3b-428d-4781-bdc4-8c7a16d84c90"], "metadata": {}}, "560e756f-52fd-46a1-a16a-184f0cad5e93": {"node_ids": ["0f0d05cb-c799-410b-8ede-9538d4347cae"], "metadata": {}}, "583cc2a1-4522-42e1-97a2-9eb43af009c7": {"node_ids": ["b660278c-71d7-4c5b-81eb-2e4dcbf35b47"], "metadata": {}}, "83e4072d-69c9-45b7-aa84-df03a189dbbd": {"node_ids": ["16afdd85-7778-4377-b2ed-6c953920d182"], "metadata": {}}, "5fd8b6cb-fdd6-4ee9-83d8-378cc053b5cf": {"node_ids": ["3641de24-697d-4d2d-8e90-13c5471a53f8"], "metadata": {}}, "2df91a24-28ac-4e38-ac89-756004ac32da": {"node_ids": ["4e1917ad-3b00-4d14-8b35-8a27ed49a9bb"], "metadata": {}}, "647a6fd9-b454-4162-b4c0-43fcb7aebd81": {"node_ids": ["b3367177-ca46-4712-a496-118b456da6a1", "6bb18606-62f9-42f2-b9fe-988e7331ccb9", "61d97130-d50f-4346-92f8-177bb4c2572f"], "metadata": {}}, "fa68fa24-1cd9-4956-977c-0cec993497f9": {"node_ids": ["175ebbd4-c6ce-4d9f-b8d0-5dd6213dc8a6"], "metadata": {}}, "67fff742-5934-42eb-985c-f9c7b1f9511a": {"node_ids": ["a9a22eaa-72df-41b2-bddf-56471da8553c"], "metadata": {}}, "8eab868c-53a7-4843-b798-37cc5094e4f7": {"node_ids": ["161ef1a3-de59-472a-bdcf-5ef96d7a39c7"], "metadata": {}}, "c8d1f8aa-5fdb-4a96-b021-1e0d7d044978": {"node_ids": ["e2c37621-12bb-4230-a45f-77fddfff2c72"], "metadata": {}}, "604e3dff-9cfb-4748-9492-688e1f174d6c": {"node_ids": ["8cf9d884-630d-4233-a196-f67b43712194"], "metadata": {}}, "7d6c80d2-3afd-4df4-b6d7-0b340b392b36": {"node_ids": ["e5a9bd15-f454-4241-bdcf-daf824d53d6f"], "metadata": {}}, "e5a412a5-a9a3-4fa2-970f-bf4058bdcbe0": {"node_ids": ["5e29a242-400b-454e-9bed-c3abfe771195"], "metadata": {}}, "9594be9a-4993-4601-9f4e-a3981d4a04c0": {"node_ids": ["d7a0dbe6-37da-44df-bf37-8243b7708f06"], "metadata": {}}, "c0711243-08bf-4086-b9fc-5774a0ee2e25": {"node_ids": ["7e27f9d0-840c-450f-a1fc-4fd3a1ea2816"], "metadata": {}}, "d588ffd3-5711-4f64-98f5-bf79c3956dc9": {"node_ids": ["0295739d-bdeb-405f-84b4-e1f1cd7561cc"], "metadata": {}}, "f1909eff-0d9c-4b18-852a-2dccf0ccf82f": {"node_ids": ["b4af83a2-0ea1-400f-bb3c-2d6ca33ac8fd"], "metadata": {}}, "410eb1d9-a93e-4c26-bc5d-183e320a0ea0": {"node_ids": ["db88b18b-bbd2-4e36-9be0-47b76709bee6"], "metadata": {}}, "c95f1c73-afa0-4f75-9e25-212c0928ef55": {"node_ids": ["7a4b989d-98ea-41b5-9478-d71b6cc75ad7"], "metadata": {}}, "bc973d61-03ab-4256-b701-9ff350baab69": {"node_ids": ["2ec27e9f-e50f-4b55-8779-ebf63cc585a3"], "metadata": {}}, "a052ba0a-7806-441e-b5a2-79e6ed5fc1ea": {"node_ids": ["7cc043c9-087d-4e14-bb4e-a85fb836ae3d"], "metadata": {}}, "04ca65dc-19ee-4f8d-871e-331e0cd07fd1": {"node_ids": ["3bc37c15-2206-4c6e-970c-05c8906c5a24"], "metadata": {}}, "e2b71924-c4b9-495e-80b8-b14f84ba5649": {"node_ids": ["ada8da20-2fd0-4b74-b020-a02839fe7c1e"], "metadata": {}}, "303eb7ae-d60c-43d0-9f1e-ae450942d931": {"node_ids": ["203ea0e8-1a38-4e33-92d5-c96e324c103a"], "metadata": {}}, "9de7cbd6-341b-48ee-a017-ce9ef6b84743": {"node_ids": ["ed8d8cc6-c397-4dcf-bb1f-ac62c76bef4c"], "metadata": {}}, "1a1ffe1c-b31f-44e0-8952-496d3d5a8e33": {"node_ids": ["55d3658c-741b-4857-b31e-bdc4c945fc73"], "metadata": {}}, "8c0d146a-8fc7-4a78-bf18-469ff90acd77": {"node_ids": ["a3c4e9f0-8e4a-45ad-a627-9b3099f74499"], "metadata": {}}, "50978624-76ed-4428-b2d1-6c4e0c5f8069": {"node_ids": ["0854306d-e195-4e08-80c6-ae7f10faac70"], "metadata": {}}, "49051029-1266-4d0a-b451-0fc451657621": {"node_ids": ["badd3ef3-55c2-43d2-b4e6-278bc6738ec6"], "metadata": {}}, "1eb4658d-9cfe-4913-b61f-448361be95af": {"node_ids": ["1d7ab131-d7d7-4c1b-a68c-733294763926"], "metadata": {}}, "69e90cff-2402-440d-82bb-f3a66fad6231": {"node_ids": ["cb165726-348b-4517-9b09-4c1b1c23da88"], "metadata": {}}, "ef7d7d2b-1c05-4139-a198-78fb9d94ede0": {"node_ids": ["12e59f0e-2b21-4476-9c81-45787e604310"], "metadata": {}}, "4f852e23-ea78-46c0-978b-bbe69590e74e": {"node_ids": ["d10134a1-7f73-4ab7-9fb0-50cf094150d9"], "metadata": {}}, "77656bbd-bc68-4de4-8c05-9ee50849a589": {"node_ids": ["aed10371-6873-4344-bff5-7be16c26b32c"], "metadata": {}}, "bb4c2d88-85ce-4483-8a93-49e1cd70f087": {"node_ids": ["79460a0c-7442-488e-8677-f8281c40faf0"], "metadata": {}}, "a0d3bda4-df0b-4927-aeab-5513dbd6db1d": {"node_ids": ["7693a93f-d7c8-4dbd-b817-edd77a3c37b8"], "metadata": {}}, "9fb90808-1164-4490-acfe-c4bdcda136c1": {"node_ids": ["5da9da63-70ab-4849-96bc-31dc14773c87"], "metadata": {}}, "5ffaafef-8eea-4b5c-acd1-eb84107fdc58": {"node_ids": ["91c48766-2baa-45dc-b270-50328f2e669b"], "metadata": {}}, "2ac76c9f-4d9f-412a-bb5a-6c842f8d5713": {"node_ids": ["f8618cb1-2e93-48ea-8fd8-d061c27568ba"], "metadata": {}}, "c63f80c2-c570-421b-8ce0-1940ca05c37d": {"node_ids": ["b608be89-6074-4cd6-af3f-026cbc87de60"], "metadata": {}}, "ffa9de92-783c-42c6-868c-a1d17e65e029": {"node_ids": ["02a8fe9e-5e91-486d-81fd-6e18dd479d4e"], "metadata": {}}, "6281d30c-9094-49ce-94cd-ee7e86a1a3b4": {"node_ids": ["d19d22cc-5e34-45b9-b9b8-6919dac159da"], "metadata": {}}, "7af1b126-3076-4e4b-8519-a4b04f0028b4": {"node_ids": ["60c297a3-ff13-49f0-be49-3cd2e584d92c"], "metadata": {}}, "3dc02176-5233-442e-aad0-2160b336d7af": {"node_ids": ["27401368-1156-49e6-b7b3-77f210675c2a"], "metadata": {}}, "705d7b9c-e513-4bf2-a12c-e575d6351af5": {"node_ids": ["858c4dd4-03c6-4538-a1e2-c19b558ed74f"], "metadata": {}}, "4c7f42a7-82b2-4c60-b171-ca377e8e1789": {"node_ids": ["a456ca6f-a673-44d3-8bf4-bbd53dd36e23"], "metadata": {}}, "ca77c1c6-cd8f-4681-8d94-231176cbf803": {"node_ids": ["30861bb0-b1b3-4338-9c52-e3be456be249"], "metadata": {}}, "b9a0fdae-09d2-46de-91f3-54cbe21e28b7": {"node_ids": ["646cc39a-72cf-4bd8-96ab-4df754b2633b"], "metadata": {}}, "ed338f32-1603-4903-bff9-c727a7cbfee2": {"node_ids": ["cb04f768-cb76-4137-ad2b-2d2f5743c81e"], "metadata": {}}, "c185283a-8098-4731-b558-0b2c1acfa9c6": {"node_ids": ["22543c26-59aa-417e-8d98-6b5147520a17"], "metadata": {}}, "3b64f8c9-69bb-47ac-b057-bc8d4ec39b1e": {"node_ids": ["278de718-a0ea-40c1-98b3-80ef20fbc00d"], "metadata": {}}, "127171e6-3173-460a-b645-06f98d71922b": {"node_ids": ["91bb3afe-7d8d-4ad3-982f-c90a186b9343"], "metadata": {}}, "b5be03dd-4331-40fe-b545-554a012f897e": {"node_ids": ["071da336-fc3b-46a8-a333-53e1cd5a0262"], "metadata": {}}, "59382a07-93e3-494f-9dfe-e3d16d2c09e5": {"node_ids": ["641128b1-c5c1-4480-a98f-3624f0166e87"], "metadata": {}}, "dcbf39fc-c954-4fa8-951f-84032aebc305": {"node_ids": ["e13143ec-3327-4262-9b33-2efb9cfc1640"], "metadata": {}}, "93f1baf8-fb11-4b82-928a-17aefb808c38": {"node_ids": ["cf5ff60f-5424-4405-887e-c5fede17ef3b"], "metadata": {}}, "f40f4bd7-fb4c-4649-870e-cc95f36db59e": {"node_ids": ["74224cb7-7488-4aae-88be-ecb1cb673804"], "metadata": {}}, "cb6baa2a-0651-4249-b97d-e74734426474": {"node_ids": ["5170ac24-8e90-49af-b994-ee621ce9b141"], "metadata": {}}, "b3633c6d-c4d2-4691-a480-5f20f81fbb68": {"node_ids": ["8fca81b1-2082-4c6f-9a38-1ddea6a798d6"], "metadata": {}}, "da5c5662-25d0-4073-928b-a64f9e191f50": {"node_ids": ["c06449a8-6975-4212-9043-b4762d7404a4"], "metadata": {}}, "6b1d719e-d81e-4c0d-b070-773bc7f81e2a": {"node_ids": ["62116df0-b6c0-49e1-b512-052e6a4e05dd"], "metadata": {}}, "cd40d92e-a162-4430-a535-64c25ec046d6": {"node_ids": ["ac37f395-6b57-4a48-8649-ebf93692343f"], "metadata": {}}, "cbd9c3f5-b11d-46f2-a392-ab6feea423ac": {"node_ids": ["9e66116e-851b-49ab-83ee-4d2311bd151e"], "metadata": {}}, "4c73b2cd-9102-472c-9c1f-862ed23ee710": {"node_ids": ["86793ee8-4749-4676-a36c-2edfec61288f"], "metadata": {}}, "f46d0e6f-3ac7-412d-9875-5d0f14146b24": {"node_ids": ["8764fd38-fa2e-457e-8ea1-caddd9a93f40"], "metadata": {}}, "4eb6bd79-7401-4bbc-baab-39ae9633e06e": {"node_ids": ["97c33909-fc15-4e5e-9718-5dc8ce7bf2ba"], "metadata": {}}, "83f5f799-51d3-47ce-bc89-20f5e8a8d3c2": {"node_ids": ["996af53f-0ea7-497e-a180-05d69e568a36"], "metadata": {}}, "0dd7b6e0-3bff-492e-9bcd-6d9726569b26": {"node_ids": ["58823e25-5dde-4f25-806b-4a61a2cfb4f6"], "metadata": {}}, "19c6ff98-622a-42ea-9bf3-2dad2f7ef57e": {"node_ids": ["ca2e1001-268b-4b6a-a728-b3adcfd23c29"], "metadata": {}}, "3c0ee000-3ca0-4edc-a8af-85115afa2540": {"node_ids": ["52e7fb52-5411-49c9-9ba6-a25ae44e5ea8"], "metadata": {}}, "90d37a5a-fe77-4920-8a91-84b732181f90": {"node_ids": ["b1836881-d30c-4070-b5fb-06881e0f0b18"], "metadata": {}}, "9e62ee3d-a66e-494d-af12-8a3dd42d23da": {"node_ids": ["04c665a0-1caa-4fc1-9bdd-64dd8ab1a7e0"], "metadata": {}}, "25be472e-b57f-467e-a0a3-2bff21539873": {"node_ids": ["a70868ec-d47e-4989-aa2f-69383fd64762"], "metadata": {}}, "19e6964e-bff5-4869-8ba4-d52bcdebb4ab": {"node_ids": ["eb2f8f52-4785-4671-a5b6-747c67e9818a"], "metadata": {}}, "669342df-2b2c-4d9c-bdac-b0f912f1fe30": {"node_ids": ["599b0f5e-5cf2-49a4-a5e7-7011b1f9c18f"], "metadata": {}}, "1fd7e7a1-cb63-48c4-9a28-39c82ff0ca8a": {"node_ids": ["469d5b59-9675-4594-ae11-e1381cd77c41"], "metadata": {}}, "cddb3235-1001-41fa-bc72-c1ad06299205": {"node_ids": ["128cf749-6187-459c-b09b-3df303f25c8f"], "metadata": {}}, "6f38b185-7980-4472-b1df-2eb3478c44b0": {"node_ids": ["84317923-e22f-4950-afa1-73e8ad3102f7"], "metadata": {}}, "939e5208-454f-425a-91bb-d09feb69d5aa": {"node_ids": ["45756963-9ac8-444b-b4e3-ad5e0ce50713"], "metadata": {}}, "e295a05a-ef97-4221-b144-c2623f6c84b7": {"node_ids": ["59c97513-2916-4a31-88cd-77e311d4a509"], "metadata": {}}, "e5c904aa-949f-44e8-811a-cd3774c005b4": {"node_ids": ["2ee10ff0-2793-45dd-a2ec-7b84ace9ac86"], "metadata": {}}, "48258350-76fa-4167-b6cd-bae13c800e09": {"node_ids": ["646efacf-af6c-4a6d-9f42-aceea70f4ad2"], "metadata": {}}, "33da2ebd-e32d-40ba-ac2a-d174cc1e3ebe": {"node_ids": ["34b2146f-5ea4-4c5e-8ae0-edf6deeadfc4"], "metadata": {}}, "73228003-e787-4615-a44d-033503047e99": {"node_ids": ["f30d40fb-eda5-4559-9745-444821221cf6"], "metadata": {}}, "4434854c-9367-4f0e-b2be-f7c2221adc4b": {"node_ids": ["69a4265d-3b93-45d3-8af6-69859f9e568b"], "metadata": {}}, "72d10b89-eb31-4cb8-9c01-b03f54b44249": {"node_ids": ["2f672f72-a271-4818-91fc-75d665313048"], "metadata": {}}, "17758270-c0e7-47dc-988c-4002cbf424be": {"node_ids": ["c5dddb36-bd7f-44c5-b793-174ddd23c71e"], "metadata": {}}, "6acf0f39-2664-4b48-a183-7ebdc425a1bb": {"node_ids": ["d42b69b5-696f-4b08-846d-bf9a21345083"], "metadata": {}}, "0d14f415-4b38-4518-8dae-455008022f25": {"node_ids": ["523f5a89-5d59-4470-b448-224a1e0cfdb7"], "metadata": {}}, "1c711c7f-ff23-40c5-bd38-eb70598b4a1e": {"node_ids": ["4ffa4832-66a9-4dbf-b27a-3722873587c0"], "metadata": {}}, "f21175c6-424b-4b64-958a-8f21186e4afa": {"node_ids": ["4ebbcc25-4af3-47f4-a58d-002e33921b0d"], "metadata": {}}, "6a59186f-e4e9-45db-b3bc-f85efd26cc7e": {"node_ids": ["a60c5149-5566-44e2-939c-6306e2bed813"], "metadata": {}}, "2531f001-a201-4dd6-af9c-3e29d31ca7dc": {"node_ids": ["12cafe24-5da5-4457-84bb-6a19b54c959f"], "metadata": {}}, "e9d15365-a661-4a07-bdc1-013e8a80f126": {"node_ids": ["27c12973-f4e5-490d-8021-e263eb8d537a"], "metadata": {}}, "b621d243-0fc9-494a-8fda-4a32e6f52a23": {"node_ids": ["e458261a-a397-43af-a5e8-4e6ae2eb564b"], "metadata": {}}, "e3417fe4-bc5f-4c5a-9f49-7b002c7cb787": {"node_ids": ["cee367f0-e76c-408d-b541-05e1c5eb2358"], "metadata": {}}, "402fe40b-9634-47e3-a037-049bc76075e1": {"node_ids": ["58e64269-15a9-4777-aa73-26465e12b76c"], "metadata": {}}, "a355d13d-c35f-4495-a9c1-d5c467ca07bc": {"node_ids": ["97afab4b-43f6-44ef-8ae9-4e43c97259cc", "b6484a01-873f-44b7-b1e9-0208c41590f1"], "metadata": {}}, "0d76b273-6e97-4b3d-aab6-4c6a4342ecb1": {"node_ids": ["e2f712ad-6951-4f00-adf8-32babc2f3230"], "metadata": {}}, "6c407c51-3177-4082-bb99-bcf26f067b6f": {"node_ids": ["14beb169-576e-44ed-9393-8b7cd1da657c"], "metadata": {}}, "dfd585fd-2aeb-42fe-83d6-b647a023dcca": {"node_ids": ["7e64662b-9397-4871-900d-e40ed842e5ba"], "metadata": {}}, "1c967c1c-a8b9-4078-b929-e41ea71ac58c": {"node_ids": ["ebe0791b-8306-4fbc-a1d3-14ce70c92eee"], "metadata": {}}, "a76799eb-c710-40b2-b21d-a601ca7a2d6c": {"node_ids": ["80b2ce00-1fb2-46f9-98b6-e66bbd50d2ca"], "metadata": {}}, "ae24197c-ac35-457e-986a-db3417e71d36": {"node_ids": ["a00bd1cd-1b65-4582-9884-dfebbc5691a0"], "metadata": {}}, "5be4c870-821d-4623-928b-9bbfc104d08f": {"node_ids": ["db8ad31e-dd89-4e7b-ac26-db5e41dcd890"], "metadata": {}}, "da5d409b-7c47-47fd-9955-4bb79c6df24c": {"node_ids": ["6af41ec4-1565-4b51-b0df-eb3b84d54150"], "metadata": {}}, "cb9ea2e3-17e9-4a63-b60d-b18b25eaf6ec": {"node_ids": ["c97c0258-8bd8-4197-bb65-9aa913f0fc25"], "metadata": {}}, "0c7a9cac-5c95-4186-842b-c8bc49e72b5c": {"node_ids": ["bc876dc0-eed3-4ab6-a914-b3e9e8f70aeb"], "metadata": {}}, "bc55620b-1b33-4da4-8eb3-bc237bd7fb1c": {"node_ids": ["36a84414-001e-436b-bd7b-983b46d678bd"], "metadata": {}}, "81eb9ea2-429e-4fd8-b027-442f79c1f171": {"node_ids": ["c0fd5afc-cd48-4332-bd7e-eb58b398460b"], "metadata": {}}}}